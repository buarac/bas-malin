# F6.2 - Forum & Discussions

**Score Priorité :** 60/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 6 - COMMUNAUTÉ  
**Effort estimé :** 10 jours  

## Description

Forum de discussions spécialisé en jardinage avec catégories thématiques, système Q&A, modération automatique et recherche avancée pour faciliter l'échange de connaissances et l'entraide entre jardiniers.

## User Stories

### US6.2.1 - Discussions Thématiques
**En tant qu'** jardinier  
**Je veux** participer à des discussions organisées par thème  
**Afin d'** approfondir mes connaissances dans des domaines spécifiques  

**Critères d'acceptation :**
- Catégories prédéfinies (légumes, fruits, fleurs, maladies, outils)
- Sous-forums par région climatique
- Fils de discussion avec épinglage des messages importants
- Tags automatiques selon contenu
- Abonnement aux sujets d'intérêt

### US6.2.2 - Système Questions/Réponses
**En tant qu'** débutant  
**Je veux** poser des questions et recevoir des réponses d'experts  
**Afin de** résoudre rapidement mes problèmes de jardinage  

**Critères d'acceptation :**
- Interface Q&A dédiée avec vote des meilleures réponses
- Système de récompenses pour réponses utiles
- Fermeture automatique questions résolues
- Recherche dans base de connaissances FAQ
- Suggestion de questions similaires

### US6.2.3 - Modération Intelligente
**En tant qu'** modérateur communautaire  
**Je veux** des outils de modération automatique  
**Afin de** maintenir la qualité des discussions  

**Critères d'acceptation :**
- Détection automatique spam/contenu inapproprié
- Signalement communautaire avec seuils
- Quarantaine automatique contenu suspect
- Outils modération en temps réel
- Historique actions de modération

## Architecture Technique

### Service Forum

```typescript
// src/services/forum/forum.service.ts
export interface ForumCategory {
  id: string;
  name: string;
  description: string;
  slug: string;
  parentId?: string;
  position: number;
  icon: string;
  color: string;
  isActive: boolean;
  permissions: CategoryPermissions;
  stats: CategoryStats;
}

export interface Discussion {
  id: string;
  categoryId: string;
  authorId: string;
  title: string;
  content: string;
  type: 'discussion' | 'question' | 'announcement';
  status: 'open' | 'closed' | 'solved' | 'archived';
  isPinned: boolean;
  isLocked: boolean;
  tags: string[];
  views: number;
  replies: number;
  lastReplyAt: Date;
  lastReplyBy: string;
  createdAt: Date;
  metadata: DiscussionMetadata;
}

export interface ForumPost {
  id: string;
  discussionId: string;
  authorId: string;
  content: string;
  parentId?: string; // Pour les réponses
  position: number;
  isAcceptedAnswer: boolean;
  votes: { up: number; down: number; };
  editHistory: EditEntry[];
  status: 'published' | 'moderated' | 'deleted';
  createdAt: Date;
  updatedAt: Date;
}

export class ForumService {
  private moderationService: ContentModerationService;
  private searchService: ForumSearchService;
  private notificationService: NotificationService;

  constructor(
    private prisma: PrismaClient,
    private aiService: AIService
  ) {
    this.moderationService = new ContentModerationService();
    this.searchService = new ForumSearchService();
    this.notificationService = new NotificationService();
  }

  async createDiscussion(
    authorId: string,
    discussionData: CreateDiscussionData
  ): Promise<Discussion> {
    // Modération automatique
    const moderationResult = await this.moderationService.moderateContent({
      title: discussionData.title,
      content: discussionData.content
    });

    // Auto-tagging avec IA
    const suggestedTags = await this.aiService.generateTags({
      title: discussionData.title,
      content: discussionData.content,
      category: discussionData.categoryId
    });

    const discussion = await this.prisma.discussion.create({
      data: {
        categoryId: discussionData.categoryId,
        authorId,
        title: discussionData.title,
        content: discussionData.content,
        type: discussionData.type || 'discussion',
        tags: [...discussionData.tags, ...suggestedTags],
        status: moderationResult.requiresReview ? 'moderated' : 'open',
        views: 0,
        replies: 0
      }
    });

    // Indexation pour recherche
    await this.searchService.indexDiscussion(discussion);

    // Notifications aux abonnés de la catégorie
    await this.notifySubscribers(discussionData.categoryId, discussion);

    return this.mapToDiscussion(discussion);
  }

  async replyToDiscussion(
    discussionId: string,
    authorId: string,
    content: string,
    parentId?: string
  ): Promise<ForumPost> {
    // Modération
    const moderationResult = await this.moderationService.moderateContent({ content });

    // Position dans le thread
    const position = await this.getNextPostPosition(discussionId);

    const post = await this.prisma.forumPost.create({
      data: {
        discussionId,
        authorId,
        content,
        parentId,
        position,
        status: moderationResult.requiresReview ? 'moderated' : 'published',
        votes: { up: 0, down: 0 }
      }
    });

    // Mise à jour stats discussion
    await this.updateDiscussionStats(discussionId);

    // Notification à l'auteur original et participants
    await this.notifyDiscussionParticipants(discussionId, post);

    return this.mapToForumPost(post);
  }

  async voteOnPost(
    userId: string,
    postId: string,
    voteType: 'up' | 'down'
  ): Promise<void> {
    // Vérifier vote existant
    const existingVote = await this.prisma.postVote.findUnique({
      where: { userId_postId: { userId, postId } }
    });

    if (existingVote) {
      if (existingVote.type === voteType) {
        // Retirer le vote
        await this.prisma.postVote.delete({
          where: { id: existingVote.id }
        });
        await this.updatePostVotes(postId, voteType, -1);
      } else {
        // Changer le vote
        await this.prisma.postVote.update({
          where: { id: existingVote.id },
          data: { type: voteType }
        });
        await this.updatePostVotes(postId, existingVote.type, -1);
        await this.updatePostVotes(postId, voteType, 1);
      }
    } else {
      // Nouveau vote
      await this.prisma.postVote.create({
        data: { userId, postId, type: voteType }
      });
      await this.updatePostVotes(postId, voteType, 1);
    }

    // Points de réputation
    const post = await this.prisma.forumPost.findUnique({
      where: { id: postId }
    });

    if (post && voteType === 'up') {
      await this.reputationService.awardPoints(post.authorId, 'helpful_vote', 2);
    }
  }

  async markAsAcceptedAnswer(
    discussionId: string,
    postId: string,
    userId: string
  ): Promise<void> {
    // Vérifier que l'utilisateur est l'auteur de la question
    const discussion = await this.prisma.discussion.findUnique({
      where: { id: discussionId }
    });

    if (!discussion || discussion.authorId !== userId) {
      throw new Error('Unauthorized to mark answer');
    }

    // Retirer autres réponses acceptées
    await this.prisma.forumPost.updateMany({
      where: {
        discussionId,
        isAcceptedAnswer: true
      },
      data: { isAcceptedAnswer: false }
    });

    // Marquer cette réponse comme acceptée
    await this.prisma.forumPost.update({
      where: { id: postId },
      data: { isAcceptedAnswer: true }
    });

    // Changer statut discussion
    await this.prisma.discussion.update({
      where: { id: discussionId },
      data: { status: 'solved' }
    });

    // Récompense pour la réponse acceptée
    const post = await this.prisma.forumPost.findUnique({
      where: { id: postId }
    });

    if (post) {
      await this.reputationService.awardPoints(post.authorId, 'solution_accepted', 15);
    }
  }

  async searchDiscussions(query: ForumSearchQuery): Promise<SearchResult<Discussion>> {
    return await this.searchService.searchDiscussions(query);
  }

  async getFAQ(categoryId?: string): Promise<FAQEntry[]> {
    // Questions fréquentes basées sur discussions populaires
    const popularSolved = await this.prisma.discussion.findMany({
      where: {
        ...(categoryId && { categoryId }),
        type: 'question',
        status: 'solved',
        views: { gte: 100 }
      },
      include: {
        acceptedAnswer: true,
        author: { select: { name: true, reputation: true } }
      },
      orderBy: [
        { views: 'desc' },
        { replies: 'desc' }
      ],
      take: 20
    });

    return popularSolved.map(discussion => ({
      question: discussion.title,
      answer: discussion.acceptedAnswer?.content || '',
      category: discussion.categoryId,
      views: discussion.views,
      askedBy: discussion.author.name,
      expertLevel: discussion.author.reputation?.level || 'beginner'
    }));
  }
}
```

### Interface Forum

```typescript
// src/app/forum/page.tsx
export default function ForumPage() {
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [discussions, setDiscussions] = useState<Discussion[]>([]);
  const [viewMode, setViewMode] = useState<'categories' | 'recent' | 'unanswered'>('categories');

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-6">
        <div className="max-w-6xl mx-auto">
          <div className="flex justify-between items-center mb-6">
            <div>
              <h1 className="text-2xl font-bold">Forum Jardiniers</h1>
              <p className="text-gray-600">Posez vos questions, partagez vos expériences</p>
            </div>
            
            <div className="flex gap-2">
              <Button variant="outline">
                <SearchIcon className="w-4 h-4 mr-2" />
                Rechercher
              </Button>
              <Button>
                <PlusIcon className="w-4 h-4 mr-2" />
                Nouvelle Discussion
              </Button>
            </div>
          </div>

          <div className="grid grid-cols-12 gap-6">
            {/* Sidebar catégories */}
            <div className="col-span-3">
              <ForumSidebar 
                selectedCategory={selectedCategory}
                onCategorySelect={setSelectedCategory}
              />
            </div>

            {/* Contenu principal */}
            <div className="col-span-9">
              {viewMode === 'categories' && !selectedCategory && (
                <CategoriesGrid />
              )}
              
              {(selectedCategory || viewMode !== 'categories') && (
                <DiscussionsList 
                  categoryId={selectedCategory}
                  viewMode={viewMode}
                />
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

const CategoriesGrid = () => {
  const { categories } = useForumCategories();

  return (
    <div className="grid grid-cols-2 gap-4">
      {categories.map(category => (
        <CategoryCard key={category.id} category={category} />
      ))}
    </div>
  );
};

const CategoryCard = ({ category }: { category: ForumCategory }) => {
  return (
    <Card className="p-4 hover:shadow-md transition-shadow cursor-pointer">
      <div className="flex items-start space-x-3">
        <div 
          className="w-12 h-12 rounded-lg flex items-center justify-center text-xl"
          style={{ backgroundColor: category.color + '20', color: category.color }}
        >
          {category.icon}
        </div>
        
        <div className="flex-1">
          <h3 className="font-semibold">{category.name}</h3>
          <p className="text-sm text-gray-600 mt-1">{category.description}</p>
          
          <div className="flex items-center space-x-4 mt-3 text-xs text-gray-500">
            <span>{category.stats.discussions} discussions</span>
            <span>{category.stats.posts} messages</span>
          </div>
        </div>
      </div>
    </Card>
  );
};

const DiscussionsList = ({ categoryId, viewMode }: {
  categoryId?: string;
  viewMode: string;
}) => {
  const { discussions, loading } = useDiscussions({ categoryId, viewMode });

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-lg font-semibold">
          {viewMode === 'recent' && 'Discussions Récentes'}
          {viewMode === 'unanswered' && 'Questions Sans Réponse'}
          {categoryId && 'Discussions de la Catégorie'}
        </h2>
        
        <Select value={viewMode}>
          <SelectTrigger className="w-48">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="recent">Plus récentes</SelectItem>
            <SelectItem value="popular">Plus populaires</SelectItem>
            <SelectItem value="unanswered">Sans réponse</SelectItem>
            <SelectItem value="solved">Résolues</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {loading ? (
        <div className="space-y-3">
          {[...Array(5)].map((_, i) => (
            <DiscussionSkeleton key={i} />
          ))}
        </div>
      ) : (
        <div className="space-y-3">
          {discussions.map(discussion => (
            <DiscussionListItem key={discussion.id} discussion={discussion} />
          ))}
        </div>
      )}
    </div>
  );
};

const DiscussionListItem = ({ discussion }: { discussion: Discussion }) => {
  return (
    <Card className="p-4 hover:bg-gray-50 transition-colors">
      <div className="flex items-start space-x-3">
        {/* Avatar auteur */}
        <Avatar className="h-10 w-10">
          <AvatarImage src={discussion.author.image} />
          <AvatarFallback>{discussion.author.name[0]}</AvatarFallback>
        </Avatar>
        
        {/* Contenu principal */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center space-x-2 mb-1">
            {discussion.isPinned && (
              <PinIcon className="w-4 h-4 text-yellow-500" />
            )}
            {discussion.type === 'question' && (
              <HelpCircleIcon className="w-4 h-4 text-blue-500" />
            )}
            {discussion.status === 'solved' && (
              <CheckCircleIcon className="w-4 h-4 text-green-500" />
            )}
          </div>
          
          <h3 className="font-medium truncate">
            <Link href={`/forum/discussions/${discussion.id}`}>
              {discussion.title}
            </Link>
          </h3>
          
          <div className="flex items-center space-x-4 mt-2 text-sm text-gray-500">
            <span>par {discussion.author.name}</span>
            <span>{formatDistanceToNow(discussion.createdAt)}</span>
            
            {discussion.tags.length > 0 && (
              <div className="flex space-x-1">
                {discussion.tags.slice(0, 2).map(tag => (
                  <Badge key={tag} variant="secondary" className="text-xs">
                    {tag}
                  </Badge>
                ))}
              </div>
            )}
          </div>
        </div>
        
        {/* Stats */}
        <div className="text-right text-sm">
          <div className="flex items-center space-x-3 text-gray-500">
            <span className="flex items-center">
              <MessageCircleIcon className="w-4 h-4 mr-1" />
              {discussion.replies}
            </span>
            <span className="flex items-center">
              <EyeIcon className="w-4 h-4 mr-1" />
              {discussion.views}
            </span>
          </div>
          
          {discussion.lastReplyAt && (
            <div className="mt-1 text-xs text-gray-500">
              Dernier: {formatDistanceToNow(discussion.lastReplyAt)}
            </div>
          )}
        </div>
      </div>
    </Card>
  );
};
```

## API Routes

```typescript
// src/app/api/forum/discussions/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const categoryId = searchParams.get('categoryId');
  const type = searchParams.get('type');
  const status = searchParams.get('status');
  const page = parseInt(searchParams.get('page') || '1');

  const discussions = await forumService.getDiscussions({
    categoryId: categoryId || undefined,
    type: type as 'discussion' | 'question' | undefined,
    status: status as any,
    page,
    limit: 20
  });

  return NextResponse.json(discussions);
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const discussionData = await request.json();
    const discussion = await forumService.createDiscussion(session.user.id, discussionData);

    return NextResponse.json({ discussionId: discussion.id });
  } catch (error) {
    return NextResponse.json({ error: 'Creation failed' }, { status: 500 });
  }
}

// src/app/api/forum/discussions/[id]/posts/route.ts
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { content, parentId } = await request.json();
    
    const post = await forumService.replyToDiscussion(
      params.id,
      session.user.id,
      content,
      parentId
    );

    return NextResponse.json({ postId: post.id });
  } catch (error) {
    return NextResponse.json({ error: 'Reply failed' }, { status: 500 });
  }
}
```

## Critères d'Acceptation Techniques

### Organisation du Contenu
- [ ] Catégories hiérarchiques avec permissions
- [ ] Tags automatiques par IA
- [ ] Épinglage et verrouillage des sujets
- [ ] Archivage automatique discussions inactives

### Système Q&A
- [ ] Marquage réponses acceptées
- [ ] Vote up/down sur réponses
- [ ] FAQ automatique basée sur popularité
- [ ] Recherche sémantique dans discussions

### Modération
- [ ] Détection automatique spam/trolling
- [ ] Quarantaine contenu suspect
- [ ] Modération communautaire par signalement
- [ ] Outils modérateurs en temps réel

## Couverture Exigences Architecture

- **EXG-002.1** : Base données forum optimisée
- **EXG-003.1** : Interface responsive forum
- **EXG-005.1** : IA pour auto-tagging et modération
- **EXG-007.1** : Notifications temps réel
- **EXG-009.1** : Métriques engagement forum

## Tests d'Acceptation

```typescript
// tests/integration/forum.test.ts
describe('Forum System', () => {
  test('création discussion avec auto-tagging', async () => {
    const discussionData = {
      title: 'Problème avec mes tomates',
      content: 'Mes tomates ont des taches noires...',
      categoryId: 'vegetables'
    };
    
    const discussion = await forumService.createDiscussion('user-1', discussionData);
    
    expect(discussion.tags).toContain('tomates');
    expect(discussion.tags).toContain('maladies');
  });

  test('système vote sur réponses', async () => {
    const post = await createTestForumPost();
    
    await forumService.voteOnPost('user-2', post.id, 'up');
    
    const updatedPost = await forumService.getPost(post.id);
    expect(updatedPost.votes.up).toBe(1);
  });

  test('recherche discussions fonctionne', async () => {
    const results = await forumService.searchDiscussions({
      query: 'tomates maladies',
      categoryId: 'vegetables'
    });
    
    expect(results.items).toHaveLength(greaterThan(0));
    expect(results.items[0].title).toContain('tomates');
  });
});
```

Cette spécification couvre un forum complet avec système Q&A, modération automatique et organisation thématique pour faciliter l'échange de connaissances en jardinage.