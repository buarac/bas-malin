# F3.2 - Moteur d'Insights IA

**Score Priorité :** 80/100  
**Statut :** PRIORITÉ MOYENNE  
**Epic :** EPIC 3 - PILIER COMPRENDRE  
**Effort estimé :** 24 jours  

## Description

Moteur d'intelligence artificielle avancé utilisant OpenAI GPT-4, Claude Pro et modèles locaux (Ollama) pour générer des insights personnalisés, recommandations intelligentes et analyses prédictives basées sur les données du jardin, météo et patterns historiques.

## User Stories

### US3.2.1 - Insights Personnalisés Multi-Sources
**En tant qu'** expert jardinier  
**Je veux** recevoir des insights intelligents basés sur toutes mes données  
**Afin de** optimiser mes décisions de jardinage  

**Critères d'acceptation :**
- Analyse croisée données IoT, météo, photos, interventions
- Insights contextuels selon saison et région climatique
- Recommandations personnalisées selon historique utilisateur
- Détection automatique de patterns et anomalies
- Score de confiance pour chaque recommandation

### US3.2.2 - Prédictions Saisonnières
**En tant qu'** utilisateur occasionnel  
**Je veux** des prédictions sur l'évolution de mon jardin  
**Afin de** planifier mes activités à long terme  

**Critères d'acceptation :**
- Prédiction rendement des cultures en cours
- Anticipation problèmes potentiels (maladies, parasites)
- Recommandations calendrier optimal des interventions
- Simulation impact changements climatiques
- Aide à la planification des prochaines saisons

### US3.2.3 - Explications Intelligentes
**En tant qu'** utilisateur débutant  
**Je veux** comprendre les raisons derrière les recommandations  
**Afin d'** apprendre et améliorer mes compétences  

**Critères d'acceptation :**
- Explications détaillées en langage naturel
- Références aux bonnes pratiques de jardinage
- Liens vers ressources pédagogiques
- Mode "apprentissage" avec conseils étape par étape
- Adaptation du niveau de complexité selon profil utilisateur

## Architecture Technique

### Moteur d'Insights Central

```typescript
// src/services/ai/insights-engine.service.ts
import { OpenAI } from 'openai';
import { Anthropic } from '@anthropic-ai/sdk';

export interface InsightRequest {
  userId: string;
  gardenId: string;
  context: InsightContext;
  type: InsightType;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  timeframe: 'immediate' | 'weekly' | 'monthly' | 'seasonal';
}

export interface InsightContext {
  currentData: {
    weather: WeatherData;
    iotReadings: SensorReading[];
    recentPhotos: PhotoAnalysis[];
    recentInterventions: Intervention[];
  };
  historicalData: {
    pastYearData: HistoricalDataSummary;
    seasonalPatterns: SeasonalPattern[];
    successMetrics: SuccessMetric[];
  };
  userProfile: {
    experienceLevel: 'beginner' | 'intermediate' | 'expert';
    preferences: UserPreferences;
    goals: GardenGoal[];
    constraints: GardenConstraint[];
  };
  gardenConfig: {
    location: GeoLocation;
    zones: ZoneConfiguration[];
    crops: ActiveCrop[];
    equipment: EquipmentConfiguration[];
  };
}

export interface GeneratedInsight {
  id: string;
  type: InsightType;
  category: InsightCategory;
  title: string;
  summary: string;
  detailedAnalysis: string;
  recommendations: Recommendation[];
  confidence: number; // 0-1
  evidenceScore: number; // 0-1
  urgency: 'low' | 'medium' | 'high' | 'critical';
  validUntil: Date;
  sources: DataSource[];
  metadata: InsightMetadata;
}

export type InsightType = 
  | 'optimization'
  | 'prediction'
  | 'alert'
  | 'educational'
  | 'planning'
  | 'troubleshooting';

export type InsightCategory =
  | 'watering'
  | 'fertilization'
  | 'pest_management'
  | 'disease_prevention'
  | 'harvest_timing'
  | 'planting_schedule'
  | 'climate_adaptation'
  | 'resource_optimization';

export class InsightsEngineService {
  private openaiClient: OpenAI;
  private anthropicClient: Anthropic;
  private ollamaService: OllamaService;
  private dataAggregationService: DataAggregationService;
  private knowledgeBaseService: KnowledgeBaseService;

  constructor(
    private prisma: PrismaClient,
    private configService: ConfigService,
    private cacheService: CacheService
  ) {
    this.openaiClient = new OpenAI({
      apiKey: configService.get('OPENAI_API_KEY')
    });
    this.anthropicClient = new Anthropic({
      apiKey: configService.get('ANTHROPIC_API_KEY')
    });
    this.ollamaService = new OllamaService();
    this.dataAggregationService = new DataAggregationService();
    this.knowledgeBaseService = new KnowledgeBaseService();
  }

  async generateInsights(request: InsightRequest): Promise<GeneratedInsight[]> {
    try {
      // 1. Collecte et agrégation des données
      const aggregatedData = await this.dataAggregationService.aggregateForInsights(request);
      
      // 2. Analyse avec modèles IA hybrides
      const analyses = await Promise.all([
        this.analyzeWithOpenAI(aggregatedData, request),
        this.analyzeWithClaude(aggregatedData, request),
        this.analyzeWithLocalModel(aggregatedData, request)
      ]);

      // 3. Fusion et validation des insights
      const fusedInsights = await this.fuseInsights(analyses);
      
      // 4. Enrichissement avec base de connaissances
      const enrichedInsights = await this.enrichWithKnowledgeBase(fusedInsights);
      
      // 5. Personnalisation selon profil utilisateur
      const personalizedInsights = await this.personalizeInsights(enrichedInsights, request.context.userProfile);
      
      // 6. Stockage et mise en cache
      await this.storeInsights(personalizedInsights, request.userId);
      
      return personalizedInsights;

    } catch (error) {
      console.error('Insights generation failed:', error);
      throw new Error('Failed to generate insights');
    }
  }

  private async analyzeWithOpenAI(data: AggregatedData, request: InsightRequest): Promise<AIAnalysis> {
    const systemPrompt = this.buildSystemPrompt('openai', request.context.userProfile);
    const dataPrompt = this.buildDataPrompt(data);
    
    const completion = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: dataPrompt }
      ],
      functions: [
        {
          name: 'generate_garden_insights',
          description: 'Generate comprehensive garden insights and recommendations',
          parameters: {
            type: 'object',
            properties: {
              insights: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    type: { type: 'string', enum: ['optimization', 'prediction', 'alert', 'educational'] },
                    category: { type: 'string' },
                    title: { type: 'string' },
                    analysis: { type: 'string' },
                    recommendations: {
                      type: 'array',
                      items: {
                        type: 'object',
                        properties: {
                          action: { type: 'string' },
                          priority: { type: 'string' },
                          reasoning: { type: 'string' },
                          timeline: { type: 'string' }
                        }
                      }
                    },
                    confidence: { type: 'number', minimum: 0, maximum: 1 },
                    evidence: { type: 'array', items: { type: 'string' } }
                  }
                }
              }
            }
          }
        }
      ],
      function_call: { name: 'generate_garden_insights' },
      temperature: 0.3
    });

    return {
      provider: 'openai',
      insights: JSON.parse(completion.choices[0].message.function_call!.arguments).insights,
      processingTime: Date.now() - data.requestTimestamp
    };
  }

  private async analyzeWithClaude(data: AggregatedData, request: InsightRequest): Promise<AIAnalysis> {
    const systemPrompt = this.buildSystemPrompt('claude', request.context.userProfile);
    const dataPrompt = this.buildDataPrompt(data);

    const response = await this.anthropicClient.messages.create({
      model: 'claude-3-opus-20240229',
      max_tokens: 4000,
      system: systemPrompt,
      messages: [
        {
          role: 'user',
          content: dataPrompt
        }
      ],
      tools: [
        {
          name: 'generate_garden_insights',
          description: 'Generate detailed garden insights with recommendations',
          input_schema: {
            type: 'object',
            properties: {
              insights: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    type: { type: 'string' },
                    category: { type: 'string' },
                    title: { type: 'string' },
                    detailed_analysis: { type: 'string' },
                    recommendations: { type: 'array' },
                    confidence_score: { type: 'number' },
                    supporting_evidence: { type: 'array' }
                  }
                }
              }
            }
          }
        }
      ]
    });

    return {
      provider: 'claude',
      insights: this.parseClaudeResponse(response),
      processingTime: Date.now() - data.requestTimestamp
    };
  }

  private async analyzeWithLocalModel(data: AggregatedData, request: InsightRequest): Promise<AIAnalysis> {
    // Utilisation d'Ollama pour modèle local (fallback)
    try {
      const prompt = this.buildLocalModelPrompt(data, request.context.userProfile);
      
      const response = await this.ollamaService.generate({
        model: 'llama2:13b',
        prompt,
        options: {
          temperature: 0.3,
          top_p: 0.9
        }
      });

      return {
        provider: 'ollama',
        insights: this.parseLocalModelResponse(response.response),
        processingTime: Date.now() - data.requestTimestamp
      };
    } catch (error) {
      console.warn('Local model analysis failed, skipping:', error);
      return {
        provider: 'ollama',
        insights: [],
        processingTime: 0
      };
    }
  }

  private async fuseInsights(analyses: AIAnalysis[]): Promise<GeneratedInsight[]> {
    const allInsights: Partial<GeneratedInsight>[] = [];
    
    // Collecte tous les insights des différents modèles
    for (const analysis of analyses) {
      allInsights.push(...analysis.insights);
    }

    // Fusion des insights similaires
    const fusedInsights = this.mergeSimilarInsights(allInsights);
    
    // Validation croisée et scoring
    const validatedInsights = await this.validateInsights(fusedInsights);
    
    // Tri par priorité et confiance
    return validatedInsights.sort((a, b) => {
      const scoreA = a.confidence * this.getUrgencyWeight(a.urgency);
      const scoreB = b.confidence * this.getUrgencyWeight(b.urgency);
      return scoreB - scoreA;
    });
  }

  private buildSystemPrompt(provider: string, userProfile: any): string {
    const basePrompt = `
Vous êtes un expert jardinier IA spécialisé dans l'analyse de données de jardinage.
Votre rôle est de générer des insights précis et actionnables pour optimiser la gestion du jardin.

Profil utilisateur:
- Niveau d'expérience: ${userProfile.experienceLevel}
- Objectifs: ${userProfile.goals?.join(', ') || 'Non spécifiés'}
- Contraintes: ${userProfile.constraints?.join(', ') || 'Aucune'}

Instructions:
1. Analysez les données fournies de manière holistique
2. Identifiez les patterns, tendances et anomalies
3. Générez des recommandations spécifiques et actionnables
4. Adaptez le niveau de détail selon l'expérience utilisateur
5. Indiquez le niveau de confiance pour chaque insight
6. Priorisez selon l'urgence et l'impact potentiel

Format de réponse: Utilisez la fonction fournie pour structurer votre réponse.
`;

    if (provider === 'claude') {
      return basePrompt + `
Spécialités Claude:
- Analysez en profondeur les corrélations entre données
- Fournissez des explications détaillées et pédagogiques
- Considérez les aspects écologiques et durables
`;
    } else if (provider === 'openai') {
      return basePrompt + `
Spécialités GPT-4:
- Optimisez les stratégies de rendement
- Analysez les patterns temporels complexes
- Fournissez des recommandations basées sur les meilleures pratiques
`;
    }

    return basePrompt;
  }

  private buildDataPrompt(data: AggregatedData): string {
    return `
Données actuelles du jardin (${new Date(data.timestamp).toLocaleDateString('fr-FR')}):

MÉTÉO:
- Température: ${data.weather.temperature}°C
- Humidité: ${data.weather.humidity}%
- Précipitations: ${data.weather.precipitation}mm
- Prévisions 7j: ${data.weather.forecast}

CAPTEURS IoT:
${data.iotReadings.map(reading => 
  `- ${reading.sensorType}: ${reading.value}${reading.unit} (${reading.location})`
).join('\n')}

DERNIÈRES PHOTOS:
${data.photos.map(photo => 
  `- ${photo.timestamp}: ${photo.aiAnalysis.summary} (confiance: ${photo.aiAnalysis.confidence})`
).join('\n')}

INTERVENTIONS RÉCENTES:
${data.interventions.map(intervention => 
  `- ${intervention.date}: ${intervention.type} - ${intervention.description}`
).join('\n')}

DONNÉES HISTORIQUES:
- Rendement moyen saison passée: ${data.historical.averageYield}
- Problèmes récurrents: ${data.historical.commonIssues.join(', ')}
- Cycles optimaux identifiés: ${data.historical.optimalCycles.join(', ')}

CULTURES ACTUELLES:
${data.activeCrops.map(crop => 
  `- ${crop.variety}: plantée le ${crop.plantingDate}, stade ${crop.growthStage}`
).join('\n')}

Générez des insights personnalisés pour optimiser la gestion de ce jardin.
`;
  }
}
```

### Service de Base de Connaissances

```typescript
// src/services/ai/knowledge-base.service.ts
export class KnowledgeBaseService {
  private embeddings: Map<string, number[]> = new Map();
  private vectorDatabase: VectorDatabase;

  constructor(private openaiClient: OpenAI) {
    this.vectorDatabase = new VectorDatabase();
    this.initializeKnowledgeBase();
  }

  private async initializeKnowledgeBase(): Promise<void> {
    // Chargement des bases de connaissances
    const knowledgeSources = [
      await this.loadPlantVarietiesKnowledge(),
      await this.loadPestManagementKnowledge(),
      await this.loadSeasonalPracticesKnowledge(),
      await this.loadClimateAdaptationKnowledge(),
      await this.loadOrganicPracticesKnowledge()
    ];

    // Création des embeddings pour recherche sémantique
    for (const source of knowledgeSources) {
      await this.indexKnowledgeSource(source);
    }
  }

  private async loadPlantVarietiesKnowledge(): Promise<KnowledgeSource> {
    return {
      id: 'plant_varieties',
      name: 'Variétés et Caractéristiques',
      content: [
        {
          topic: 'tomate_cherry',
          data: {
            plantingPeriod: 'mars-mai',
            harvestPeriod: 'juin-octobre',
            waterNeeds: 'modéré-élevé',
            companionPlants: ['basilic', 'persil', 'œillet'],
            commonDiseases: ['mildiou', 'alternariose'],
            optimalTemperature: '18-25°C',
            soilPH: '6.0-7.0',
            tips: [
              'Installer tuteurs dès la plantation',
              'Pincer gourmands régulièrement',
              'Arroser au pied pour éviter maladies'
            ]
          }
        },
        // ... autres variétés
      ]
    };
  }

  async findRelevantKnowledge(query: string, limit: number = 5): Promise<KnowledgeResult[]> {
    // Création embedding de la requête
    const queryEmbedding = await this.createEmbedding(query);
    
    // Recherche par similarité vectorielle
    const similarResults = await this.vectorDatabase.findSimilar(queryEmbedding, limit);
    
    return similarResults.map(result => ({
      content: result.content,
      relevanceScore: result.similarity,
      source: result.metadata.source,
      topic: result.metadata.topic
    }));
  }

  private async createEmbedding(text: string): Promise<number[]> {
    const response = await this.openaiClient.embeddings.create({
      model: 'text-embedding-3-small',
      input: text
    });

    return response.data[0].embedding;
  }

  async enrichInsightWithKnowledge(insight: Partial<GeneratedInsight>): Promise<GeneratedInsight> {
    // Recherche de connaissances pertinentes
    const relevantKnowledge = await this.findRelevantKnowledge(
      `${insight.category} ${insight.title} ${insight.summary}`,
      3
    );

    // Enrichissement des recommandations
    const enrichedRecommendations = await this.enrichRecommendations(
      insight.recommendations || [],
      relevantKnowledge
    );

    // Ajout de références pédagogiques
    const educationalReferences = this.extractEducationalReferences(relevantKnowledge);

    return {
      ...insight,
      recommendations: enrichedRecommendations,
      metadata: {
        ...insight.metadata,
        knowledgeReferences: relevantKnowledge.map(k => k.source),
        educationalLinks: educationalReferences
      }
    } as GeneratedInsight;
  }
}
```

### Interface Insights & Recommandations

```typescript
// src/app/insights/page.tsx
export default function InsightsPage() {
  const { insights, isLoading, generateNewInsights } = useInsights();
  const { deviceType } = useResponsive();

  if (deviceType === 'tv') {
    return <InsightsTVDashboard insights={insights} />;
  }

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold">Insights IA</h1>
            <p className="text-gray-600 mt-1">
              Recommandations intelligentes pour votre jardin
            </p>
          </div>
          
          <Button 
            onClick={generateNewInsights}
            disabled={isLoading}
            leftIcon={isLoading ? <Loader2Icon className="animate-spin" /> : <SparklesIcon />}
          >
            {isLoading ? 'Génération...' : 'Nouveaux Insights'}
          </Button>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Insights prioritaires */}
          <div className="lg:col-span-2">
            <PriorityInsightsSection insights={insights.filter(i => i.urgency === 'high')} />
            <AllInsightsSection insights={insights} />
          </div>
          
          {/* Sidebar */}
          <div className="space-y-6">
            <InsightsStatsCard insights={insights} />
            <QuickActionsPanel insights={insights} />
            <LearningResourcesPanel />
          </div>
        </div>
      </div>
    </div>
  );
}

const PriorityInsightsSection = ({ insights }: { insights: GeneratedInsight[] }) => {
  if (insights.length === 0) return null;

  return (
    <section className="mb-8">
      <h2 className="text-xl font-semibold mb-4 flex items-center">
        <AlertTriangleIcon className="w-5 h-5 mr-2 text-orange-500" />
        Insights Prioritaires
      </h2>
      
      <div className="space-y-4">
        {insights.map(insight => (
          <PriorityInsightCard key={insight.id} insight={insight} />
        ))}
      </div>
    </section>
  );
};

const PriorityInsightCard = ({ insight }: { insight: GeneratedInsight }) => {
  const [expanded, setExpanded] = useState(false);

  return (
    <Card className="border-orange-200 bg-orange-50/50">
      <CardContent className="p-6">
        <div className="flex justify-between items-start mb-4">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-2">
              <Badge variant="warning" className="text-xs">
                {insight.urgency.toUpperCase()}
              </Badge>
              <Badge variant="outline" className="text-xs">
                {insight.category}
              </Badge>
              <div className="flex items-center text-xs text-gray-500">
                <TrendingUpIcon className="w-3 h-3 mr-1" />
                {Math.round(insight.confidence * 100)}% confiance
              </div>
            </div>
            
            <h3 className="text-lg font-semibold text-orange-900 mb-2">
              {insight.title}
            </h3>
            
            <p className="text-orange-800 text-sm mb-3">
              {insight.summary}
            </p>
          </div>
        </div>

        {/* Recommandations prioritaires */}
        <div className="space-y-2 mb-4">
          {insight.recommendations.slice(0, 2).map((rec, index) => (
            <div key={index} className="flex items-start space-x-2">
              <CheckCircleIcon className="w-4 h-4 text-green-600 mt-0.5 flex-shrink-0" />
              <div className="text-sm">
                <span className="font-medium">{rec.action}</span>
                {rec.timeline && (
                  <span className="text-gray-600 ml-2">({rec.timeline})</span>
                )}
              </div>
            </div>
          ))}
        </div>

        {/* Boutons d'action */}
        <div className="flex gap-2">
          <Button 
            size="sm" 
            variant="outline"
            onClick={() => setExpanded(!expanded)}
          >
            {expanded ? 'Réduire' : 'Détails'}
          </Button>
          
          <Button size="sm">
            Appliquer
          </Button>
        </div>

        {/* Détails étendus */}
        {expanded && (
          <div className="mt-4 pt-4 border-t border-orange-200">
            <div className="prose prose-sm max-w-none">
              <h4 className="text-sm font-semibold mb-2">Analyse détaillée</h4>
              <p className="text-sm text-gray-700 mb-4">
                {insight.detailedAnalysis}
              </p>
              
              {insight.recommendations.length > 2 && (
                <div>
                  <h4 className="text-sm font-semibold mb-2">Toutes les recommandations</h4>
                  <ul className="space-y-1">
                    {insight.recommendations.slice(2).map((rec, index) => (
                      <li key={index} className="text-sm text-gray-700">
                        • {rec.action}
                        {rec.reasoning && (
                          <span className="text-gray-500 ml-2">- {rec.reasoning}</span>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

const AllInsightsSection = ({ insights }: { insights: GeneratedInsight[] }) => {
  const [filterCategory, setFilterCategory] = useState<string>('all');
  const [sortBy, setSortBy] = useState<'confidence' | 'urgency' | 'date'>('confidence');

  const filteredAndSortedInsights = useMemo(() => {
    let filtered = insights;
    
    if (filterCategory !== 'all') {
      filtered = insights.filter(i => i.category === filterCategory);
    }

    return filtered.sort((a, b) => {
      switch (sortBy) {
        case 'confidence':
          return b.confidence - a.confidence;
        case 'urgency':
          const urgencyWeight = { critical: 4, high: 3, medium: 2, low: 1 };
          return urgencyWeight[b.urgency] - urgencyWeight[a.urgency];
        case 'date':
          return new Date(b.metadata.generatedAt).getTime() - new Date(a.metadata.generatedAt).getTime();
        default:
          return 0;
      }
    });
  }, [insights, filterCategory, sortBy]);

  return (
    <section>
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold">Tous les Insights</h2>
        
        <div className="flex gap-2">
          <select 
            value={filterCategory}
            onChange={(e) => setFilterCategory(e.target.value)}
            className="text-sm border border-gray-300 rounded px-2 py-1"
          >
            <option value="all">Toutes catégories</option>
            <option value="watering">Arrosage</option>
            <option value="fertilization">Fertilisation</option>
            <option value="pest_management">Parasites</option>
            <option value="harvest_timing">Récolte</option>
          </select>
          
          <select 
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value as any)}
            className="text-sm border border-gray-300 rounded px-2 py-1"
          >
            <option value="confidence">Confiance</option>
            <option value="urgency">Urgence</option>
            <option value="date">Date</option>
          </select>
        </div>
      </div>

      <div className="grid grid-cols-1 gap-4">
        {filteredAndSortedInsights.map(insight => (
          <InsightCard key={insight.id} insight={insight} />
        ))}
      </div>
    </section>
  );
};
```

## API Routes

```typescript
// src/app/api/insights/generate/route.ts
export async function POST(request: Request) {
  try {
    const { gardenId, timeframe, categories } = await request.json();
    
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Création de la requête d'insights
    const insightRequest: InsightRequest = {
      userId: session.user.id,
      gardenId,
      context: await buildInsightContext(gardenId),
      type: 'optimization',
      priority: 'medium',
      timeframe: timeframe || 'weekly'
    };

    // Génération des insights
    const insights = await insightsEngineService.generateInsights(insightRequest);
    
    return NextResponse.json({
      insights: insights.map(insight => ({
        id: insight.id,
        type: insight.type,
        category: insight.category,
        title: insight.title,
        summary: insight.summary,
        confidence: insight.confidence,
        urgency: insight.urgency,
        recommendations: insight.recommendations.slice(0, 3), // Limite pour l'API
        generatedAt: new Date().toISOString()
      }))
    });

  } catch (error) {
    console.error('Insights generation failed:', error);
    return NextResponse.json(
      { error: 'Failed to generate insights' },
      { status: 500 }
    );
  }
}

// src/app/api/insights/[insightId]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { insightId: string } }
) {
  const insight = await prisma.insightIA.findUnique({
    where: { id: params.insightId },
    include: {
      sources: true,
      recommendations: true
    }
  });

  if (!insight) {
    return NextResponse.json({ error: 'Insight not found' }, { status: 404 });
  }

  return NextResponse.json({
    id: insight.id,
    type: insight.type,
    category: insight.categorie,
    title: insight.titre,
    summary: insight.resume,
    detailedAnalysis: insight.analyseDetaillee,
    confidence: insight.confiance,
    urgency: insight.urgence,
    recommendations: insight.recommendations,
    sources: insight.sources,
    generatedAt: insight.createdAt,
    validUntil: insight.valideJusqu
  });
}
```

## Critères d'Acceptation Techniques

### Intelligence
- [ ] Précision recommandations > 80%
- [ ] Temps de génération insights < 30s
- [ ] Support multi-modèles IA (OpenAI + Claude + Local)
- [ ] Personnalisation selon profil utilisateur

### Performance
- [ ] Cache intelligent des analyses répétitives
- [ ] Fallback local si APIs indisponibles
- [ ] Traitement async pour insights complexes
- [ ] Optimisation coûts API avec modèles hybrides

### Qualité
- [ ] Score de confiance calibré
- [ ] Validation croisée entre modèles
- [ ] Base de connaissances enrichie
- [ ] Explications pédagogiques adaptées

## Couverture Exigences Architecture

- **EXG-005.1** : IA hybride OpenAI + Claude + Local
- **EXG-005.2** : Analyse prédictive et recommandations
- **EXG-002.2** : Cache Redis pour performances
- **EXG-001.3** : Interface adaptative multi-device
- **EXG-009.1** : Monitoring utilisation IA

## Tests d'Acceptation

```typescript
// tests/integration/insights-engine.test.ts
describe('Insights Engine', () => {
  test('génère insights pertinents avec données complètes', async () => {
    const mockRequest = createMockInsightRequest();
    
    const insights = await insightsEngineService.generateInsights(mockRequest);
    
    expect(insights).toHaveLength(greaterThan(0));
    expect(insights[0].confidence).toBeGreaterThan(0.6);
    expect(insights[0].recommendations).toHaveLength(greaterThan(0));
  });

  test('fusionne correctement analyses multi-modèles', async () => {
    const openaiAnalysis = createMockOpenAIAnalysis();
    const claudeAnalysis = createMockClaudeAnalysis();
    
    const fused = await insightsEngineService.fuseInsights([openaiAnalysis, claudeAnalysis]);
    
    expect(fused[0].confidence).toBeGreaterThan(0.7); // Confiance augmentée par consensus
  });

  test('enrichit avec base de connaissances', async () => {
    const insight = createBasicInsight();
    
    const enriched = await knowledgeBaseService.enrichInsightWithKnowledge(insight);
    
    expect(enriched.metadata.knowledgeReferences).toHaveLength(greaterThan(0));
    expect(enriched.metadata.educationalLinks).toBeDefined();
  });
});
```

Cette spécification couvre un moteur d'insights IA complet et intelligent qui fournit des recommandations personnalisées et actionnables pour optimiser la gestion du jardin.