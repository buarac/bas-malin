# F4.3 - Automatisation & Scénarios

**Score Priorité :** 75/100  
**Statut :** PRIORITÉ MODÉRÉE  
**Epic :** EPIC 4 - PILIER OPTIMISER  
**Effort estimé :** 20 jours  

## Description

Système d'automatisation avancé avec créateur de scénarios no-code, déclencheurs intelligents basés sur l'IA, intégration IoT/Home Assistant et exécution d'actions automatiques pour optimiser la gestion du jardin sans intervention manuelle.

## User Stories

### US4.3.1 - Créateur de Scénarios Visual
**En tant qu'** expert jardinier  
**Je veux** créer des automatisations complexes visuellement  
**Afin d'** optimiser mon jardin sans compétences techniques  

**Critères d'acceptation :**
- Interface drag & drop pour création de workflows
- Bibliothèque de déclencheurs prédéfinis (météo, capteurs, planning)
- Actions configurables (arrosage, notifications, éclairage)
- Test et simulation avant activation
- Historique des exécutions avec logs détaillés

### US4.3.2 - Automatisations Intelligentes
**En tant qu'** utilisateur occasionnel  
**Je veux** que mon jardin s'auto-gère intelligemment  
**Afin de** maintenir des conditions optimales sans effort  

**Critères d'acceptation :**
- Suggestions d'automatisations basées sur l'IA
- Apprentissage des patterns et préférences utilisateur
- Adaptation automatique selon conditions météo
- Gestion des conflits entre scénarios
- Mode urgence avec priorités définies

### US4.3.3 - Intégration Domotique Complète
**En tant qu'** utilisateur avancé  
**Je veux** intégrer mon jardin à ma domotique existante  
**Afin de** créer un écosystème intelligent global  

**Critères d'acceptation :**
- Synchronisation bidirectionnelle Home Assistant
- Support Node-RED pour workflows avancés
- API REST pour intégrations tierces
- Webhooks entrants et sortants
- Compatible protocoles IoT (Zigbee, Z-Wave, Wi-Fi)

## Architecture Technique

### Moteur d'Automatisation

```typescript
// src/services/automation/automation-engine.service.ts
export interface AutomationScenario {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  triggers: TriggerDefinition[];
  conditions: ConditionDefinition[];
  actions: ActionDefinition[];
  schedule: ScheduleDefinition;
  priority: number; // 1-10, plus élevé = priorité
  metadata: ScenarioMetadata;
  createdAt: Date;
  lastExecuted?: Date;
  executionCount: number;
}

export interface TriggerDefinition {
  id: string;
  type: TriggerType;
  config: TriggerConfig;
  enabled: boolean;
}

export type TriggerType = 
  | 'sensor_threshold'    // Capteur dépasse seuil
  | 'weather_condition'   // Condition météo
  | 'time_schedule'       // Programmation horaire
  | 'manual_trigger'      // Déclenchement manuel
  | 'ai_recommendation'   // Recommandation IA
  | 'plant_growth_stage'  // Stade de croissance
  | 'harvest_ready'       // Récolte prête
  | 'external_webhook';   // Webhook externe

export interface ActionDefinition {
  id: string;
  type: ActionType;
  config: ActionConfig;
  delay?: number; // en secondes
  retry?: RetryConfig;
}

export type ActionType =
  | 'irrigation_start'    // Démarrer arrosage
  | 'irrigation_stop'     // Arrêter arrosage
  | 'notification_send'   // Envoyer notification
  | 'light_control'       // Contrôle éclairage
  | 'ventilation_control' // Contrôle ventilation
  | 'data_collection'     // Collecter données
  | 'ai_analysis'         // Déclencher analyse IA
  | 'home_assistant'      // Action Home Assistant
  | 'webhook_call';       // Appel webhook

export class AutomationEngineService extends EventEmitter {
  private activeScenarios: Map<string, AutomationScenario> = new Map();
  private executionQueue: ExecutionQueue;
  private conditionEvaluator: ConditionEvaluator;
  private actionExecutor: ActionExecutor;

  constructor(
    private prisma: PrismaClient,
    private iotService: IoTService,
    private weatherService: WeatherService,
    private homeAssistantService: HomeAssistantService,
    private aiService: AIService
  ) {
    super();
    this.executionQueue = new ExecutionQueue();
    this.conditionEvaluator = new ConditionEvaluator();
    this.actionExecutor = new ActionExecutor();
    this.initializeEngine();
  }

  private async initializeEngine(): Promise<void> {
    // Chargement des scénarios actifs
    await this.loadActiveScenarios();
    
    // Setup des listeners pour déclencheurs
    this.setupTriggerListeners();
    
    // Démarrage de la queue d'exécution
    this.executionQueue.start();
    
    console.log(`Automation engine initialized with ${this.activeScenarios.size} scenarios`);
  }

  private async loadActiveScenarios(): Promise<void> {
    const scenarios = await this.prisma.scenarioAutomatisation.findMany({
      where: { enabled: true },
      include: {
        declencheurs: true,
        conditions: true,
        actions: true
      }
    });

    for (const scenario of scenarios) {
      this.activeScenarios.set(scenario.id, this.mapToScenario(scenario));
    }
  }

  private setupTriggerListeners(): void {
    // Listener pour capteurs IoT
    this.iotService.on('sensorReading', (reading) => {
      this.evaluateSensorTriggers(reading);
    });

    // Listener pour conditions météo
    this.weatherService.on('weatherUpdate', (weather) => {
      this.evaluateWeatherTriggers(weather);
    });

    // Listener pour croissance des plantes
    this.on('plantGrowthStageChange', (event) => {
      this.evaluateGrowthTriggers(event);
    });

    // Listener pour recommandations IA
    this.aiService.on('recommendationGenerated', (recommendation) => {
      this.evaluateAITriggers(recommendation);
    });

    // Setup timers pour déclencheurs horaires
    this.setupScheduledTriggers();
  }

  private async evaluateSensorTriggers(reading: SensorReading): Promise<void> {
    const relevantScenarios = Array.from(this.activeScenarios.values())
      .filter(scenario => 
        scenario.triggers.some(trigger => 
          trigger.type === 'sensor_threshold' && 
          trigger.config.sensorId === reading.sensorId
        )
      );

    for (const scenario of relevantScenarios) {
      const sensorTriggers = scenario.triggers.filter(t => t.type === 'sensor_threshold');
      
      for (const trigger of sensorTriggers) {
        if (this.evaluateSensorThreshold(trigger, reading)) {
          await this.queueScenarioExecution(scenario, {
            triggerType: 'sensor_threshold',
            triggerId: trigger.id,
            data: reading
          });
        }
      }
    }
  }

  private evaluateSensorThreshold(trigger: TriggerDefinition, reading: SensorReading): boolean {
    const { operator, value, hysteresis } = trigger.config;
    
    switch (operator) {
      case 'greater_than':
        return reading.value > value;
      case 'less_than':
        return reading.value < value;
      case 'equals':
        return Math.abs(reading.value - value) < (hysteresis || 0.1);
      case 'between':
        return reading.value >= trigger.config.minValue && reading.value <= trigger.config.maxValue;
      default:
        return false;
    }
  }

  private async queueScenarioExecution(
    scenario: AutomationScenario, 
    context: ExecutionContext
  ): Promise<void> {
    // Vérification des conditions
    const conditionsValid = await this.conditionEvaluator.evaluate(scenario.conditions, context);
    if (!conditionsValid) {
      console.log(`Scenario ${scenario.name} conditions not met, skipping execution`);
      return;
    }

    // Vérification des conflits
    const hasConflicts = await this.checkScenarioConflicts(scenario, context);
    if (hasConflicts) {
      console.log(`Scenario ${scenario.name} has conflicts, resolving...`);
      await this.resolveConflicts(scenario, context);
      return;
    }

    // Ajout à la queue d'exécution
    const execution: QueuedExecution = {
      id: generateId(),
      scenarioId: scenario.id,
      scenario,
      context,
      priority: scenario.priority,
      scheduledAt: new Date(),
      status: 'queued'
    };

    await this.executionQueue.enqueue(execution);
    
    this.emit('scenarioQueued', { scenario, context });
  }

  async executeScenario(execution: QueuedExecution): Promise<ExecutionResult> {
    const startTime = Date.now();
    const { scenario, context } = execution;
    
    console.log(`Executing scenario: ${scenario.name}`);

    try {
      // Marquer comme en cours
      execution.status = 'executing';
      execution.startedAt = new Date();

      const actionResults: ActionResult[] = [];

      // Exécution des actions en séquence
      for (const action of scenario.actions) {
        try {
          // Délai si spécifié
          if (action.delay > 0) {
            await this.delay(action.delay * 1000);
          }

          const actionResult = await this.actionExecutor.execute(action, context);
          actionResults.push(actionResult);

          // Arrêt si action critique échoue
          if (!actionResult.success && action.config.critical) {
            throw new Error(`Critical action failed: ${actionResult.error}`);
          }

        } catch (error) {
          console.error(`Action ${action.id} failed:`, error);
          
          // Retry si configuré
          if (action.retry) {
            const retryResult = await this.retryAction(action, context, action.retry);
            actionResults.push(retryResult);
          } else {
            actionResults.push({
              actionId: action.id,
              success: false,
              error: error.message,
              executedAt: new Date()
            });
          }
        }
      }

      // Résultat final
      const result: ExecutionResult = {
        executionId: execution.id,
        scenarioId: scenario.id,
        success: actionResults.every(r => r.success),
        startTime: execution.startedAt!,
        endTime: new Date(),
        duration: Date.now() - startTime,
        actionResults,
        context
      };

      // Stockage du résultat
      await this.storeExecutionResult(result);
      
      // Mise à jour statistiques
      await this.updateScenarioStats(scenario.id, result);

      this.emit('scenarioExecuted', result);
      
      return result;

    } catch (error) {
      console.error(`Scenario execution failed: ${scenario.name}`, error);
      
      const result: ExecutionResult = {
        executionId: execution.id,
        scenarioId: scenario.id,
        success: false,
        startTime: execution.startedAt!,
        endTime: new Date(),
        duration: Date.now() - startTime,
        error: error.message,
        actionResults: [],
        context
      };

      await this.storeExecutionResult(result);
      this.emit('scenarioFailed', result);
      
      return result;
    }
  }

  private async checkScenarioConflicts(
    scenario: AutomationScenario, 
    context: ExecutionContext
  ): Promise<boolean> {
    // Vérification des ressources partagées
    const resourceConflicts = await this.checkResourceConflicts(scenario);
    
    // Vérification des scénarios mutuellement exclusifs
    const exclusionConflicts = await this.checkExclusionConflicts(scenario);
    
    // Vérification des priorités en cours
    const priorityConflicts = await this.checkPriorityConflicts(scenario);

    return resourceConflicts || exclusionConflicts || priorityConflicts;
  }

  private async resolveConflicts(
    scenario: AutomationScenario,
    context: ExecutionContext
  ): Promise<void> {
    // Stratégies de résolution de conflits
    const strategies = [
      this.resolveBySuspendingLowerPriority,
      this.resolveByQueueing,
      this.resolveByMerging,
      this.resolveByUserDecision
    ];

    for (const strategy of strategies) {
      const resolved = await strategy.call(this, scenario, context);
      if (resolved) {
        break;
      }
    }
  }
}
```

### Visual Scenario Builder

```typescript
// src/services/automation/scenario-builder.service.ts
export interface ScenarioBuilderNode {
  id: string;
  type: 'trigger' | 'condition' | 'action' | 'delay' | 'parallel' | 'conditional';
  position: { x: number; y: number };
  data: NodeData;
  connections: NodeConnection[];
}

export interface NodeConnection {
  from: string;
  to: string;
  type: 'success' | 'failure' | 'conditional';
  condition?: string;
}

export class ScenarioBuilderService {
  private nodeRegistry: Map<string, NodeDefinition> = new Map();
  private templateLibrary: Map<string, ScenarioTemplate> = new Map();

  constructor() {
    this.initializeNodeRegistry();
    this.loadTemplateLibrary();
  }

  private initializeNodeRegistry(): void {
    // Déclencheurs
    this.registerNode({
      id: 'trigger_sensor',
      type: 'trigger',
      name: 'Capteur IoT',
      description: 'Déclenché quand un capteur dépasse un seuil',
      icon: 'sensor',
      category: 'triggers',
      inputs: [],
      outputs: [{ id: 'triggered', type: 'event' }],
      configSchema: {
        sensorId: { type: 'select', required: true, options: 'sensors' },
        operator: { 
          type: 'select', 
          required: true, 
          options: ['>', '<', '=', 'between'] 
        },
        value: { type: 'number', required: true },
        hysteresis: { type: 'number', default: 0.1 }
      }
    });

    this.registerNode({
      id: 'trigger_weather',
      type: 'trigger',
      name: 'Condition Météo',
      description: 'Déclenché selon les conditions météo',
      icon: 'cloud',
      category: 'triggers',
      inputs: [],
      outputs: [{ id: 'triggered', type: 'event' }],
      configSchema: {
        condition: {
          type: 'select',
          required: true,
          options: ['rain', 'sun', 'frost', 'wind', 'temperature']
        },
        operator: { type: 'select', options: ['>', '<', '='] },
        value: { type: 'number' }
      }
    });

    // Actions
    this.registerNode({
      id: 'action_irrigation',
      type: 'action',
      name: 'Arrosage',
      description: 'Contrôle l\'arrosage automatique',
      icon: 'droplet',
      category: 'actions',
      inputs: [{ id: 'trigger', type: 'event' }],
      outputs: [
        { id: 'success', type: 'event' },
        { id: 'failure', type: 'event' }
      ],
      configSchema: {
        zoneId: { type: 'select', required: true, options: 'zones' },
        action: { 
          type: 'select', 
          required: true, 
          options: ['start', 'stop', 'schedule'] 
        },
        duration: { type: 'number', unit: 'minutes', default: 10 },
        intensity: { type: 'number', min: 0, max: 100, default: 50 }
      }
    });

    this.registerNode({
      id: 'action_notification',
      type: 'action',
      name: 'Notification',
      description: 'Envoie une notification',
      icon: 'bell',
      category: 'actions',
      inputs: [{ id: 'trigger', type: 'event' }],
      outputs: [{ id: 'sent', type: 'event' }],
      configSchema: {
        channel: {
          type: 'select',
          required: true,
          options: ['push', 'email', 'sms']
        },
        message: { type: 'text', required: true },
        priority: {
          type: 'select',
          options: ['low', 'medium', 'high', 'critical'],
          default: 'medium'
        }
      }
    });

    // Conditions
    this.registerNode({
      id: 'condition_time',
      type: 'condition',
      name: 'Condition Horaire',
      description: 'Vérifie l\'heure et les jours',
      icon: 'clock',
      category: 'conditions',
      inputs: [{ id: 'input', type: 'event' }],
      outputs: [
        { id: 'true', type: 'event' },
        { id: 'false', type: 'event' }
      ],
      configSchema: {
        timeRange: {
          type: 'timerange',
          start: { type: 'time', default: '08:00' },
          end: { type: 'time', default: '20:00' }
        },
        days: {
          type: 'multiselect',
          options: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
          default: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
        }
      }
    });
  }

  async generateScenarioFromTemplate(
    templateId: string, 
    userConfig: any
  ): Promise<ScenarioBuilderNode[]> {
    const template = this.templateLibrary.get(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }

    // Application de la configuration utilisateur
    const nodes = template.nodes.map(node => ({
      ...node,
      id: generateId(),
      data: this.applyUserConfig(node.data, userConfig)
    }));

    // Mise à jour des connexions avec nouveaux IDs
    const idMapping = new Map(
      template.nodes.map((original, index) => [original.id, nodes[index].id])
    );

    nodes.forEach(node => {
      node.connections = node.connections.map(connection => ({
        ...connection,
        from: idMapping.get(connection.from) || connection.from,
        to: idMapping.get(connection.to) || connection.to
      }));
    });

    return nodes;
  }

  async validateScenario(nodes: ScenarioBuilderNode[]): Promise<ValidationResult> {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];

    // Validation de la structure
    const structureValidation = this.validateStructure(nodes);
    errors.push(...structureValidation.errors);
    warnings.push(...structureValidation.warnings);

    // Validation des configurations
    for (const node of nodes) {
      const nodeValidation = await this.validateNodeConfig(node);
      errors.push(...nodeValidation.errors);
      warnings.push(...nodeValidation.warnings);
    }

    // Validation des ressources
    const resourceValidation = await this.validateResourceUsage(nodes);
    errors.push(...resourceValidation.errors);
    warnings.push(...resourceValidation.warnings);

    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  async simulateScenario(
    nodes: ScenarioBuilderNode[],
    simulationConfig: SimulationConfig
  ): Promise<SimulationResult> {
    const simulator = new ScenarioSimulator();
    return await simulator.simulate(nodes, simulationConfig);
  }
}
```

### Interface Visual Builder

```typescript
// src/app/automation/builder/page.tsx
export default function ScenarioBuilderPage() {
  const [nodes, setNodes] = useState<ScenarioBuilderNode[]>([]);
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [mode, setMode] = useState<'design' | 'test' | 'deploy'>('design');

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      {/* Header */}
      <div className="border-b bg-white px-6 py-4">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-xl font-semibold">Créateur de Scénarios</h1>
            <p className="text-sm text-gray-600">
              Créez des automatisations intelligentes pour votre jardin
            </p>
          </div>
          
          <div className="flex items-center space-x-3">
            <ModeSelector value={mode} onChange={setMode} />
            <Button variant="outline">
              <PlayIcon className="w-4 h-4 mr-2" />
              Tester
            </Button>
            <Button>
              <SaveIcon className="w-4 h-4 mr-2" />
              Sauvegarder
            </Button>
          </div>
        </div>
      </div>

      <div className="flex-1 flex">
        {/* Palette des composants */}
        <div className="w-80 border-r bg-white">
          <NodePalette onNodeAdd={(nodeType) => addNode(nodeType)} />
        </div>

        {/* Canvas principal */}
        <div className="flex-1 relative">
          <ScenarioCanvas
            nodes={nodes}
            onNodesChange={setNodes}
            selectedNode={selectedNode}
            onNodeSelect={setSelectedNode}
          />
        </div>

        {/* Panneau de configuration */}
        {selectedNode && (
          <div className="w-96 border-l bg-white">
            <NodeConfigPanel
              node={nodes.find(n => n.id === selectedNode)!}
              onChange={(nodeId, config) => updateNodeConfig(nodeId, config)}
            />
          </div>
        )}
      </div>
    </div>
  );
}

const ScenarioCanvas = ({ nodes, onNodesChange, selectedNode, onNodeSelect }: {
  nodes: ScenarioBuilderNode[];
  onNodesChange: (nodes: ScenarioBuilderNode[]) => void;
  selectedNode: string | null;
  onNodeSelect: (nodeId: string) => void;
}) => {
  const [connections, setConnections] = useState<NodeConnection[]>([]);

  return (
    <div className="w-full h-full relative overflow-hidden">
      <ReactFlow
        nodes={nodes.map(node => ({
          id: node.id,
          type: node.type,
          position: node.position,
          data: node.data,
          selected: node.id === selectedNode
        }))}
        edges={connections.map(conn => ({
          id: `${conn.from}-${conn.to}`,
          source: conn.from,
          target: conn.to,
          type: conn.type === 'conditional' ? 'smoothstep' : 'default',
          label: conn.condition,
          animated: true
        }))}
        onNodesChange={(changes) => {
          // Mise à jour des positions des nodes
          const updatedNodes = applyNodeChanges(changes, nodes);
          onNodesChange(updatedNodes);
        }}
        onConnect={(connection) => {
          setConnections(prev => [...prev, {
            from: connection.source!,
            to: connection.target!,
            type: 'success'
          }]);
        }}
        onNodeClick={(_, node) => onNodeSelect(node.id)}
        nodeTypes={{
          trigger: TriggerNode,
          condition: ConditionNode,
          action: ActionNode,
          delay: DelayNode
        }}
        fitView
        attributionPosition="bottom-right"
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
};

const NodePalette = ({ onNodeAdd }: { onNodeAdd: (nodeType: string) => void }) => {
  const nodeCategories = [
    {
      name: 'Déclencheurs',
      nodes: [
        { id: 'trigger_sensor', name: 'Capteur IoT', icon: '📊' },
        { id: 'trigger_weather', name: 'Météo', icon: '🌤️' },
        { id: 'trigger_schedule', name: 'Programmation', icon: '⏰' },
        { id: 'trigger_manual', name: 'Manuel', icon: '👆' }
      ]
    },
    {
      name: 'Conditions',
      nodes: [
        { id: 'condition_time', name: 'Horaire', icon: '🕐' },
        { id: 'condition_weather', name: 'Météo', icon: '☀️' },
        { id: 'condition_sensor', name: 'Capteur', icon: '📈' },
        { id: 'condition_custom', name: 'Personnalisée', icon: '⚙️' }
      ]
    },
    {
      name: 'Actions',
      nodes: [
        { id: 'action_irrigation', name: 'Arrosage', icon: '💧' },
        { id: 'action_notification', name: 'Notification', icon: '🔔' },
        { id: 'action_light', name: 'Éclairage', icon: '💡' },
        { id: 'action_ventilation', name: 'Ventilation', icon: '🌪️' }
      ]
    }
  ];

  return (
    <div className="p-4 space-y-6">
      <div>
        <h3 className="font-semibold text-gray-900 mb-3">Composants</h3>
        <Input
          placeholder="Rechercher un composant..."
          className="mb-4"
        />
      </div>

      {nodeCategories.map(category => (
        <div key={category.name}>
          <h4 className="text-sm font-medium text-gray-700 mb-2">
            {category.name}
          </h4>
          <div className="space-y-2">
            {category.nodes.map(node => (
              <div
                key={node.id}
                className="flex items-center p-2 rounded border cursor-pointer hover:bg-gray-50"
                draggable
                onDragStart={(e) => {
                  e.dataTransfer.setData('nodeType', node.id);
                }}
                onClick={() => onNodeAdd(node.id)}
              >
                <span className="text-lg mr-3">{node.icon}</span>
                <span className="text-sm">{node.name}</span>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};
```

## API Routes

```typescript
// src/app/api/automation/scenarios/route.ts
export async function GET() {
  const scenarios = await prisma.scenarioAutomatisation.findMany({
    include: {
      declencheurs: true,
      conditions: true,
      actions: true,
      executions: {
        take: 5,
        orderBy: { executedAt: 'desc' }
      }
    }
  });

  return NextResponse.json({
    scenarios: scenarios.map(scenario => ({
      id: scenario.id,
      name: scenario.nom,
      enabled: scenario.enabled,
      priority: scenario.priorite,
      lastExecuted: scenario.derniereExecution,
      executionCount: scenario.nombreExecutions,
      successRate: calculateSuccessRate(scenario.executions)
    }))
  });
}

export async function POST(request: Request) {
  const { nodes, name, description } = await request.json();
  
  // Validation du scénario
  const validation = await scenarioBuilderService.validateScenario(nodes);
  if (!validation.valid) {
    return NextResponse.json(
      { error: 'Invalid scenario', details: validation.errors },
      { status: 400 }
    );
  }

  // Conversion en format base de données
  const scenario = await convertNodesToScenario(nodes, { name, description });
  
  // Sauvegarde
  const savedScenario = await prisma.scenarioAutomatisation.create({
    data: scenario
  });

  // Activation dans le moteur
  await automationEngineService.loadScenario(savedScenario.id);

  return NextResponse.json({ scenarioId: savedScenario.id });
}

// src/app/api/automation/scenarios/[scenarioId]/execute/route.ts
export async function POST(
  request: Request,
  { params }: { params: { scenarioId: string } }
) {
  try {
    const scenario = await prisma.scenarioAutomatisation.findUnique({
      where: { id: params.scenarioId }
    });

    if (!scenario) {
      return NextResponse.json({ error: 'Scenario not found' }, { status: 404 });
    }

    // Exécution manuelle du scénario
    const result = await automationEngineService.executeScenario({
      id: generateId(),
      scenarioId: scenario.id,
      scenario: mapToAutomationScenario(scenario),
      context: {
        triggerType: 'manual_trigger',
        triggerId: 'manual',
        data: { executedBy: 'user', timestamp: new Date() }
      },
      priority: scenario.priorite,
      scheduledAt: new Date(),
      status: 'queued'
    });

    return NextResponse.json({
      executionId: result.executionId,
      success: result.success,
      duration: result.duration,
      actionResults: result.actionResults
    });

  } catch (error) {
    console.error('Manual scenario execution failed:', error);
    return NextResponse.json(
      { error: 'Execution failed' },
      { status: 500 }
    );
  }
}
```

## Critères d'Acceptation Techniques

### Interface Builder
- [ ] Drag & drop fluide (< 100ms de latence)
- [ ] Validation en temps réel des connexions
- [ ] Templates prédéfinis pour cas d'usage courants
- [ ] Simulation avant déploiement
- [ ] Historique des modifications

### Moteur d'Exécution
- [ ] Traitement concurrent de 100+ scénarios
- [ ] Résolution automatique des conflits
- [ ] Retry intelligent avec backoff
- [ ] Isolation des pannes (circuit breaker)
- [ ] Logs détaillés pour debug

### Intégrations
- [ ] Home Assistant bidirectionnel
- [ ] API REST complète
- [ ] Webhooks entrants/sortants
- [ ] Support Node-RED
- [ ] Compatible protocoles IoT standards

## Couverture Exigences Architecture

- **EXG-006.1** : Intégration Home Assistant native
- **EXG-005.1** : IA pour suggestions d'automatisations
- **EXG-007.1** : Exécution temps réel
- **EXG-001.3** : Interface no-code adaptative
- **EXG-009.1** : Monitoring des automatisations

## Tests d'Acceptation

```typescript
// tests/integration/automation.test.ts
describe('Automation System', () => {
  test('scénario simple s\'exécute correctement', async () => {
    const scenario = createTestScenario();
    
    const result = await automationEngineService.executeScenario({
      scenario,
      context: { triggerType: 'manual_trigger', data: {} }
    });
    
    expect(result.success).toBe(true);
    expect(result.actionResults).toHaveLength(scenario.actions.length);
  });

  test('résolution de conflits fonctionne', async () => {
    const scenario1 = createConflictingScenario('irrigation_zone_1');
    const scenario2 = createConflictingScenario('irrigation_zone_1');
    
    await automationEngineService.queueScenarioExecution(scenario1, {});
    await automationEngineService.queueScenarioExecution(scenario2, {});
    
    // Le scénario avec priorité plus élevée doit s'exécuter
    const executions = await getExecutionHistory();
    expect(executions.filter(e => e.success)).toHaveLength(1);
  });

  test('visual builder génère scénario valide', async () => {
    const nodes = createTestNodes();
    
    const validation = await scenarioBuilderService.validateScenario(nodes);
    expect(validation.valid).toBe(true);
    
    const scenario = await convertNodesToScenario(nodes);
    expect(scenario.triggers).toHaveLength(greaterThan(0));
    expect(scenario.actions).toHaveLength(greaterThan(0));
  });
});
```

Cette spécification couvre un système complet d'automatisation avec interface visuelle, moteur d'exécution robuste et intégrations domotiques avancées pour optimiser intelligemment la gestion du jardin.