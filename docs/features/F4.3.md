# F4.3 - Automatisation & Sc√©narios

**Score Priorit√© :** 75/100  
**Statut :** PRIORIT√â MOD√âR√âE  
**Epic :** EPIC 4 - PILIER OPTIMISER  
**Effort estim√© :** 20 jours  

## Description

Syst√®me d'automatisation avanc√© avec cr√©ateur de sc√©narios no-code, d√©clencheurs intelligents bas√©s sur l'IA, int√©gration IoT/Home Assistant et ex√©cution d'actions automatiques pour optimiser la gestion du jardin sans intervention manuelle.

## User Stories

### US4.3.1 - Cr√©ateur de Sc√©narios Visual
**En tant qu'** expert jardinier  
**Je veux** cr√©er des automatisations complexes visuellement  
**Afin d'** optimiser mon jardin sans comp√©tences techniques  

**Crit√®res d'acceptation :**
- Interface drag & drop pour cr√©ation de workflows
- Biblioth√®que de d√©clencheurs pr√©d√©finis (m√©t√©o, capteurs, planning)
- Actions configurables (arrosage, notifications, √©clairage)
- Test et simulation avant activation
- Historique des ex√©cutions avec logs d√©taill√©s

### US4.3.2 - Automatisations Intelligentes
**En tant qu'** utilisateur occasionnel  
**Je veux** que mon jardin s'auto-g√®re intelligemment  
**Afin de** maintenir des conditions optimales sans effort  

**Crit√®res d'acceptation :**
- Suggestions d'automatisations bas√©es sur l'IA
- Apprentissage des patterns et pr√©f√©rences utilisateur
- Adaptation automatique selon conditions m√©t√©o
- Gestion des conflits entre sc√©narios
- Mode urgence avec priorit√©s d√©finies

### US4.3.3 - Int√©gration Domotique Compl√®te
**En tant qu'** utilisateur avanc√©  
**Je veux** int√©grer mon jardin √† ma domotique existante  
**Afin de** cr√©er un √©cosyst√®me intelligent global  

**Crit√®res d'acceptation :**
- Synchronisation bidirectionnelle Home Assistant
- Support Node-RED pour workflows avanc√©s
- API REST pour int√©grations tierces
- Webhooks entrants et sortants
- Compatible protocoles IoT (Zigbee, Z-Wave, Wi-Fi)

## Architecture Technique

### Moteur d'Automatisation

```typescript
// src/services/automation/automation-engine.service.ts
export interface AutomationScenario {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  triggers: TriggerDefinition[];
  conditions: ConditionDefinition[];
  actions: ActionDefinition[];
  schedule: ScheduleDefinition;
  priority: number; // 1-10, plus √©lev√© = priorit√©
  metadata: ScenarioMetadata;
  createdAt: Date;
  lastExecuted?: Date;
  executionCount: number;
}

export interface TriggerDefinition {
  id: string;
  type: TriggerType;
  config: TriggerConfig;
  enabled: boolean;
}

export type TriggerType = 
  | 'sensor_threshold'    // Capteur d√©passe seuil
  | 'weather_condition'   // Condition m√©t√©o
  | 'time_schedule'       // Programmation horaire
  | 'manual_trigger'      // D√©clenchement manuel
  | 'ai_recommendation'   // Recommandation IA
  | 'plant_growth_stage'  // Stade de croissance
  | 'harvest_ready'       // R√©colte pr√™te
  | 'external_webhook';   // Webhook externe

export interface ActionDefinition {
  id: string;
  type: ActionType;
  config: ActionConfig;
  delay?: number; // en secondes
  retry?: RetryConfig;
}

export type ActionType =
  | 'irrigation_start'    // D√©marrer arrosage
  | 'irrigation_stop'     // Arr√™ter arrosage
  | 'notification_send'   // Envoyer notification
  | 'light_control'       // Contr√¥le √©clairage
  | 'ventilation_control' // Contr√¥le ventilation
  | 'data_collection'     // Collecter donn√©es
  | 'ai_analysis'         // D√©clencher analyse IA
  | 'home_assistant'      // Action Home Assistant
  | 'webhook_call';       // Appel webhook

export class AutomationEngineService extends EventEmitter {
  private activeScenarios: Map<string, AutomationScenario> = new Map();
  private executionQueue: ExecutionQueue;
  private conditionEvaluator: ConditionEvaluator;
  private actionExecutor: ActionExecutor;

  constructor(
    private prisma: PrismaClient,
    private iotService: IoTService,
    private weatherService: WeatherService,
    private homeAssistantService: HomeAssistantService,
    private aiService: AIService
  ) {
    super();
    this.executionQueue = new ExecutionQueue();
    this.conditionEvaluator = new ConditionEvaluator();
    this.actionExecutor = new ActionExecutor();
    this.initializeEngine();
  }

  private async initializeEngine(): Promise<void> {
    // Chargement des sc√©narios actifs
    await this.loadActiveScenarios();
    
    // Setup des listeners pour d√©clencheurs
    this.setupTriggerListeners();
    
    // D√©marrage de la queue d'ex√©cution
    this.executionQueue.start();
    
    console.log(`Automation engine initialized with ${this.activeScenarios.size} scenarios`);
  }

  private async loadActiveScenarios(): Promise<void> {
    const scenarios = await this.prisma.scenarioAutomatisation.findMany({
      where: { enabled: true },
      include: {
        declencheurs: true,
        conditions: true,
        actions: true
      }
    });

    for (const scenario of scenarios) {
      this.activeScenarios.set(scenario.id, this.mapToScenario(scenario));
    }
  }

  private setupTriggerListeners(): void {
    // Listener pour capteurs IoT
    this.iotService.on('sensorReading', (reading) => {
      this.evaluateSensorTriggers(reading);
    });

    // Listener pour conditions m√©t√©o
    this.weatherService.on('weatherUpdate', (weather) => {
      this.evaluateWeatherTriggers(weather);
    });

    // Listener pour croissance des plantes
    this.on('plantGrowthStageChange', (event) => {
      this.evaluateGrowthTriggers(event);
    });

    // Listener pour recommandations IA
    this.aiService.on('recommendationGenerated', (recommendation) => {
      this.evaluateAITriggers(recommendation);
    });

    // Setup timers pour d√©clencheurs horaires
    this.setupScheduledTriggers();
  }

  private async evaluateSensorTriggers(reading: SensorReading): Promise<void> {
    const relevantScenarios = Array.from(this.activeScenarios.values())
      .filter(scenario => 
        scenario.triggers.some(trigger => 
          trigger.type === 'sensor_threshold' && 
          trigger.config.sensorId === reading.sensorId
        )
      );

    for (const scenario of relevantScenarios) {
      const sensorTriggers = scenario.triggers.filter(t => t.type === 'sensor_threshold');
      
      for (const trigger of sensorTriggers) {
        if (this.evaluateSensorThreshold(trigger, reading)) {
          await this.queueScenarioExecution(scenario, {
            triggerType: 'sensor_threshold',
            triggerId: trigger.id,
            data: reading
          });
        }
      }
    }
  }

  private evaluateSensorThreshold(trigger: TriggerDefinition, reading: SensorReading): boolean {
    const { operator, value, hysteresis } = trigger.config;
    
    switch (operator) {
      case 'greater_than':
        return reading.value > value;
      case 'less_than':
        return reading.value < value;
      case 'equals':
        return Math.abs(reading.value - value) < (hysteresis || 0.1);
      case 'between':
        return reading.value >= trigger.config.minValue && reading.value <= trigger.config.maxValue;
      default:
        return false;
    }
  }

  private async queueScenarioExecution(
    scenario: AutomationScenario, 
    context: ExecutionContext
  ): Promise<void> {
    // V√©rification des conditions
    const conditionsValid = await this.conditionEvaluator.evaluate(scenario.conditions, context);
    if (!conditionsValid) {
      console.log(`Scenario ${scenario.name} conditions not met, skipping execution`);
      return;
    }

    // V√©rification des conflits
    const hasConflicts = await this.checkScenarioConflicts(scenario, context);
    if (hasConflicts) {
      console.log(`Scenario ${scenario.name} has conflicts, resolving...`);
      await this.resolveConflicts(scenario, context);
      return;
    }

    // Ajout √† la queue d'ex√©cution
    const execution: QueuedExecution = {
      id: generateId(),
      scenarioId: scenario.id,
      scenario,
      context,
      priority: scenario.priority,
      scheduledAt: new Date(),
      status: 'queued'
    };

    await this.executionQueue.enqueue(execution);
    
    this.emit('scenarioQueued', { scenario, context });
  }

  async executeScenario(execution: QueuedExecution): Promise<ExecutionResult> {
    const startTime = Date.now();
    const { scenario, context } = execution;
    
    console.log(`Executing scenario: ${scenario.name}`);

    try {
      // Marquer comme en cours
      execution.status = 'executing';
      execution.startedAt = new Date();

      const actionResults: ActionResult[] = [];

      // Ex√©cution des actions en s√©quence
      for (const action of scenario.actions) {
        try {
          // D√©lai si sp√©cifi√©
          if (action.delay > 0) {
            await this.delay(action.delay * 1000);
          }

          const actionResult = await this.actionExecutor.execute(action, context);
          actionResults.push(actionResult);

          // Arr√™t si action critique √©choue
          if (!actionResult.success && action.config.critical) {
            throw new Error(`Critical action failed: ${actionResult.error}`);
          }

        } catch (error) {
          console.error(`Action ${action.id} failed:`, error);
          
          // Retry si configur√©
          if (action.retry) {
            const retryResult = await this.retryAction(action, context, action.retry);
            actionResults.push(retryResult);
          } else {
            actionResults.push({
              actionId: action.id,
              success: false,
              error: error.message,
              executedAt: new Date()
            });
          }
        }
      }

      // R√©sultat final
      const result: ExecutionResult = {
        executionId: execution.id,
        scenarioId: scenario.id,
        success: actionResults.every(r => r.success),
        startTime: execution.startedAt!,
        endTime: new Date(),
        duration: Date.now() - startTime,
        actionResults,
        context
      };

      // Stockage du r√©sultat
      await this.storeExecutionResult(result);
      
      // Mise √† jour statistiques
      await this.updateScenarioStats(scenario.id, result);

      this.emit('scenarioExecuted', result);
      
      return result;

    } catch (error) {
      console.error(`Scenario execution failed: ${scenario.name}`, error);
      
      const result: ExecutionResult = {
        executionId: execution.id,
        scenarioId: scenario.id,
        success: false,
        startTime: execution.startedAt!,
        endTime: new Date(),
        duration: Date.now() - startTime,
        error: error.message,
        actionResults: [],
        context
      };

      await this.storeExecutionResult(result);
      this.emit('scenarioFailed', result);
      
      return result;
    }
  }

  private async checkScenarioConflicts(
    scenario: AutomationScenario, 
    context: ExecutionContext
  ): Promise<boolean> {
    // V√©rification des ressources partag√©es
    const resourceConflicts = await this.checkResourceConflicts(scenario);
    
    // V√©rification des sc√©narios mutuellement exclusifs
    const exclusionConflicts = await this.checkExclusionConflicts(scenario);
    
    // V√©rification des priorit√©s en cours
    const priorityConflicts = await this.checkPriorityConflicts(scenario);

    return resourceConflicts || exclusionConflicts || priorityConflicts;
  }

  private async resolveConflicts(
    scenario: AutomationScenario,
    context: ExecutionContext
  ): Promise<void> {
    // Strat√©gies de r√©solution de conflits
    const strategies = [
      this.resolveBySuspendingLowerPriority,
      this.resolveByQueueing,
      this.resolveByMerging,
      this.resolveByUserDecision
    ];

    for (const strategy of strategies) {
      const resolved = await strategy.call(this, scenario, context);
      if (resolved) {
        break;
      }
    }
  }
}
```

### Visual Scenario Builder

```typescript
// src/services/automation/scenario-builder.service.ts
export interface ScenarioBuilderNode {
  id: string;
  type: 'trigger' | 'condition' | 'action' | 'delay' | 'parallel' | 'conditional';
  position: { x: number; y: number };
  data: NodeData;
  connections: NodeConnection[];
}

export interface NodeConnection {
  from: string;
  to: string;
  type: 'success' | 'failure' | 'conditional';
  condition?: string;
}

export class ScenarioBuilderService {
  private nodeRegistry: Map<string, NodeDefinition> = new Map();
  private templateLibrary: Map<string, ScenarioTemplate> = new Map();

  constructor() {
    this.initializeNodeRegistry();
    this.loadTemplateLibrary();
  }

  private initializeNodeRegistry(): void {
    // D√©clencheurs
    this.registerNode({
      id: 'trigger_sensor',
      type: 'trigger',
      name: 'Capteur IoT',
      description: 'D√©clench√© quand un capteur d√©passe un seuil',
      icon: 'sensor',
      category: 'triggers',
      inputs: [],
      outputs: [{ id: 'triggered', type: 'event' }],
      configSchema: {
        sensorId: { type: 'select', required: true, options: 'sensors' },
        operator: { 
          type: 'select', 
          required: true, 
          options: ['>', '<', '=', 'between'] 
        },
        value: { type: 'number', required: true },
        hysteresis: { type: 'number', default: 0.1 }
      }
    });

    this.registerNode({
      id: 'trigger_weather',
      type: 'trigger',
      name: 'Condition M√©t√©o',
      description: 'D√©clench√© selon les conditions m√©t√©o',
      icon: 'cloud',
      category: 'triggers',
      inputs: [],
      outputs: [{ id: 'triggered', type: 'event' }],
      configSchema: {
        condition: {
          type: 'select',
          required: true,
          options: ['rain', 'sun', 'frost', 'wind', 'temperature']
        },
        operator: { type: 'select', options: ['>', '<', '='] },
        value: { type: 'number' }
      }
    });

    // Actions
    this.registerNode({
      id: 'action_irrigation',
      type: 'action',
      name: 'Arrosage',
      description: 'Contr√¥le l\'arrosage automatique',
      icon: 'droplet',
      category: 'actions',
      inputs: [{ id: 'trigger', type: 'event' }],
      outputs: [
        { id: 'success', type: 'event' },
        { id: 'failure', type: 'event' }
      ],
      configSchema: {
        zoneId: { type: 'select', required: true, options: 'zones' },
        action: { 
          type: 'select', 
          required: true, 
          options: ['start', 'stop', 'schedule'] 
        },
        duration: { type: 'number', unit: 'minutes', default: 10 },
        intensity: { type: 'number', min: 0, max: 100, default: 50 }
      }
    });

    this.registerNode({
      id: 'action_notification',
      type: 'action',
      name: 'Notification',
      description: 'Envoie une notification',
      icon: 'bell',
      category: 'actions',
      inputs: [{ id: 'trigger', type: 'event' }],
      outputs: [{ id: 'sent', type: 'event' }],
      configSchema: {
        channel: {
          type: 'select',
          required: true,
          options: ['push', 'email', 'sms']
        },
        message: { type: 'text', required: true },
        priority: {
          type: 'select',
          options: ['low', 'medium', 'high', 'critical'],
          default: 'medium'
        }
      }
    });

    // Conditions
    this.registerNode({
      id: 'condition_time',
      type: 'condition',
      name: 'Condition Horaire',
      description: 'V√©rifie l\'heure et les jours',
      icon: 'clock',
      category: 'conditions',
      inputs: [{ id: 'input', type: 'event' }],
      outputs: [
        { id: 'true', type: 'event' },
        { id: 'false', type: 'event' }
      ],
      configSchema: {
        timeRange: {
          type: 'timerange',
          start: { type: 'time', default: '08:00' },
          end: { type: 'time', default: '20:00' }
        },
        days: {
          type: 'multiselect',
          options: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
          default: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
        }
      }
    });
  }

  async generateScenarioFromTemplate(
    templateId: string, 
    userConfig: any
  ): Promise<ScenarioBuilderNode[]> {
    const template = this.templateLibrary.get(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }

    // Application de la configuration utilisateur
    const nodes = template.nodes.map(node => ({
      ...node,
      id: generateId(),
      data: this.applyUserConfig(node.data, userConfig)
    }));

    // Mise √† jour des connexions avec nouveaux IDs
    const idMapping = new Map(
      template.nodes.map((original, index) => [original.id, nodes[index].id])
    );

    nodes.forEach(node => {
      node.connections = node.connections.map(connection => ({
        ...connection,
        from: idMapping.get(connection.from) || connection.from,
        to: idMapping.get(connection.to) || connection.to
      }));
    });

    return nodes;
  }

  async validateScenario(nodes: ScenarioBuilderNode[]): Promise<ValidationResult> {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];

    // Validation de la structure
    const structureValidation = this.validateStructure(nodes);
    errors.push(...structureValidation.errors);
    warnings.push(...structureValidation.warnings);

    // Validation des configurations
    for (const node of nodes) {
      const nodeValidation = await this.validateNodeConfig(node);
      errors.push(...nodeValidation.errors);
      warnings.push(...nodeValidation.warnings);
    }

    // Validation des ressources
    const resourceValidation = await this.validateResourceUsage(nodes);
    errors.push(...resourceValidation.errors);
    warnings.push(...resourceValidation.warnings);

    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  async simulateScenario(
    nodes: ScenarioBuilderNode[],
    simulationConfig: SimulationConfig
  ): Promise<SimulationResult> {
    const simulator = new ScenarioSimulator();
    return await simulator.simulate(nodes, simulationConfig);
  }
}
```

### Interface Visual Builder

```typescript
// src/app/automation/builder/page.tsx
export default function ScenarioBuilderPage() {
  const [nodes, setNodes] = useState<ScenarioBuilderNode[]>([]);
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [mode, setMode] = useState<'design' | 'test' | 'deploy'>('design');

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      {/* Header */}
      <div className="border-b bg-white px-6 py-4">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-xl font-semibold">Cr√©ateur de Sc√©narios</h1>
            <p className="text-sm text-gray-600">
              Cr√©ez des automatisations intelligentes pour votre jardin
            </p>
          </div>
          
          <div className="flex items-center space-x-3">
            <ModeSelector value={mode} onChange={setMode} />
            <Button variant="outline">
              <PlayIcon className="w-4 h-4 mr-2" />
              Tester
            </Button>
            <Button>
              <SaveIcon className="w-4 h-4 mr-2" />
              Sauvegarder
            </Button>
          </div>
        </div>
      </div>

      <div className="flex-1 flex">
        {/* Palette des composants */}
        <div className="w-80 border-r bg-white">
          <NodePalette onNodeAdd={(nodeType) => addNode(nodeType)} />
        </div>

        {/* Canvas principal */}
        <div className="flex-1 relative">
          <ScenarioCanvas
            nodes={nodes}
            onNodesChange={setNodes}
            selectedNode={selectedNode}
            onNodeSelect={setSelectedNode}
          />
        </div>

        {/* Panneau de configuration */}
        {selectedNode && (
          <div className="w-96 border-l bg-white">
            <NodeConfigPanel
              node={nodes.find(n => n.id === selectedNode)!}
              onChange={(nodeId, config) => updateNodeConfig(nodeId, config)}
            />
          </div>
        )}
      </div>
    </div>
  );
}

const ScenarioCanvas = ({ nodes, onNodesChange, selectedNode, onNodeSelect }: {
  nodes: ScenarioBuilderNode[];
  onNodesChange: (nodes: ScenarioBuilderNode[]) => void;
  selectedNode: string | null;
  onNodeSelect: (nodeId: string) => void;
}) => {
  const [connections, setConnections] = useState<NodeConnection[]>([]);

  return (
    <div className="w-full h-full relative overflow-hidden">
      <ReactFlow
        nodes={nodes.map(node => ({
          id: node.id,
          type: node.type,
          position: node.position,
          data: node.data,
          selected: node.id === selectedNode
        }))}
        edges={connections.map(conn => ({
          id: `${conn.from}-${conn.to}`,
          source: conn.from,
          target: conn.to,
          type: conn.type === 'conditional' ? 'smoothstep' : 'default',
          label: conn.condition,
          animated: true
        }))}
        onNodesChange={(changes) => {
          // Mise √† jour des positions des nodes
          const updatedNodes = applyNodeChanges(changes, nodes);
          onNodesChange(updatedNodes);
        }}
        onConnect={(connection) => {
          setConnections(prev => [...prev, {
            from: connection.source!,
            to: connection.target!,
            type: 'success'
          }]);
        }}
        onNodeClick={(_, node) => onNodeSelect(node.id)}
        nodeTypes={{
          trigger: TriggerNode,
          condition: ConditionNode,
          action: ActionNode,
          delay: DelayNode
        }}
        fitView
        attributionPosition="bottom-right"
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
};

const NodePalette = ({ onNodeAdd }: { onNodeAdd: (nodeType: string) => void }) => {
  const nodeCategories = [
    {
      name: 'D√©clencheurs',
      nodes: [
        { id: 'trigger_sensor', name: 'Capteur IoT', icon: 'üìä' },
        { id: 'trigger_weather', name: 'M√©t√©o', icon: 'üå§Ô∏è' },
        { id: 'trigger_schedule', name: 'Programmation', icon: '‚è∞' },
        { id: 'trigger_manual', name: 'Manuel', icon: 'üëÜ' }
      ]
    },
    {
      name: 'Conditions',
      nodes: [
        { id: 'condition_time', name: 'Horaire', icon: 'üïê' },
        { id: 'condition_weather', name: 'M√©t√©o', icon: '‚òÄÔ∏è' },
        { id: 'condition_sensor', name: 'Capteur', icon: 'üìà' },
        { id: 'condition_custom', name: 'Personnalis√©e', icon: '‚öôÔ∏è' }
      ]
    },
    {
      name: 'Actions',
      nodes: [
        { id: 'action_irrigation', name: 'Arrosage', icon: 'üíß' },
        { id: 'action_notification', name: 'Notification', icon: 'üîî' },
        { id: 'action_light', name: '√âclairage', icon: 'üí°' },
        { id: 'action_ventilation', name: 'Ventilation', icon: 'üå™Ô∏è' }
      ]
    }
  ];

  return (
    <div className="p-4 space-y-6">
      <div>
        <h3 className="font-semibold text-gray-900 mb-3">Composants</h3>
        <Input
          placeholder="Rechercher un composant..."
          className="mb-4"
        />
      </div>

      {nodeCategories.map(category => (
        <div key={category.name}>
          <h4 className="text-sm font-medium text-gray-700 mb-2">
            {category.name}
          </h4>
          <div className="space-y-2">
            {category.nodes.map(node => (
              <div
                key={node.id}
                className="flex items-center p-2 rounded border cursor-pointer hover:bg-gray-50"
                draggable
                onDragStart={(e) => {
                  e.dataTransfer.setData('nodeType', node.id);
                }}
                onClick={() => onNodeAdd(node.id)}
              >
                <span className="text-lg mr-3">{node.icon}</span>
                <span className="text-sm">{node.name}</span>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};
```

## API Routes

```typescript
// src/app/api/automation/scenarios/route.ts
export async function GET() {
  const scenarios = await prisma.scenarioAutomatisation.findMany({
    include: {
      declencheurs: true,
      conditions: true,
      actions: true,
      executions: {
        take: 5,
        orderBy: { executedAt: 'desc' }
      }
    }
  });

  return NextResponse.json({
    scenarios: scenarios.map(scenario => ({
      id: scenario.id,
      name: scenario.nom,
      enabled: scenario.enabled,
      priority: scenario.priorite,
      lastExecuted: scenario.derniereExecution,
      executionCount: scenario.nombreExecutions,
      successRate: calculateSuccessRate(scenario.executions)
    }))
  });
}

export async function POST(request: Request) {
  const { nodes, name, description } = await request.json();
  
  // Validation du sc√©nario
  const validation = await scenarioBuilderService.validateScenario(nodes);
  if (!validation.valid) {
    return NextResponse.json(
      { error: 'Invalid scenario', details: validation.errors },
      { status: 400 }
    );
  }

  // Conversion en format base de donn√©es
  const scenario = await convertNodesToScenario(nodes, { name, description });
  
  // Sauvegarde
  const savedScenario = await prisma.scenarioAutomatisation.create({
    data: scenario
  });

  // Activation dans le moteur
  await automationEngineService.loadScenario(savedScenario.id);

  return NextResponse.json({ scenarioId: savedScenario.id });
}

// src/app/api/automation/scenarios/[scenarioId]/execute/route.ts
export async function POST(
  request: Request,
  { params }: { params: { scenarioId: string } }
) {
  try {
    const scenario = await prisma.scenarioAutomatisation.findUnique({
      where: { id: params.scenarioId }
    });

    if (!scenario) {
      return NextResponse.json({ error: 'Scenario not found' }, { status: 404 });
    }

    // Ex√©cution manuelle du sc√©nario
    const result = await automationEngineService.executeScenario({
      id: generateId(),
      scenarioId: scenario.id,
      scenario: mapToAutomationScenario(scenario),
      context: {
        triggerType: 'manual_trigger',
        triggerId: 'manual',
        data: { executedBy: 'user', timestamp: new Date() }
      },
      priority: scenario.priorite,
      scheduledAt: new Date(),
      status: 'queued'
    });

    return NextResponse.json({
      executionId: result.executionId,
      success: result.success,
      duration: result.duration,
      actionResults: result.actionResults
    });

  } catch (error) {
    console.error('Manual scenario execution failed:', error);
    return NextResponse.json(
      { error: 'Execution failed' },
      { status: 500 }
    );
  }
}
```

## Crit√®res d'Acceptation Techniques

### Interface Builder
- [ ] Drag & drop fluide (< 100ms de latence)
- [ ] Validation en temps r√©el des connexions
- [ ] Templates pr√©d√©finis pour cas d'usage courants
- [ ] Simulation avant d√©ploiement
- [ ] Historique des modifications

### Moteur d'Ex√©cution
- [ ] Traitement concurrent de 100+ sc√©narios
- [ ] R√©solution automatique des conflits
- [ ] Retry intelligent avec backoff
- [ ] Isolation des pannes (circuit breaker)
- [ ] Logs d√©taill√©s pour debug

### Int√©grations
- [ ] Home Assistant bidirectionnel
- [ ] API REST compl√®te
- [ ] Webhooks entrants/sortants
- [ ] Support Node-RED
- [ ] Compatible protocoles IoT standards

## Couverture Exigences Architecture

- **EXG-006.1** : Int√©gration Home Assistant native
- **EXG-005.1** : IA pour suggestions d'automatisations
- **EXG-007.1** : Ex√©cution temps r√©el
- **EXG-001.3** : Interface no-code adaptative
- **EXG-009.1** : Monitoring des automatisations

## Tests d'Acceptation

```typescript
// tests/integration/automation.test.ts
describe('Automation System', () => {
  test('sc√©nario simple s\'ex√©cute correctement', async () => {
    const scenario = createTestScenario();
    
    const result = await automationEngineService.executeScenario({
      scenario,
      context: { triggerType: 'manual_trigger', data: {} }
    });
    
    expect(result.success).toBe(true);
    expect(result.actionResults).toHaveLength(scenario.actions.length);
  });

  test('r√©solution de conflits fonctionne', async () => {
    const scenario1 = createConflictingScenario('irrigation_zone_1');
    const scenario2 = createConflictingScenario('irrigation_zone_1');
    
    await automationEngineService.queueScenarioExecution(scenario1, {});
    await automationEngineService.queueScenarioExecution(scenario2, {});
    
    // Le sc√©nario avec priorit√© plus √©lev√©e doit s'ex√©cuter
    const executions = await getExecutionHistory();
    expect(executions.filter(e => e.success)).toHaveLength(1);
  });

  test('visual builder g√©n√®re sc√©nario valide', async () => {
    const nodes = createTestNodes();
    
    const validation = await scenarioBuilderService.validateScenario(nodes);
    expect(validation.valid).toBe(true);
    
    const scenario = await convertNodesToScenario(nodes);
    expect(scenario.triggers).toHaveLength(greaterThan(0));
    expect(scenario.actions).toHaveLength(greaterThan(0));
  });
});
```

Cette sp√©cification couvre un syst√®me complet d'automatisation avec interface visuelle, moteur d'ex√©cution robuste et int√©grations domotiques avanc√©es pour optimiser intelligemment la gestion du jardin.