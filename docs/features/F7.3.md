# F7.3 - PWA & Fonctionnalités Offline Avancées

**Score Priorité :** 35/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 7 - EXPÉRIENCE & POLISH  
**Effort estimé :** 12 jours  

## Description

Progressive Web App (PWA) complète avec installation native sur mobile/desktop, mode offline robuste avec synchronisation différée, cache intelligent et fonctionnalités avancées pour utilisation sans connexion optimale.

## User Stories

### US7.3.1 - Installation Native PWA
**En tant qu'** utilisateur mobile  
**Je veux** installer l'application nativement sur mon téléphone  
**Afin d'** avoir accès direct comme une app native  

**Critères d'acceptation :**
- Installation PWA sur iOS/Android via prompt
- Icône sur écran d'accueil avec branding
- Lancement en plein écran sans navigateur
- Intégration notifications push natives
- Splash screen personnalisé au lancement

### US7.3.2 - Mode Offline Complet
**En tant qu'** jardinier en déplacement  
**Je veux** utiliser l'app même sans connexion internet  
**Afin de** continuer à saisir mes données terrain  

**Critères d'acceptation :**
- Cache intelligent des données critiques
- Saisie offline avec validation locale
- Queue de synchronisation automatique
- Indicateur état connexion visible
- Résolution automatique conflits sync

### US7.3.3 - Synchronisation Différée
**En tant qu'** utilisateur  
**Je veux** que mes données offline se synchronisent automatiquement  
**Afin de** retrouver mes données sur tous mes appareils  

**Critères d'acceptation :**
- Sync automatique au retour connexion
- Gestion conflits avec stratégies configurables
- Historique sync avec résolution d'erreurs
- Synchronisation différentielle optimisée
- Backup local sécurisé des données

## Architecture Technique

### Configuration PWA

```typescript
// public/manifest.json
{
  "name": "Baš-Malin - Jardin Intelligent",
  "short_name": "Baš-Malin",
  "description": "Votre assistant jardinage intelligent",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#10B981",
  "orientation": "portrait-primary",
  "categories": ["lifestyle", "productivity"],
  "screenshots": [
    {
      "src": "/screenshots/mobile-dashboard.png",
      "sizes": "390x844",
      "type": "image/png",
      "form_factor": "narrow"
    },
    {
      "src": "/screenshots/desktop-dashboard.png", 
      "sizes": "1920x1080",
      "type": "image/png",
      "form_factor": "wide"
    }
  ],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96", 
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "share_target": {
    "action": "/share-image",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "files": [
        {
          "name": "image",
          "accept": ["image/*"]
        }
      ]
    }
  },
  "shortcuts": [
    {
      "name": "Nouvelle Récolte",
      "short_name": "Récolte", 
      "description": "Enregistrer une récolte rapide",
      "url": "/harvests/new",
      "icons": [
        {
          "src": "/icons/shortcut-harvest.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "Journal",
      "short_name": "Journal",
      "description": "Consulter le journal de bord",
      "url": "/journal",
      "icons": [
        {
          "src": "/icons/shortcut-journal.png",
          "sizes": "96x96"
        }
      ]
    }
  ]
}
```

### Service Worker Avancé

```typescript
// src/service-worker/sw.ts
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { BackgroundSync } from 'workbox-background-sync';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

// Précache des assets statiques
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Stratégies de cache par type de ressource
registerRoute(
  /\.(?:png|jpg|jpeg|svg|webp|gif)$/,
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1000,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 jours
      }),
    ],
  })
);

registerRoute(
  /\.(?:js|css)$/,
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Cache des données API
registerRoute(
  /^https:\/\/api\.basmalin\.com\/v1\//,
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 500,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Background sync pour données offline
const bgSync = new BackgroundSync('offline-sync-queue', {
  maxRetentionTime: 24 * 60 // 24 heures
});

registerRoute(
  /^https:\/\/api\.basmalin\.com\/v1\/.*\/(harvests|interventions|notes)/,
  async ({ request }) => {
    try {
      const response = await fetch(request);
      return response;
    } catch (error) {
      // Si offline, ajouter à la queue background sync
      await bgSync.requestWillDequeue({ request });
      return new Response('Queued for background sync', { status: 202 });
    }
  },
  'POST'
);

// Gestion des notifications push
self.addEventListener('push', (event) => {
  const options = {
    body: event.data?.text() || 'Nouvelle notification de votre jardin',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: 'garden-notification',
    requireInteraction: false,
    actions: [
      {
        action: 'view',
        title: 'Voir',
        icon: '/icons/action-view.png'
      },
      {
        action: 'dismiss', 
        title: 'Ignorer',
        icon: '/icons/action-dismiss.png'
      }
    ],
    data: {
      url: '/dashboard',
      timestamp: Date.now()
    }
  };

  event.waitUntil(
    self.registration.showNotification('Baš-Malin', options)
  );
});

// Gestion des clics sur notifications
self.addEventListener('notificationclick', (event) => {
  const notification = event.notification;
  const action = event.action;

  if (action === 'dismiss') {
    notification.close();
    return;
  }

  event.waitUntil(
    self.clients.matchAll().then(clients => {
      const client = clients.find(c => c.visibilityState === 'visible');
      
      if (client) {
        client.navigate(notification.data.url);
        client.focus();
      } else {
        self.clients.openWindow(notification.data.url);
      }
      
      notification.close();
    })
  );
});

// Partage d'images
self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  
  if (url.pathname === '/share-image') {
    event.respondWith(handleImageShare(event.request));
  }
});

async function handleImageShare(request: Request): Promise<Response> {
  const formData = await request.formData();
  const image = formData.get('image') as File;
  
  if (image) {
    // Rediriger vers la page d'analyse d'image avec l'image
    const imageUrl = URL.createObjectURL(image);
    return Response.redirect(`/vision/analyze?shared_image=${encodeURIComponent(imageUrl)}`);
  }
  
  return Response.redirect('/');
}
```

### Gestionnaire Offline

```typescript
// src/services/offline/offline.service.ts
export interface OfflineOperation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: Date;
  attempts: number;
  status: 'pending' | 'syncing' | 'completed' | 'failed';
  error?: string;
}

export interface SyncStrategy {
  conflictResolution: 'client_wins' | 'server_wins' | 'merge' | 'manual';
  retryPolicy: {
    maxAttempts: number;
    backoffMultiplier: number;
    initialDelay: number;
  };
}

export class OfflineService {
  private db: IDBDatabase;
  private syncQueue: OfflineOperation[] = [];
  private isOnline: boolean = navigator.onLine;
  private syncInProgress: boolean = false;

  constructor() {
    this.initializeDB();
    this.setupEventListeners();
    this.startPeriodicSync();
  }

  private async initializeDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('BasMalinOffline', 2);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Store pour les opérations en attente
        if (!db.objectStoreNames.contains('syncQueue')) {
          const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id' });
          syncStore.createIndex('timestamp', 'timestamp');
          syncStore.createIndex('status', 'status');
        }
        
        // Store pour les données cachées
        if (!db.objectStoreNames.contains('cachedData')) {
          const cacheStore = db.createObjectStore('cachedData', { keyPath: 'key' });
          cacheStore.createIndex('entity', 'entity');
          cacheStore.createIndex('lastSync', 'lastSync');
        }
        
        // Store pour les conflits
        if (!db.objectStoreNames.contains('conflicts')) {
          const conflictStore = db.createObjectStore('conflicts', { keyPath: 'id' });
          conflictStore.createIndex('entity', 'entity');
        }
      };
    });
  }

  private setupEventListeners(): void {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.triggerSync();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
    });

    // Service Worker sync event
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data.type === 'BACKGROUND_SYNC') {
          this.processSyncQueue();
        }
      });
    }
  }

  async queueOperation(operation: Omit<OfflineOperation, 'id' | 'timestamp' | 'attempts' | 'status'>): Promise<string> {
    const operationId = `${Date.now()}-${Math.random().toString(36).substring(7)}`;
    
    const queuedOperation: OfflineOperation = {
      ...operation,
      id: operationId,
      timestamp: new Date(),
      attempts: 0,
      status: 'pending'
    };

    // Sauvegarde en IndexedDB
    await this.saveToIndexedDB('syncQueue', queuedOperation);
    
    // Ajout à la queue mémoire
    this.syncQueue.push(queuedOperation);

    // Tentative sync immédiate si online
    if (this.isOnline) {
      this.triggerSync();
    }

    return operationId;
  }

  async getOfflineData(entity: string, key: string): Promise<any> {
    const cacheKey = `${entity}:${key}`;
    return await this.getFromIndexedDB('cachedData', cacheKey);
  }

  async cacheData(entity: string, key: string, data: any): Promise<void> {
    const cacheEntry = {
      key: `${entity}:${key}`,
      entity,
      data,
      lastSync: new Date(),
      version: Date.now()
    };
    
    await this.saveToIndexedDB('cachedData', cacheEntry);
  }

  private async triggerSync(): Promise<void> {
    if (this.syncInProgress || !this.isOnline) {
      return;
    }

    this.syncInProgress = true;
    
    try {
      await this.processSyncQueue();
    } catch (error) {
      console.error('Sync failed:', error);
    } finally {
      this.syncInProgress = false;
    }
  }

  private async processSyncQueue(): Promise<void> {
    const pendingOperations = await this.getPendingOperations();
    
    for (const operation of pendingOperations) {
      try {
        await this.syncOperation(operation);
      } catch (error) {
        await this.handleSyncError(operation, error);
      }
    }
  }

  private async syncOperation(operation: OfflineOperation): Promise<void> {
    // Marquer comme en cours de sync
    operation.status = 'syncing';
    operation.attempts++;
    await this.updateOperation(operation);

    let response: Response;
    
    switch (operation.type) {
      case 'create':
        response = await fetch(`/api/v1/${operation.entity}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(operation.data)
        });
        break;
        
      case 'update':
        response = await fetch(`/api/v1/${operation.entity}/${operation.data.id}`, {
          method: 'PUT', 
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(operation.data)
        });
        break;
        
      case 'delete':
        response = await fetch(`/api/v1/${operation.entity}/${operation.data.id}`, {
          method: 'DELETE'
        });
        break;
        
      default:
        throw new Error(`Unknown operation type: ${operation.type}`);
    }

    if (!response.ok) {
      if (response.status === 409) {
        // Conflit - nécessite résolution
        await this.handleConflict(operation, await response.json());
      } else {
        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
      }
    } else {
      // Succès
      operation.status = 'completed';
      await this.updateOperation(operation);
      await this.removeFromQueue(operation.id);
    }
  }

  private async handleSyncError(operation: OfflineOperation, error: any): Promise<void> {
    const maxAttempts = 5;
    
    if (operation.attempts >= maxAttempts) {
      operation.status = 'failed';
      operation.error = error.message;
      await this.updateOperation(operation);
      
      // Notification à l'utilisateur
      this.notifyUserOfFailedSync(operation);
    } else {
      // Réessayer plus tard avec backoff exponentiel
      operation.status = 'pending';
      await this.updateOperation(operation);
      
      const delay = Math.pow(2, operation.attempts) * 1000; // 2^n secondes
      setTimeout(() => {
        if (this.isOnline) this.triggerSync();
      }, delay);
    }
  }

  private async handleConflict(operation: OfflineOperation, serverData: any): Promise<void> {
    const conflict = {
      id: `conflict-${operation.id}`,
      entity: operation.entity,
      operationId: operation.id,
      clientData: operation.data,
      serverData,
      timestamp: new Date(),
      resolved: false
    };

    await this.saveToIndexedDB('conflicts', conflict);
    
    // Notifier l'utilisateur du conflit
    this.notifyUserOfConflict(conflict);
  }

  async resolveConflict(
    conflictId: string, 
    resolution: 'client' | 'server' | 'merge',
    mergedData?: any
  ): Promise<void> {
    const conflict = await this.getFromIndexedDB('conflicts', conflictId);
    if (!conflict) return;

    let finalData: any;
    
    switch (resolution) {
      case 'client':
        finalData = conflict.clientData;
        break;
      case 'server':
        finalData = conflict.serverData;
        break;
      case 'merge':
        finalData = mergedData;
        break;
    }

    // Appliquer la résolution
    const response = await fetch(`/api/v1/${conflict.entity}/${finalData.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(finalData)
    });

    if (response.ok) {
      // Marquer conflit comme résolu
      conflict.resolved = true;
      await this.updateInIndexedDB('conflicts', conflict);
      
      // Supprimer l'opération de la queue
      await this.removeFromQueue(conflict.operationId);
    }
  }

  // Utilitaires IndexedDB
  private async saveToIndexedDB(storeName: string, data: any): Promise<void> {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.put(data);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  private async getFromIndexedDB(storeName: string, key: string): Promise<any> {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  private startPeriodicSync(): void {
    setInterval(() => {
      if (this.isOnline && !this.syncInProgress) {
        this.triggerSync();
      }
    }, 30000); // Toutes les 30 secondes
  }

  // API publique pour les composants
  async saveHarvestOffline(harvestData: any): Promise<string> {
    // Validation locale
    const validationResult = this.validateHarvestData(harvestData);
    if (!validationResult.valid) {
      throw new Error(`Validation failed: ${validationResult.errors.join(', ')}`);
    }

    // Cache local
    const cacheKey = `harvest-${Date.now()}`;
    await this.cacheData('harvests', cacheKey, harvestData);

    // Queue sync
    return await this.queueOperation({
      type: 'create',
      entity: 'harvests',
      data: harvestData
    });
  }

  private validateHarvestData(data: any): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    if (!data.quantity || data.quantity <= 0) {
      errors.push('Quantité requise et doit être positive');
    }
    
    if (!data.unit) {
      errors.push('Unité requise');
    }
    
    if (!data.date) {
      errors.push('Date requise');
    }

    return { valid: errors.length === 0, errors };
  }

  private notifyUserOfFailedSync(operation: OfflineOperation): void {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification('Échec de synchronisation', {
        body: `Impossible de synchroniser ${operation.entity}. Vérifiez votre connexion.`,
        icon: '/icons/icon-192x192.png'
      });
    }
  }

  private notifyUserOfConflict(conflict: any): void {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification('Conflit de données détecté', {
        body: 'Des modifications ont été faites par ailleurs. Résolution manuelle requise.',
        icon: '/icons/icon-192x192.png'
      });
    }
  }
}
```

### Hook React pour PWA

```typescript
// src/hooks/usePWA.ts
export function usePWA() {
  const [installPrompt, setInstallPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [isInstalled, setIsInstalled] = useState(false);
  const [isOffline, setIsOffline] = useState(!navigator.onLine);
  const [syncStatus, setSyncStatus] = useState<'synced' | 'syncing' | 'pending' | 'failed'>('synced');

  useEffect(() => {
    // Détection prompt d'installation
    const handleBeforeInstallPrompt = (e: BeforeInstallPromptEvent) => {
      e.preventDefault();
      setInstallPrompt(e);
    };

    // Détection installation
    const handleAppInstalled = () => {
      setIsInstalled(true);
      setInstallPrompt(null);
    };

    // État connexion
    const handleOnline = () => setIsOffline(false);
    const handleOffline = () => setIsOffline(true);

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // Vérification installation existante
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true);
    }

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const installApp = async () => {
    if (!installPrompt) return false;

    const result = await installPrompt.prompt();
    setInstallPrompt(null);
    
    return result.outcome === 'accepted';
  };

  const shareContent = async (data: ShareData) => {
    if (navigator.share) {
      try {
        await navigator.share(data);
        return true;
      } catch (error) {
        return false;
      }
    }
    return false;
  };

  const requestNotificationPermission = async () => {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission();
      return permission === 'granted';
    }
    return false;
  };

  return {
    installPrompt: !!installPrompt,
    isInstalled,
    isOffline,
    syncStatus,
    installApp,
    shareContent,
    requestNotificationPermission
  };
}
```

### Interface PWA

```typescript
// src/components/PWA/InstallPrompt.tsx
export const InstallPrompt = () => {
  const { installPrompt, installApp } = usePWA();
  const [showPrompt, setShowPrompt] = useState(false);

  useEffect(() => {
    if (installPrompt) {
      setShowPrompt(true);
    }
  }, [installPrompt]);

  if (!showPrompt) return null;

  return (
    <div className="fixed bottom-4 left-4 right-4 md:left-auto md:w-96 z-50">
      <Card className="p-4 shadow-lg border-green-200 bg-green-50">
        <div className="flex items-start space-x-3">
          <div className="w-10 h-10 bg-green-500 rounded-lg flex items-center justify-center">
            <DownloadIcon className="w-5 h-5 text-white" />
          </div>
          
          <div className="flex-1">
            <h3 className="font-semibold text-green-800 mb-1">
              Installer Baš-Malin
            </h3>
            <p className="text-sm text-green-700 mb-3">
              Accédez instantanément à votre jardin depuis votre écran d'accueil
            </p>
            
            <div className="flex space-x-2">
              <Button size="sm" onClick={installApp}>
                Installer
              </Button>
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => setShowPrompt(false)}
              >
                Plus tard
              </Button>
            </div>
          </div>
          
          <Button
            size="sm"
            variant="ghost"
            onClick={() => setShowPrompt(false)}
          >
            <XIcon className="w-4 h-4" />
          </Button>
        </div>
      </Card>
    </div>
  );
};

// src/components/PWA/OfflineIndicator.tsx
export const OfflineIndicator = () => {
  const { isOffline, syncStatus } = usePWA();

  if (!isOffline && syncStatus === 'synced') return null;

  return (
    <div className={`fixed top-4 left-4 right-4 md:left-auto md:w-96 z-40 ${
      isOffline ? 'bg-orange-50 border-orange-200' : 'bg-blue-50 border-blue-200'
    } border rounded-lg p-3`}>
      <div className="flex items-center space-x-2">
        {isOffline ? (
          <WifiOffIcon className="w-4 h-4 text-orange-500" />
        ) : (
          <RefreshCwIcon className={`w-4 h-4 text-blue-500 ${syncStatus === 'syncing' ? 'animate-spin' : ''}`} />
        )}
        
        <span className={`text-sm font-medium ${
          isOffline ? 'text-orange-800' : 'text-blue-800'
        }`}>
          {isOffline && 'Mode hors ligne'}
          {syncStatus === 'syncing' && 'Synchronisation...'}
          {syncStatus === 'pending' && 'En attente de synchronisation'}
          {syncStatus === 'failed' && 'Échec de synchronisation'}
        </span>
      </div>
    </div>
  );
};
```

## Critères d'Acceptation Techniques

### Installation PWA
- [ ] Prompt d'installation sur mobile/desktop
- [ ] Icônes adaptatives toutes tailles
- [ ] Splash screen personnalisé
- [ ] Mode standalone (sans UI navigateur)
- [ ] Raccourcis app avec actions rapides

### Mode Offline
- [ ] Cache intelligent données critiques
- [ ] Validation locale avant sauvegarde
- [ ] Interface utilisable 100% offline
- [ ] Indicateur état connexion visible
- [ ] Queue synchronisation persistante

### Synchronisation
- [ ] Sync automatique au retour connexion
- [ ] Résolution conflits configurable
- [ ] Retry avec backoff exponentiel
- [ ] Logs détaillés synchronisation
- [ ] Notifications erreurs sync

## Couverture Exigences Architecture

- **EXG-003.1** : PWA responsive toutes plateformes
- **EXG-002.1** : Cache local avec IndexedDB
- **EXG-007.1** : Notifications push natives
- **EXG-009.1** : Monitoring sync et performance

## Tests d'Acceptation

```typescript
// tests/integration/pwa-offline.test.ts
describe('PWA Offline Functionality', () => {
  test('sauvegarde offline fonctionne', async () => {
    // Simuler mode offline
    Object.defineProperty(navigator, 'onLine', { value: false });
    
    const harvestData = {
      quantity: 2.5,
      unit: 'kg',
      date: '2024-08-20',
      notes: 'Test offline'
    };
    
    const operationId = await offlineService.saveHarvestOffline(harvestData);
    expect(operationId).toBeDefined();
    
    const cachedData = await offlineService.getOfflineData('harvests', operationId);
    expect(cachedData.quantity).toBe(2.5);
  });

  test('synchronisation au retour connexion', async () => {
    // Queue operation offline
    const operationId = await offlineService.queueOperation({
      type: 'create',
      entity: 'harvests',
      data: testHarvestData
    });
    
    // Simuler retour connexion
    Object.defineProperty(navigator, 'onLine', { value: true });
    window.dispatchEvent(new Event('online'));
    
    // Attendre sync
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const operation = await offlineService.getOperation(operationId);
    expect(operation.status).toBe('completed');
  });

  test('installation PWA disponible', async () => {
    const { installPrompt } = usePWA();
    
    // Simuler event beforeinstallprompt
    const mockEvent = new CustomEvent('beforeinstallprompt');
    window.dispatchEvent(mockEvent);
    
    expect(installPrompt).toBe(true);
  });
});
```

Cette spécification couvre une PWA complète avec mode offline robuste et synchronisation intelligente pour une expérience utilisateur optimale.