# F7.1 - Export/Import de Données

**Score Priorité :** 55/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 7 - EXTENSIONS  
**Effort estimé :** 8 jours  

## Description

Système complet d'export et import de données avec support de multiples formats, sauvegarde complète du jardin, migration entre comptes et intégration avec outils tiers pour assurer la portabilité et la pérennité des données utilisateur.

## User Stories

### US7.1.1 - Export Complet des Données
**En tant qu'** utilisateur expert  
**Je veux** exporter toutes mes données de jardinage  
**Afin de** sauvegarder mon historique et migrer vers d'autres systèmes  

**Critères d'acceptation :**
- Export JSON/CSV/PDF de toutes les données
- Choix sélectif des types de données à exporter
- Génération archives ZIP avec structure organisée
- Export planifiable automatiquement
- Conformité RGPD pour portabilité des données

### US7.1.2 - Import depuis Autres Systèmes
**En tant qu'** nouvel utilisateur  
**Je veux** importer mes données depuis d'autres applications  
**Afin de** conserver mon historique de jardinage  

**Critères d'acceptation :**
- Import CSV standardisé (tableur)
- Connecteurs pour applications populaires (GrowVeg, PlanIT, etc.)
- Assistant d'import avec mapping des champs
- Validation et nettoyage automatique des données
- Gestion des conflits et doublons

### US7.1.3 - Synchronisation Externe
**En tant qu'** utilisateur avancé  
**Je veux** synchroniser avec mes outils existants  
**Afin d'** intégrer Baš-Malin dans mon workflow  

**Critères d'acceptation :**
- API REST pour intégrations tierces
- Webhooks pour notifications automatiques
- Synchronisation bidirectionnelle Google Sheets
- Export automatique vers cloud (Dropbox, Google Drive)
- Format standard pour échange de données jardin

## Architecture Technique

### Service d'Export

```typescript
// src/services/export/export.service.ts
export interface ExportConfig {
  format: 'json' | 'csv' | 'pdf' | 'excel';
  scope: ExportScope;
  dateRange?: DateRange;
  includeImages: boolean;
  includePrivateData: boolean;
  compression: boolean;
}

export interface ExportScope {
  gardens: boolean;
  cultures: boolean;
  harvests: boolean;
  interventions: boolean;
  sensors: boolean;
  weather: boolean;
  analytics: boolean;
  community: boolean;
}

export class ExportService {
  constructor(
    private prisma: PrismaClient,
    private storageService: StorageService,
    private pdfService: PDFService
  ) {}

  async exportUserData(userId: string, config: ExportConfig): Promise<ExportResult> {
    const exportJob = await this.createExportJob(userId, config);
    
    try {
      const data = await this.collectExportData(userId, config);
      const processedData = await this.processExportData(data, config);
      const filePath = await this.generateExportFile(processedData, config);
      
      await this.finalizeExport(exportJob.id, filePath);
      
      return {
        jobId: exportJob.id,
        filePath,
        fileSize: await this.getFileSize(filePath),
        downloadUrl: await this.getDownloadUrl(filePath),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 jours
      };
    } catch (error) {
      await this.markExportFailed(exportJob.id, error.message);
      throw error;
    }
  }

  private async collectExportData(userId: string, config: ExportScope): Promise<ExportData> {
    const data: ExportData = {};

    if (config.gardens) {
      data.gardens = await this.prisma.jardin.findMany({
        where: { userId },
        include: {
          zones: {
            include: {
              instancesCultures: {
                include: {
                  varieteCulture: true,
                  recoltes: true,
                  interventions: true
                }
              }
            }
          }
        }
      });
    }

    if (config.cultures) {
      data.cultures = await this.prisma.varieteCulture.findMany({
        where: { createdBy: userId }
      });
    }

    if (config.harvests) {
      data.harvests = await this.prisma.recolte.findMany({
        where: {
          instanceCulture: {
            zone: {
              jardin: { userId }
            }
          }
        },
        include: {
          instanceCulture: {
            include: { varieteCulture: true }
          }
        }
      });
    }

    if (config.interventions) {
      data.interventions = await this.prisma.intervention.findMany({
        where: {
          instanceCulture: {
            zone: {
              jardin: { userId }
            }
          }
        }
      });
    }

    if (config.sensors) {
      data.sensorData = await this.prisma.lectureCapteur.findMany({
        where: {
          capteurIoT: {
            appareilIoT: {
              jardin: { userId }
            }
          }
        },
        take: 10000, // Limiter pour éviter exports trop lourds
        orderBy: { timestamp: 'desc' }
      });
    }

    return data;
  }

  private async generateExportFile(data: ProcessedExportData, config: ExportConfig): Promise<string> {
    const timestamp = new Date().toISOString().split('T')[0];
    const fileName = `basmalin-export-${timestamp}`;

    switch (config.format) {
      case 'json':
        return this.generateJSONExport(data, fileName);
      case 'csv':
        return this.generateCSVExport(data, fileName);
      case 'pdf':
        return this.generatePDFExport(data, fileName);
      case 'excel':
        return this.generateExcelExport(data, fileName);
      default:
        throw new Error(`Unsupported format: ${config.format}`);
    }
  }

  private async generateJSONExport(data: ProcessedExportData, fileName: string): Promise<string> {
    const jsonData = {
      metadata: {
        exportDate: new Date().toISOString(),
        version: '1.0',
        source: 'Baš-Malin',
        format: 'json'
      },
      data
    };

    const filePath = `exports/${fileName}.json`;
    await this.storageService.writeFile(filePath, JSON.stringify(jsonData, null, 2));
    
    return filePath;
  }

  private async generateCSVExport(data: ProcessedExportData, fileName: string): Promise<string> {
    const zipPath = `exports/${fileName}.zip`;
    const zip = new JSZip();

    // Un fichier CSV par type de données
    for (const [type, records] of Object.entries(data)) {
      if (Array.isArray(records) && records.length > 0) {
        const csv = this.convertToCSV(records);
        zip.file(`${type}.csv`, csv);
      }
    }

    // Fichier README avec structure
    zip.file('README.txt', this.generateExportReadme(data));

    const buffer = await zip.generateAsync({ type: 'nodebuffer' });
    await this.storageService.writeFile(zipPath, buffer);
    
    return zipPath;
  }

  private async generatePDFExport(data: ProcessedExportData, fileName: string): Promise<string> {
    const pdfPath = `exports/${fileName}.pdf`;
    
    const html = await this.generateHTMLReport(data);
    const pdfBuffer = await this.pdfService.generatePDF(html, {
      format: 'A4',
      margin: '20px',
      displayHeaderFooter: true,
      headerTemplate: '<div class="header">Rapport Jardin Baš-Malin</div>',
      footerTemplate: '<div class="footer">Page <span class="pageNumber"></span> / <span class="totalPages"></span></div>'
    });

    await this.storageService.writeFile(pdfPath, pdfBuffer);
    
    return pdfPath;
  }
}
```

### Service d'Import

```typescript
// src/services/import/import.service.ts
export interface ImportConfig {
  source: 'csv' | 'json' | 'external_api';
  mapping: FieldMapping;
  options: ImportOptions;
  validation: ValidationRules;
}

export interface FieldMapping {
  [sourceField: string]: {
    targetField: string;
    transform?: (value: any) => any;
    required: boolean;
  };
}

export class ImportService {
  constructor(
    private prisma: PrismaClient,
    private validationService: DataValidationService
  ) {}

  async importData(userId: string, filePath: string, config: ImportConfig): Promise<ImportResult> {
    const importJob = await this.createImportJob(userId, config);
    
    try {
      // Lecture et parsing du fichier
      const rawData = await this.readImportFile(filePath, config.source);
      
      // Mapping des champs
      const mappedData = this.mapFields(rawData, config.mapping);
      
      // Validation des données
      const validationResult = await this.validateImportData(mappedData, config.validation);
      
      if (validationResult.hasErrors) {
        throw new ImportError('Validation failed', validationResult.errors);
      }
      
      // Import en base avec transaction
      const result = await this.performImport(userId, validationResult.cleanData);
      
      await this.finalizeImport(importJob.id, result);
      
      return result;
    } catch (error) {
      await this.markImportFailed(importJob.id, error.message);
      throw error;
    }
  }

  private async performImport(userId: string, data: CleanImportData): Promise<ImportResult> {
    const result: ImportResult = {
      created: { gardens: 0, cultures: 0, harvests: 0, interventions: 0 },
      updated: { gardens: 0, cultures: 0, harvests: 0, interventions: 0 },
      skipped: { gardens: 0, cultures: 0, harvests: 0, interventions: 0 },
      errors: []
    };

    await this.prisma.$transaction(async (tx) => {
      // Import des jardins
      if (data.gardens) {
        for (const gardenData of data.gardens) {
          try {
            const existing = await tx.jardin.findFirst({
              where: {
                userId,
                nom: gardenData.nom
              }
            });

            if (existing) {
              await tx.jardin.update({
                where: { id: existing.id },
                data: gardenData
              });
              result.updated.gardens++;
            } else {
              await tx.jardin.create({
                data: { ...gardenData, userId }
              });
              result.created.gardens++;
            }
          } catch (error) {
            result.errors.push(`Garden import error: ${error.message}`);
            result.skipped.gardens++;
          }
        }
      }

      // Import des cultures
      if (data.cultures) {
        for (const cultureData of data.cultures) {
          try {
            const existing = await tx.varieteCulture.findFirst({
              where: {
                nom: cultureData.nom,
                createdBy: userId
              }
            });

            if (!existing) {
              await tx.varieteCulture.create({
                data: { ...cultureData, createdBy: userId }
              });
              result.created.cultures++;
            } else {
              result.skipped.cultures++;
            }
          } catch (error) {
            result.errors.push(`Culture import error: ${error.message}`);
            result.skipped.cultures++;
          }
        }
      }

      // Import des récoltes avec gestion des dépendances
      if (data.harvests) {
        for (const harvestData of data.harvests) {
          try {
            // Recherche de l'instance de culture correspondante
            const instanceCulture = await this.findMatchingCultureInstance(
              tx, 
              userId, 
              harvestData
            );

            if (instanceCulture) {
              await tx.recolte.create({
                data: {
                  ...harvestData,
                  instanceCultureId: instanceCulture.id
                }
              });
              result.created.harvests++;
            } else {
              result.skipped.harvests++;
              result.errors.push(`No matching culture instance for harvest`);
            }
          } catch (error) {
            result.errors.push(`Harvest import error: ${error.message}`);
            result.skipped.harvests++;
          }
        }
      }
    });

    return result;
  }

  async importFromCSV(userId: string, csvContent: string, mapping: FieldMapping): Promise<ImportResult> {
    const Papa = require('papaparse');
    
    const parseResult = Papa.parse(csvContent, {
      header: true,
      skipEmptyLines: true,
      transform: (value: string) => value.trim()
    });

    if (parseResult.errors.length > 0) {
      throw new ImportError('CSV parsing failed', parseResult.errors);
    }

    return this.importData(userId, parseResult.data, {
      source: 'csv',
      mapping,
      options: { batchSize: 100 },
      validation: { strict: false }
    });
  }

  async importFromGoogleSheets(userId: string, spreadsheetId: string, range: string): Promise<ImportResult> {
    // Intégration Google Sheets API
    const sheets = google.sheets({ version: 'v4', auth: this.googleAuth });
    
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range
    });

    const rows = response.data.values;
    if (!rows || rows.length === 0) {
      throw new ImportError('No data found in spreadsheet');
    }

    // Conversion en format standard
    const headers = rows[0];
    const data = rows.slice(1).map(row => {
      const obj: any = {};
      headers.forEach((header, index) => {
        obj[header] = row[index] || '';
      });
      return obj;
    });

    // Auto-détection du mapping
    const suggestedMapping = this.suggestFieldMapping(headers);

    return this.importData(userId, data, {
      source: 'json',
      mapping: suggestedMapping,
      options: { autoDetectFormat: true },
      validation: { strict: false }
    });
  }

  private suggestFieldMapping(headers: string[]): FieldMapping {
    const mapping: FieldMapping = {};
    
    const commonMappings = {
      'name': 'nom',
      'variety': 'varieteCulture.nom',
      'plant_date': 'datePlantation',
      'harvest_date': 'dateRecolte',
      'quantity': 'quantite',
      'weight': 'poids',
      'notes': 'notes'
    };

    headers.forEach(header => {
      const normalized = header.toLowerCase().replace(/[^a-z0-9]/g, '_');
      if (commonMappings[normalized]) {
        mapping[header] = {
          targetField: commonMappings[normalized],
          required: false
        };
      }
    });

    return mapping;
  }
}
```

### Interface Export/Import

```typescript
// src/app/settings/data/page.tsx
export default function DataManagementPage() {
  const [activeTab, setActiveTab] = useState<'export' | 'import' | 'sync'>('export');

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-2xl font-bold mb-6">Gestion des Données</h1>
        
        <div className="bg-white rounded-lg shadow">
          <div className="border-b">
            <div className="flex space-x-1">
              {[
                { id: 'export', label: 'Export', icon: '📤' },
                { id: 'import', label: 'Import', icon: '📥' },
                { id: 'sync', label: 'Synchronisation', icon: '🔄' }
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id as any)}
                  className={`px-6 py-3 border-b-2 font-medium text-sm ${
                    activeTab === tab.id
                      ? 'border-green-500 text-green-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700'
                  }`}
                >
                  {tab.icon} {tab.label}
                </button>
              ))}
            </div>
          </div>

          <div className="p-6">
            {activeTab === 'export' && <ExportPanel />}
            {activeTab === 'import' && <ImportPanel />}
            {activeTab === 'sync' && <SyncPanel />}
          </div>
        </div>
      </div>
    </div>
  );
}

const ExportPanel = () => {
  const [exportConfig, setExportConfig] = useState<ExportConfig>({
    format: 'json',
    scope: {
      gardens: true,
      cultures: true,
      harvests: true,
      interventions: true,
      sensors: false,
      weather: false,
      analytics: false,
      community: false
    },
    includeImages: true,
    includePrivateData: true,
    compression: true
  });

  const handleExport = async () => {
    try {
      const result = await exportService.exportUserData(exportConfig);
      // Téléchargement automatique
      window.open(result.downloadUrl);
    } catch (error) {
      console.error('Export failed:', error);
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-4">Exporter vos Données</h3>
        <p className="text-gray-600 mb-6">
          Sauvegardez toutes vos données de jardinage dans le format de votre choix.
        </p>
      </div>

      {/* Format selection */}
      <div>
        <label className="block text-sm font-medium mb-2">Format d'export</label>
        <Select value={exportConfig.format} onValueChange={(value) => 
          setExportConfig(prev => ({ ...prev, format: value as any }))
        }>
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="json">JSON (complet)</SelectItem>
            <SelectItem value="csv">CSV (tableur)</SelectItem>
            <SelectItem value="pdf">PDF (rapport)</SelectItem>
            <SelectItem value="excel">Excel</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Data scope */}
      <div>
        <label className="block text-sm font-medium mb-3">Données à inclure</label>
        <div className="grid grid-cols-2 gap-3">
          {Object.entries(exportConfig.scope).map(([key, value]) => (
            <div key={key} className="flex items-center space-x-2">
              <Checkbox
                checked={value}
                onCheckedChange={(checked) =>
                  setExportConfig(prev => ({
                    ...prev,
                    scope: { ...prev.scope, [key]: checked }
                  }))
                }
              />
              <label className="text-sm capitalize">{key.replace(/([A-Z])/g, ' $1')}</label>
            </div>
          ))}
        </div>
      </div>

      {/* Options */}
      <div>
        <label className="block text-sm font-medium mb-3">Options</label>
        <div className="space-y-2">
          <div className="flex items-center space-x-2">
            <Checkbox
              checked={exportConfig.includeImages}
              onCheckedChange={(checked) =>
                setExportConfig(prev => ({ ...prev, includeImages: checked }))
              }
            />
            <label className="text-sm">Inclure les images</label>
          </div>
          <div className="flex items-center space-x-2">
            <Checkbox
              checked={exportConfig.compression}
              onCheckedChange={(checked) =>
                setExportConfig(prev => ({ ...prev, compression: checked }))
              }
            />
            <label className="text-sm">Compresser l'archive</label>
          </div>
        </div>
      </div>

      <Button onClick={handleExport} className="w-full">
        <DownloadIcon className="w-4 h-4 mr-2" />
        Générer l'Export
      </Button>
    </div>
  );
};

const ImportPanel = () => {
  const [dragActive, setDragActive] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(false);
    
    const files = e.dataTransfer.files;
    if (files && files[0]) {
      setSelectedFile(files[0]);
    }
  };

  const handleImport = async () => {
    if (!selectedFile) return;

    try {
      const formData = new FormData();
      formData.append('file', selectedFile);
      
      const result = await importService.importFile(formData);
      console.log('Import successful:', result);
    } catch (error) {
      console.error('Import failed:', error);
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-4">Importer des Données</h3>
        <p className="text-gray-600 mb-6">
          Importez vos données depuis d'autres applications ou fichiers CSV/JSON.
        </p>
      </div>

      {/* File drop zone */}
      <div
        className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
          dragActive ? 'border-green-500 bg-green-50' : 'border-gray-300'
        }`}
        onDragEnter={(e) => { e.preventDefault(); setDragActive(true); }}
        onDragLeave={(e) => { e.preventDefault(); setDragActive(false); }}
        onDragOver={(e) => e.preventDefault()}
        onDrop={handleDrop}
      >
        {selectedFile ? (
          <div>
            <FileIcon className="w-12 h-12 mx-auto text-green-500 mb-2" />
            <p className="font-medium">{selectedFile.name}</p>
            <p className="text-sm text-gray-500">{(selectedFile.size / 1024).toFixed(1)} KB</p>
          </div>
        ) : (
          <div>
            <UploadIcon className="w-12 h-12 mx-auto text-gray-400 mb-4" />
            <p className="text-lg font-medium">Glissez votre fichier ici</p>
            <p className="text-gray-500">ou cliquez pour sélectionner</p>
            <p className="text-xs text-gray-400 mt-2">
              Formats supportés: CSV, JSON, Excel
            </p>
          </div>
        )}
      </div>

      {selectedFile && (
        <Button onClick={handleImport} className="w-full">
          <UploadIcon className="w-4 h-4 mr-2" />
          Lancer l'Import
        </Button>
      )}

      {/* Quick imports */}
      <div>
        <h4 className="font-medium mb-3">Imports Rapides</h4>
        <div className="grid grid-cols-2 gap-3">
          <Button variant="outline">
            📊 Google Sheets
          </Button>
          <Button variant="outline">
            🌱 GrowVeg
          </Button>
        </div>
      </div>
    </div>
  );
};
```

## Critères d'Acceptation Techniques

### Export
- [ ] Support JSON, CSV, PDF, Excel
- [ ] Export sélectif par type de données
- [ ] Compression automatique des archives
- [ ] Planification d'exports automatiques
- [ ] Conformité RGPD portabilité

### Import
- [ ] Auto-détection format et encoding
- [ ] Mapping flexible des champs
- [ ] Validation et nettoyage données
- [ ] Gestion des conflits et doublons
- [ ] Import par batch pour gros volumes

### Synchronisation
- [ ] API REST pour intégrations tierces
- [ ] Webhooks bidirectionnels
- [ ] Sync Google Sheets temps réel
- [ ] Format standard échange de données
- [ ] Monitoring des synchronisations

## Couverture Exigences Architecture

- **EXG-002.1** : Export optimisé depuis PostgreSQL
- **EXG-008.2** : Conformité RGPD portabilité
- **EXG-010.1** : API REST pour intégrations
- **EXG-009.1** : Monitoring des exports/imports

## Tests d'Acceptation

```typescript
// tests/integration/export-import.test.ts
describe('Export/Import System', () => {
  test('export complet utilisateur fonctionne', async () => {
    const config = createFullExportConfig();
    const result = await exportService.exportUserData('user-1', config);
    
    expect(result.filePath).toBeDefined();
    expect(result.downloadUrl).toBeDefined();
    expect(result.fileSize).toBeGreaterThan(0);
  });

  test('import CSV avec mapping automatique', async () => {
    const csvContent = createTestCSVContent();
    const result = await importService.importFromCSV('user-2', csvContent, {});
    
    expect(result.created.harvests).toBeGreaterThan(0);
    expect(result.errors).toHaveLength(0);
  });

  test('synchronisation Google Sheets bidirectionnelle', async () => {
    const spreadsheetId = 'test-sheet-id';
    await importService.importFromGoogleSheets('user-1', spreadsheetId, 'A1:Z100');
    
    const exported = await exportService.exportToGoogleSheets('user-1', spreadsheetId);
    expect(exported.success).toBe(true);
  });
});
```

Cette spécification couvre un système complet d'export/import avec support multi-formats et intégrations tierces pour assurer la portabilité des données.