# F7.1 - Export/Import de Donn√©es

**Score Priorit√© :** 55/100  
**Statut :** PRIORIT√â FAIBLE  
**Epic :** EPIC 7 - EXTENSIONS  
**Effort estim√© :** 8 jours  

## Description

Syst√®me complet d'export et import de donn√©es avec support de multiples formats, sauvegarde compl√®te du jardin, migration entre comptes et int√©gration avec outils tiers pour assurer la portabilit√© et la p√©rennit√© des donn√©es utilisateur.

## User Stories

### US7.1.1 - Export Complet des Donn√©es
**En tant qu'** utilisateur expert  
**Je veux** exporter toutes mes donn√©es de jardinage  
**Afin de** sauvegarder mon historique et migrer vers d'autres syst√®mes  

**Crit√®res d'acceptation :**
- Export JSON/CSV/PDF de toutes les donn√©es
- Choix s√©lectif des types de donn√©es √† exporter
- G√©n√©ration archives ZIP avec structure organis√©e
- Export planifiable automatiquement
- Conformit√© RGPD pour portabilit√© des donn√©es

### US7.1.2 - Import depuis Autres Syst√®mes
**En tant qu'** nouvel utilisateur  
**Je veux** importer mes donn√©es depuis d'autres applications  
**Afin de** conserver mon historique de jardinage  

**Crit√®res d'acceptation :**
- Import CSV standardis√© (tableur)
- Connecteurs pour applications populaires (GrowVeg, PlanIT, etc.)
- Assistant d'import avec mapping des champs
- Validation et nettoyage automatique des donn√©es
- Gestion des conflits et doublons

### US7.1.3 - Synchronisation Externe
**En tant qu'** utilisateur avanc√©  
**Je veux** synchroniser avec mes outils existants  
**Afin d'** int√©grer Ba≈°-Malin dans mon workflow  

**Crit√®res d'acceptation :**
- API REST pour int√©grations tierces
- Webhooks pour notifications automatiques
- Synchronisation bidirectionnelle Google Sheets
- Export automatique vers cloud (Dropbox, Google Drive)
- Format standard pour √©change de donn√©es jardin

## Architecture Technique

### Service d'Export

```typescript
// src/services/export/export.service.ts
export interface ExportConfig {
  format: 'json' | 'csv' | 'pdf' | 'excel';
  scope: ExportScope;
  dateRange?: DateRange;
  includeImages: boolean;
  includePrivateData: boolean;
  compression: boolean;
}

export interface ExportScope {
  gardens: boolean;
  cultures: boolean;
  harvests: boolean;
  interventions: boolean;
  sensors: boolean;
  weather: boolean;
  analytics: boolean;
  community: boolean;
}

export class ExportService {
  constructor(
    private prisma: PrismaClient,
    private storageService: StorageService,
    private pdfService: PDFService
  ) {}

  async exportUserData(userId: string, config: ExportConfig): Promise<ExportResult> {
    const exportJob = await this.createExportJob(userId, config);
    
    try {
      const data = await this.collectExportData(userId, config);
      const processedData = await this.processExportData(data, config);
      const filePath = await this.generateExportFile(processedData, config);
      
      await this.finalizeExport(exportJob.id, filePath);
      
      return {
        jobId: exportJob.id,
        filePath,
        fileSize: await this.getFileSize(filePath),
        downloadUrl: await this.getDownloadUrl(filePath),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 jours
      };
    } catch (error) {
      await this.markExportFailed(exportJob.id, error.message);
      throw error;
    }
  }

  private async collectExportData(userId: string, config: ExportScope): Promise<ExportData> {
    const data: ExportData = {};

    if (config.gardens) {
      data.gardens = await this.prisma.jardin.findMany({
        where: { userId },
        include: {
          zones: {
            include: {
              instancesCultures: {
                include: {
                  varieteCulture: true,
                  recoltes: true,
                  interventions: true
                }
              }
            }
          }
        }
      });
    }

    if (config.cultures) {
      data.cultures = await this.prisma.varieteCulture.findMany({
        where: { createdBy: userId }
      });
    }

    if (config.harvests) {
      data.harvests = await this.prisma.recolte.findMany({
        where: {
          instanceCulture: {
            zone: {
              jardin: { userId }
            }
          }
        },
        include: {
          instanceCulture: {
            include: { varieteCulture: true }
          }
        }
      });
    }

    if (config.interventions) {
      data.interventions = await this.prisma.intervention.findMany({
        where: {
          instanceCulture: {
            zone: {
              jardin: { userId }
            }
          }
        }
      });
    }

    if (config.sensors) {
      data.sensorData = await this.prisma.lectureCapteur.findMany({
        where: {
          capteurIoT: {
            appareilIoT: {
              jardin: { userId }
            }
          }
        },
        take: 10000, // Limiter pour √©viter exports trop lourds
        orderBy: { timestamp: 'desc' }
      });
    }

    return data;
  }

  private async generateExportFile(data: ProcessedExportData, config: ExportConfig): Promise<string> {
    const timestamp = new Date().toISOString().split('T')[0];
    const fileName = `basmalin-export-${timestamp}`;

    switch (config.format) {
      case 'json':
        return this.generateJSONExport(data, fileName);
      case 'csv':
        return this.generateCSVExport(data, fileName);
      case 'pdf':
        return this.generatePDFExport(data, fileName);
      case 'excel':
        return this.generateExcelExport(data, fileName);
      default:
        throw new Error(`Unsupported format: ${config.format}`);
    }
  }

  private async generateJSONExport(data: ProcessedExportData, fileName: string): Promise<string> {
    const jsonData = {
      metadata: {
        exportDate: new Date().toISOString(),
        version: '1.0',
        source: 'Ba≈°-Malin',
        format: 'json'
      },
      data
    };

    const filePath = `exports/${fileName}.json`;
    await this.storageService.writeFile(filePath, JSON.stringify(jsonData, null, 2));
    
    return filePath;
  }

  private async generateCSVExport(data: ProcessedExportData, fileName: string): Promise<string> {
    const zipPath = `exports/${fileName}.zip`;
    const zip = new JSZip();

    // Un fichier CSV par type de donn√©es
    for (const [type, records] of Object.entries(data)) {
      if (Array.isArray(records) && records.length > 0) {
        const csv = this.convertToCSV(records);
        zip.file(`${type}.csv`, csv);
      }
    }

    // Fichier README avec structure
    zip.file('README.txt', this.generateExportReadme(data));

    const buffer = await zip.generateAsync({ type: 'nodebuffer' });
    await this.storageService.writeFile(zipPath, buffer);
    
    return zipPath;
  }

  private async generatePDFExport(data: ProcessedExportData, fileName: string): Promise<string> {
    const pdfPath = `exports/${fileName}.pdf`;
    
    const html = await this.generateHTMLReport(data);
    const pdfBuffer = await this.pdfService.generatePDF(html, {
      format: 'A4',
      margin: '20px',
      displayHeaderFooter: true,
      headerTemplate: '<div class="header">Rapport Jardin Ba≈°-Malin</div>',
      footerTemplate: '<div class="footer">Page <span class="pageNumber"></span> / <span class="totalPages"></span></div>'
    });

    await this.storageService.writeFile(pdfPath, pdfBuffer);
    
    return pdfPath;
  }
}
```

### Service d'Import

```typescript
// src/services/import/import.service.ts
export interface ImportConfig {
  source: 'csv' | 'json' | 'external_api';
  mapping: FieldMapping;
  options: ImportOptions;
  validation: ValidationRules;
}

export interface FieldMapping {
  [sourceField: string]: {
    targetField: string;
    transform?: (value: any) => any;
    required: boolean;
  };
}

export class ImportService {
  constructor(
    private prisma: PrismaClient,
    private validationService: DataValidationService
  ) {}

  async importData(userId: string, filePath: string, config: ImportConfig): Promise<ImportResult> {
    const importJob = await this.createImportJob(userId, config);
    
    try {
      // Lecture et parsing du fichier
      const rawData = await this.readImportFile(filePath, config.source);
      
      // Mapping des champs
      const mappedData = this.mapFields(rawData, config.mapping);
      
      // Validation des donn√©es
      const validationResult = await this.validateImportData(mappedData, config.validation);
      
      if (validationResult.hasErrors) {
        throw new ImportError('Validation failed', validationResult.errors);
      }
      
      // Import en base avec transaction
      const result = await this.performImport(userId, validationResult.cleanData);
      
      await this.finalizeImport(importJob.id, result);
      
      return result;
    } catch (error) {
      await this.markImportFailed(importJob.id, error.message);
      throw error;
    }
  }

  private async performImport(userId: string, data: CleanImportData): Promise<ImportResult> {
    const result: ImportResult = {
      created: { gardens: 0, cultures: 0, harvests: 0, interventions: 0 },
      updated: { gardens: 0, cultures: 0, harvests: 0, interventions: 0 },
      skipped: { gardens: 0, cultures: 0, harvests: 0, interventions: 0 },
      errors: []
    };

    await this.prisma.$transaction(async (tx) => {
      // Import des jardins
      if (data.gardens) {
        for (const gardenData of data.gardens) {
          try {
            const existing = await tx.jardin.findFirst({
              where: {
                userId,
                nom: gardenData.nom
              }
            });

            if (existing) {
              await tx.jardin.update({
                where: { id: existing.id },
                data: gardenData
              });
              result.updated.gardens++;
            } else {
              await tx.jardin.create({
                data: { ...gardenData, userId }
              });
              result.created.gardens++;
            }
          } catch (error) {
            result.errors.push(`Garden import error: ${error.message}`);
            result.skipped.gardens++;
          }
        }
      }

      // Import des cultures
      if (data.cultures) {
        for (const cultureData of data.cultures) {
          try {
            const existing = await tx.varieteCulture.findFirst({
              where: {
                nom: cultureData.nom,
                createdBy: userId
              }
            });

            if (!existing) {
              await tx.varieteCulture.create({
                data: { ...cultureData, createdBy: userId }
              });
              result.created.cultures++;
            } else {
              result.skipped.cultures++;
            }
          } catch (error) {
            result.errors.push(`Culture import error: ${error.message}`);
            result.skipped.cultures++;
          }
        }
      }

      // Import des r√©coltes avec gestion des d√©pendances
      if (data.harvests) {
        for (const harvestData of data.harvests) {
          try {
            // Recherche de l'instance de culture correspondante
            const instanceCulture = await this.findMatchingCultureInstance(
              tx, 
              userId, 
              harvestData
            );

            if (instanceCulture) {
              await tx.recolte.create({
                data: {
                  ...harvestData,
                  instanceCultureId: instanceCulture.id
                }
              });
              result.created.harvests++;
            } else {
              result.skipped.harvests++;
              result.errors.push(`No matching culture instance for harvest`);
            }
          } catch (error) {
            result.errors.push(`Harvest import error: ${error.message}`);
            result.skipped.harvests++;
          }
        }
      }
    });

    return result;
  }

  async importFromCSV(userId: string, csvContent: string, mapping: FieldMapping): Promise<ImportResult> {
    const Papa = require('papaparse');
    
    const parseResult = Papa.parse(csvContent, {
      header: true,
      skipEmptyLines: true,
      transform: (value: string) => value.trim()
    });

    if (parseResult.errors.length > 0) {
      throw new ImportError('CSV parsing failed', parseResult.errors);
    }

    return this.importData(userId, parseResult.data, {
      source: 'csv',
      mapping,
      options: { batchSize: 100 },
      validation: { strict: false }
    });
  }

  async importFromGoogleSheets(userId: string, spreadsheetId: string, range: string): Promise<ImportResult> {
    // Int√©gration Google Sheets API
    const sheets = google.sheets({ version: 'v4', auth: this.googleAuth });
    
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range
    });

    const rows = response.data.values;
    if (!rows || rows.length === 0) {
      throw new ImportError('No data found in spreadsheet');
    }

    // Conversion en format standard
    const headers = rows[0];
    const data = rows.slice(1).map(row => {
      const obj: any = {};
      headers.forEach((header, index) => {
        obj[header] = row[index] || '';
      });
      return obj;
    });

    // Auto-d√©tection du mapping
    const suggestedMapping = this.suggestFieldMapping(headers);

    return this.importData(userId, data, {
      source: 'json',
      mapping: suggestedMapping,
      options: { autoDetectFormat: true },
      validation: { strict: false }
    });
  }

  private suggestFieldMapping(headers: string[]): FieldMapping {
    const mapping: FieldMapping = {};
    
    const commonMappings = {
      'name': 'nom',
      'variety': 'varieteCulture.nom',
      'plant_date': 'datePlantation',
      'harvest_date': 'dateRecolte',
      'quantity': 'quantite',
      'weight': 'poids',
      'notes': 'notes'
    };

    headers.forEach(header => {
      const normalized = header.toLowerCase().replace(/[^a-z0-9]/g, '_');
      if (commonMappings[normalized]) {
        mapping[header] = {
          targetField: commonMappings[normalized],
          required: false
        };
      }
    });

    return mapping;
  }
}
```

### Interface Export/Import

```typescript
// src/app/settings/data/page.tsx
export default function DataManagementPage() {
  const [activeTab, setActiveTab] = useState<'export' | 'import' | 'sync'>('export');

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-2xl font-bold mb-6">Gestion des Donn√©es</h1>
        
        <div className="bg-white rounded-lg shadow">
          <div className="border-b">
            <div className="flex space-x-1">
              {[
                { id: 'export', label: 'Export', icon: 'üì§' },
                { id: 'import', label: 'Import', icon: 'üì•' },
                { id: 'sync', label: 'Synchronisation', icon: 'üîÑ' }
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id as any)}
                  className={`px-6 py-3 border-b-2 font-medium text-sm ${
                    activeTab === tab.id
                      ? 'border-green-500 text-green-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700'
                  }`}
                >
                  {tab.icon} {tab.label}
                </button>
              ))}
            </div>
          </div>

          <div className="p-6">
            {activeTab === 'export' && <ExportPanel />}
            {activeTab === 'import' && <ImportPanel />}
            {activeTab === 'sync' && <SyncPanel />}
          </div>
        </div>
      </div>
    </div>
  );
}

const ExportPanel = () => {
  const [exportConfig, setExportConfig] = useState<ExportConfig>({
    format: 'json',
    scope: {
      gardens: true,
      cultures: true,
      harvests: true,
      interventions: true,
      sensors: false,
      weather: false,
      analytics: false,
      community: false
    },
    includeImages: true,
    includePrivateData: true,
    compression: true
  });

  const handleExport = async () => {
    try {
      const result = await exportService.exportUserData(exportConfig);
      // T√©l√©chargement automatique
      window.open(result.downloadUrl);
    } catch (error) {
      console.error('Export failed:', error);
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-4">Exporter vos Donn√©es</h3>
        <p className="text-gray-600 mb-6">
          Sauvegardez toutes vos donn√©es de jardinage dans le format de votre choix.
        </p>
      </div>

      {/* Format selection */}
      <div>
        <label className="block text-sm font-medium mb-2">Format d'export</label>
        <Select value={exportConfig.format} onValueChange={(value) => 
          setExportConfig(prev => ({ ...prev, format: value as any }))
        }>
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="json">JSON (complet)</SelectItem>
            <SelectItem value="csv">CSV (tableur)</SelectItem>
            <SelectItem value="pdf">PDF (rapport)</SelectItem>
            <SelectItem value="excel">Excel</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Data scope */}
      <div>
        <label className="block text-sm font-medium mb-3">Donn√©es √† inclure</label>
        <div className="grid grid-cols-2 gap-3">
          {Object.entries(exportConfig.scope).map(([key, value]) => (
            <div key={key} className="flex items-center space-x-2">
              <Checkbox
                checked={value}
                onCheckedChange={(checked) =>
                  setExportConfig(prev => ({
                    ...prev,
                    scope: { ...prev.scope, [key]: checked }
                  }))
                }
              />
              <label className="text-sm capitalize">{key.replace(/([A-Z])/g, ' $1')}</label>
            </div>
          ))}
        </div>
      </div>

      {/* Options */}
      <div>
        <label className="block text-sm font-medium mb-3">Options</label>
        <div className="space-y-2">
          <div className="flex items-center space-x-2">
            <Checkbox
              checked={exportConfig.includeImages}
              onCheckedChange={(checked) =>
                setExportConfig(prev => ({ ...prev, includeImages: checked }))
              }
            />
            <label className="text-sm">Inclure les images</label>
          </div>
          <div className="flex items-center space-x-2">
            <Checkbox
              checked={exportConfig.compression}
              onCheckedChange={(checked) =>
                setExportConfig(prev => ({ ...prev, compression: checked }))
              }
            />
            <label className="text-sm">Compresser l'archive</label>
          </div>
        </div>
      </div>

      <Button onClick={handleExport} className="w-full">
        <DownloadIcon className="w-4 h-4 mr-2" />
        G√©n√©rer l'Export
      </Button>
    </div>
  );
};

const ImportPanel = () => {
  const [dragActive, setDragActive] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(false);
    
    const files = e.dataTransfer.files;
    if (files && files[0]) {
      setSelectedFile(files[0]);
    }
  };

  const handleImport = async () => {
    if (!selectedFile) return;

    try {
      const formData = new FormData();
      formData.append('file', selectedFile);
      
      const result = await importService.importFile(formData);
      console.log('Import successful:', result);
    } catch (error) {
      console.error('Import failed:', error);
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-4">Importer des Donn√©es</h3>
        <p className="text-gray-600 mb-6">
          Importez vos donn√©es depuis d'autres applications ou fichiers CSV/JSON.
        </p>
      </div>

      {/* File drop zone */}
      <div
        className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
          dragActive ? 'border-green-500 bg-green-50' : 'border-gray-300'
        }`}
        onDragEnter={(e) => { e.preventDefault(); setDragActive(true); }}
        onDragLeave={(e) => { e.preventDefault(); setDragActive(false); }}
        onDragOver={(e) => e.preventDefault()}
        onDrop={handleDrop}
      >
        {selectedFile ? (
          <div>
            <FileIcon className="w-12 h-12 mx-auto text-green-500 mb-2" />
            <p className="font-medium">{selectedFile.name}</p>
            <p className="text-sm text-gray-500">{(selectedFile.size / 1024).toFixed(1)} KB</p>
          </div>
        ) : (
          <div>
            <UploadIcon className="w-12 h-12 mx-auto text-gray-400 mb-4" />
            <p className="text-lg font-medium">Glissez votre fichier ici</p>
            <p className="text-gray-500">ou cliquez pour s√©lectionner</p>
            <p className="text-xs text-gray-400 mt-2">
              Formats support√©s: CSV, JSON, Excel
            </p>
          </div>
        )}
      </div>

      {selectedFile && (
        <Button onClick={handleImport} className="w-full">
          <UploadIcon className="w-4 h-4 mr-2" />
          Lancer l'Import
        </Button>
      )}

      {/* Quick imports */}
      <div>
        <h4 className="font-medium mb-3">Imports Rapides</h4>
        <div className="grid grid-cols-2 gap-3">
          <Button variant="outline">
            üìä Google Sheets
          </Button>
          <Button variant="outline">
            üå± GrowVeg
          </Button>
        </div>
      </div>
    </div>
  );
};
```

## Crit√®res d'Acceptation Techniques

### Export
- [ ] Support JSON, CSV, PDF, Excel
- [ ] Export s√©lectif par type de donn√©es
- [ ] Compression automatique des archives
- [ ] Planification d'exports automatiques
- [ ] Conformit√© RGPD portabilit√©

### Import
- [ ] Auto-d√©tection format et encoding
- [ ] Mapping flexible des champs
- [ ] Validation et nettoyage donn√©es
- [ ] Gestion des conflits et doublons
- [ ] Import par batch pour gros volumes

### Synchronisation
- [ ] API REST pour int√©grations tierces
- [ ] Webhooks bidirectionnels
- [ ] Sync Google Sheets temps r√©el
- [ ] Format standard √©change de donn√©es
- [ ] Monitoring des synchronisations

## Couverture Exigences Architecture

- **EXG-002.1** : Export optimis√© depuis PostgreSQL
- **EXG-008.2** : Conformit√© RGPD portabilit√©
- **EXG-010.1** : API REST pour int√©grations
- **EXG-009.1** : Monitoring des exports/imports

## Tests d'Acceptation

```typescript
// tests/integration/export-import.test.ts
describe('Export/Import System', () => {
  test('export complet utilisateur fonctionne', async () => {
    const config = createFullExportConfig();
    const result = await exportService.exportUserData('user-1', config);
    
    expect(result.filePath).toBeDefined();
    expect(result.downloadUrl).toBeDefined();
    expect(result.fileSize).toBeGreaterThan(0);
  });

  test('import CSV avec mapping automatique', async () => {
    const csvContent = createTestCSVContent();
    const result = await importService.importFromCSV('user-2', csvContent, {});
    
    expect(result.created.harvests).toBeGreaterThan(0);
    expect(result.errors).toHaveLength(0);
  });

  test('synchronisation Google Sheets bidirectionnelle', async () => {
    const spreadsheetId = 'test-sheet-id';
    await importService.importFromGoogleSheets('user-1', spreadsheetId, 'A1:Z100');
    
    const exported = await exportService.exportToGoogleSheets('user-1', spreadsheetId);
    expect(exported.success).toBe(true);
  });
});
```

Cette sp√©cification couvre un syst√®me complet d'export/import avec support multi-formats et int√©grations tierces pour assurer la portabilit√© des donn√©es.