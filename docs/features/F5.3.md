# F5.3 - IA Conversationnelle & MCP Server

**Score Priorit√© :** 50/100  
**Statut :** PRIORIT√â FAIBLE  
**Epic :** EPIC 5 - IA AVANC√âE & PR√âDICTIONS  
**Effort estim√© :** 20 jours  

## Description

Assistant IA conversationnel pour questions jardinage contextualis√©es et serveur MCP (Model Context Protocol) permettant aux IA externes (Claude, ChatGPT, Ollama) d'acc√©der et interroger les donn√©es du jardin intelligemment.

## User Stories

### US5.3.1 - Assistant IA Jardin
**En tant qu'** utilisateur d√©butant  
**Je veux** poser des questions naturelles sur mon jardin  
**Afin d'** obtenir des conseils personnalis√©s bas√©s sur mes donn√©es r√©elles  

**Crit√®res d'acceptation :**
- Chat conversationnel avec NLP avanc√©
- Acc√®s contextuel aux donn√©es utilisateur
- R√©ponses personnalis√©es selon historique
- Support multi-modal (texte + images)
- Int√©gration donn√©es m√©t√©o et calendrier

### US5.3.2 - Diagnostic Automatique Photos
**En tant qu'** jardinier  
**Je veux** diagnostiquer mes probl√®mes de plantes avec une photo  
**Afin de** recevoir un diagnostic et des conseils de traitement  

**Crit√®res d'acceptation :**
- Upload photo avec g√©olocalisation
- Reconnaissance automatique probl√®mes/maladies
- Diagnostic contextualis√© selon vari√©t√© et saison
- Propositions de traitement adapt√©es
- Suivi √©volution du traitement

### US5.3.3 - Serveur MCP pour IA Externes
**En tant qu'** utilisateur expert  
**Je veux** interroger mon potager via Claude/ChatGPT  
**Afin d'** utiliser mon IA pr√©f√©r√©e avec mes donn√©es  

**Crit√®res d'acceptation :**
- Serveur MCP conforme au protocole
- Authentification s√©curis√©e pour IA externes
- API standardis√©e pour requ√™tes jardinage
- Permissions granulaires par type de donn√©es
- Logs d√©taill√©s des interactions

## Architecture Technique

### Service IA Conversationnelle

```typescript
// src/services/ai/conversational-ai.service.ts
export interface ConversationContext {
  userId: string;
  gardenId?: string;
  sessionId: string;
  language: 'fr' | 'sr' | 'en';
  expertise: 'beginner' | 'intermediate' | 'expert';
  currentLocation?: { lat: number; lon: number; };
  currentSeason?: string;
  recentActivities?: Activity[];
}

export interface AIMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  attachments?: MessageAttachment[];
  context?: Record<string, any>;
  timestamp: Date;
  tokens?: { input: number; output: number; cost: number; };
}

export interface ConversationSession {
  id: string;
  userId: string;
  title: string;
  context: ConversationContext;
  messages: AIMessage[];
  status: 'active' | 'archived';
  aiProvider: 'openai' | 'anthropic' | 'ollama';
  totalTokens: number;
  totalCost: number;
  createdAt: Date;
  lastMessageAt: Date;
}

export class ConversationalAIService {
  private openaiClient: OpenAI;
  private anthropicClient: Anthropic;
  private ollamaClient: OllamaClient;
  private contextBuilder: ConversationContextBuilder;

  constructor(
    private prisma: PrismaClient,
    private weatherService: WeatherService,
    private gardenService: GardenService
  ) {
    this.openaiClient = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.anthropicClient = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
    this.ollamaClient = new OllamaClient({ baseURL: process.env.OLLAMA_URL });
    this.contextBuilder = new ConversationContextBuilder();
  }

  async createSession(userId: string, gardenId?: string): Promise<ConversationSession> {
    // Construire le contexte initial
    const context = await this.contextBuilder.buildContext({
      userId,
      gardenId,
      language: await this.getUserLanguage(userId),
      expertise: await this.getUserExpertise(userId)
    });

    const session = await this.prisma.conversationSession.create({
      data: {
        userId,
        title: 'Nouvelle conversation',
        context,
        status: 'active',
        aiProvider: 'openai', // Par d√©faut
        totalTokens: 0,
        totalCost: 0
      }
    });

    // Message de bienvenue contextualis√©
    const welcomeMessage = await this.generateWelcomeMessage(context);
    await this.addMessage(session.id, {
      role: 'assistant',
      content: welcomeMessage,
      context: { type: 'welcome' }
    });

    return this.mapToConversationSession(session);
  }

  async sendMessage(
    sessionId: string,
    message: string,
    attachments?: MessageAttachment[]
  ): Promise<AIMessage> {
    const session = await this.getSession(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    // Ajouter le message utilisateur
    const userMessage = await this.addMessage(sessionId, {
      role: 'user',
      content: message,
      attachments
    });

    // Construire le contexte enrichi
    const enrichedContext = await this.enrichContext(session, message, attachments);

    // G√©n√©rer la r√©ponse selon le provider configur√©
    const response = await this.generateResponse(session, enrichedContext);

    // Ajouter la r√©ponse de l'IA
    const assistantMessage = await this.addMessage(sessionId, {
      role: 'assistant',
      content: response.content,
      context: response.context,
      tokens: response.usage
    });

    // Mettre √† jour les m√©triques de session
    await this.updateSessionMetrics(sessionId, response.usage);

    return assistantMessage;
  }

  private async enrichContext(
    session: ConversationSession,
    message: string,
    attachments?: MessageAttachment[]
  ): Promise<EnrichedContext> {
    const context: EnrichedContext = {
      ...session.context,
      userMessage: message
    };

    // Analyse d'intention NLP
    const intent = await this.analyzeIntent(message);
    context.detectedIntent = intent;

    // Enrichissement selon l'intention
    switch (intent.type) {
      case 'plant_identification':
        if (attachments?.[0]?.type === 'image') {
          context.plantAnalysis = await this.analyzePlantImage(attachments[0]);
        }
        break;

      case 'problem_diagnosis':
        context.gardenData = await this.getRecentGardenActivity(session.context.gardenId);
        if (attachments) {
          context.problemAnalysis = await this.analyzeProblemImages(attachments);
        }
        break;

      case 'planning_advice':
        context.weatherForecast = await this.weatherService.getForecast(
          session.context.currentLocation,
          7
        );
        context.seasonalData = await this.getSeasonalRecommendations(
          session.context.currentSeason
        );
        break;

      case 'harvest_timing':
        context.cultureData = await this.getCurrentCultures(session.context.gardenId);
        context.harvestHistory = await this.getHarvestHistory(session.context.gardenId);
        break;
    }

    return context;
  }

  private async generateResponse(
    session: ConversationSession,
    context: EnrichedContext
  ): Promise<AIResponse> {
    const systemPrompt = this.buildSystemPrompt(context);
    const conversationHistory = await this.getRecentMessages(session.id, 10);

    switch (session.aiProvider) {
      case 'openai':
        return await this.generateOpenAIResponse(systemPrompt, conversationHistory, context);
      
      case 'anthropic':
        return await this.generateAnthropicResponse(systemPrompt, conversationHistory, context);
      
      case 'ollama':
        return await this.generateOllamaResponse(systemPrompt, conversationHistory, context);
      
      default:
        throw new Error(`Unsupported AI provider: ${session.aiProvider}`);
    }
  }

  private async generateOpenAIResponse(
    systemPrompt: string,
    history: AIMessage[],
    context: EnrichedContext
  ): Promise<AIResponse> {
    const messages = [
      { role: 'system', content: systemPrompt },
      ...history.map(msg => ({
        role: msg.role,
        content: msg.content
      }))
    ];

    const completion = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: messages as any,
      temperature: 0.7,
      max_tokens: 1000,
      tools: [
        {
          type: 'function',
          function: {
            name: 'get_garden_data',
            description: 'R√©cup√®re les donn√©es du jardin de l\'utilisateur',
            parameters: {
              type: 'object',
              properties: {
                dataType: {
                  type: 'string',
                  enum: ['cultures', 'harvests', 'interventions', 'weather']
                },
                timeframe: { type: 'string' }
              }
            }
          }
        },
        {
          type: 'function',
          function: {
            name: 'analyze_plant_image',
            description: 'Analyse une image de plante pour diagnostic',
            parameters: {
              type: 'object',
              properties: {
                imageUrl: { type: 'string' },
                analysisType: {
                  type: 'string',
                  enum: ['disease', 'growth_stage', 'species_identification']
                }
              }
            }
          }
        }
      ]
    });

    const message = completion.choices[0].message;
    let finalContent = message.content || '';

    // Traitement des appels de fonctions
    if (message.tool_calls) {
      for (const toolCall of message.tool_calls) {
        const functionResult = await this.executeFunction(
          toolCall.function.name,
          JSON.parse(toolCall.function.arguments),
          context
        );
        
        finalContent += `\n\n${functionResult}`;
      }
    }

    return {
      content: finalContent,
      context: {
        model: 'gpt-4-turbo-preview',
        toolsUsed: message.tool_calls?.map(tc => tc.function.name) || []
      },
      usage: {
        input: completion.usage?.prompt_tokens || 0,
        output: completion.usage?.completion_tokens || 0,
        cost: this.calculateOpenAICost(completion.usage)
      }
    };
  }

  private buildSystemPrompt(context: EnrichedContext): string {
    const { expertise, currentSeason, language } = context;
    
    let prompt = `Tu es un assistant jardinage expert sp√©cialis√© dans les potagers intelligents.

CONTEXTE UTILISATEUR:
- Niveau: ${expertise}
- Saison: ${currentSeason}
- Langue: ${language}`;

    if (context.gardenData) {
      prompt += `
- Cultures actuelles: ${context.gardenData.activeCultures.map(c => c.name).join(', ')}
- Derni√®res r√©coltes: ${context.gardenData.recentHarvests.map(h => `${h.quantity}${h.unit} de ${h.variety}`).join(', ')}`;
    }

    if (context.weatherForecast) {
      prompt += `
- M√©t√©o prochains jours: ${context.weatherForecast.summary}`;
    }

    prompt += `

INSTRUCTIONS:
1. R√©ponds de mani√®re personnalis√©e selon les donn√©es r√©elles du jardin
2. Adapte ton niveau de d√©tail selon l'expertise utilisateur
3. Inclus des conseils pratiques et temporellement pertinents
4. Si tu analyses une image, d√©cris pr√©cis√©ment ce que tu vois
5. Propose toujours des actions concr√®tes
6. Utilise un ton bienveillant et encourageant

CAPACIT√âS SP√âCIALES:
- Acc√®s aux donn√©es jardinage en temps r√©el
- Analyse d'images pour diagnostic
- Corr√©lation avec m√©t√©o et saisons
- Historique des interventions et r√©sultats`;

    return prompt;
  }

  private async executeFunction(
    functionName: string,
    args: any,
    context: EnrichedContext
  ): Promise<string> {
    switch (functionName) {
      case 'get_garden_data':
        return await this.getGardenDataFunction(args.dataType, args.timeframe, context);
      
      case 'analyze_plant_image':
        return await this.analyzePlantImageFunction(args.imageUrl, args.analysisType);
      
      default:
        return `Fonction ${functionName} non impl√©ment√©e`;
    }
  }

  async diagnoseFromPhoto(
    userId: string,
    imageData: Buffer,
    metadata: ImageMetadata
  ): Promise<PlantDiagnosis> {
    // Upload vers stockage avec m√©tadonn√©es
    const imageUrl = await this.uploadDiagnosisImage(imageData, metadata);

    // Analyse avec GPT-4 Vision
    const visionAnalysis = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-vision-preview',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: `Analyse cette photo de plante et identifie:
1. L'esp√®ce/vari√©t√© si possible
2. Les probl√®mes visibles (maladies, parasites, carences)
3. Le stade de croissance
4. L'√©tat g√©n√©ral de sant√©
5. Tes recommandations de traitement

Contexte: ${metadata.season}, r√©gion ${metadata.region}, photo prise le ${metadata.timestamp}`
            },
            {
              type: 'image_url',
              image_url: { url: imageUrl }
            }
          ]
        }
      ],
      max_tokens: 1000
    });

    const analysisText = visionAnalysis.choices[0].message.content || '';

    // Parsing structur√© de l'analyse
    const diagnosis = await this.parseVisionAnalysis(analysisText, metadata);

    // Sauvegarde du diagnostic
    await this.savePlantDiagnosis({
      userId,
      imageUrl,
      analysis: analysisText,
      diagnosis,
      metadata
    });

    return diagnosis;
  }

  // Fonctions d'analyse d'images
  private async analyzePlantImage(attachment: MessageAttachment): Promise<PlantAnalysis> {
    const completion = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-vision-preview',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: 'Analyse cette image de plante et identifie l\'esp√®ce, les probl√®mes visibles, et le stade de croissance.'
            },
            {
              type: 'image_url',
              image_url: { url: attachment.url }
            }
          ]
        }
      ]
    });

    return this.parseImageAnalysis(completion.choices[0].message.content || '');
  }
}
```

### Serveur MCP (Model Context Protocol)

```typescript
// src/services/mcp/mcp-server.service.ts
export interface MCPTool {
  name: string;
  description: string;
  inputSchema: object;
}

export interface MCPResource {
  uri: string;
  name: string;
  description?: string;
  mimeType?: string;
}

export class MCPServerService {
  private tools: MCPTool[] = [];
  private resources: MCPResource[] = [];

  constructor(
    private prisma: PrismaClient,
    private gardenService: GardenService,
    private weatherService: WeatherService
  ) {
    this.initializeTools();
    this.initializeResources();
  }

  private initializeTools(): void {
    this.tools = [
      {
        name: 'get_garden_overview',
        description: 'R√©cup√®re un aper√ßu complet du jardin avec cultures actuelles, m√©t√©o et alertes',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string', description: 'ID du jardin' }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'get_current_cultures',
        description: 'Liste les cultures actuellement plant√©es',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            status: {
              type: 'string',
              enum: ['active', 'harvested', 'all'],
              description: 'Filtrer par statut'
            }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'get_harvest_history',
        description: 'Historique des r√©coltes avec quantit√©s et dates',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            timeframe: {
              type: 'string',
              enum: ['week', 'month', 'season', 'year'],
              description: 'P√©riode √† analyser'
            },
            culture_type: { type: 'string', description: 'Filtrer par type de culture' }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'get_weather_impact',
        description: 'Analyse l\'impact m√©t√©o sur les cultures',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            forecast_days: { type: 'number', minimum: 1, maximum: 14 }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'suggest_interventions',
        description: 'Sugg√®re des interventions bas√©es sur l\'√©tat du jardin',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            urgency_filter: {
              type: 'string',
              enum: ['urgent', 'soon', 'planned', 'all']
            }
          },
          required: ['garden_id']
        }
      }
    ];
  }

  private initializeResources(): void {
    this.resources = [
      {
        uri: 'basmalin://gardens/{garden_id}',
        name: 'Garden Data',
        description: 'Donn√©es compl√®tes d\'un jardin sp√©cifique',
        mimeType: 'application/json'
      },
      {
        uri: 'basmalin://cultures/{culture_id}',
        name: 'Culture Details',
        description: 'D√©tails d\'une culture sp√©cifique',
        mimeType: 'application/json'
      },
      {
        uri: 'basmalin://weather/{garden_id}',
        name: 'Weather Data',
        description: 'Donn√©es m√©t√©o pour un jardin',
        mimeType: 'application/json'
      }
    ];
  }

  // Impl√©mentation du protocole MCP
  async handleMCPRequest(request: MCPRequest): Promise<MCPResponse> {
    try {
      switch (request.method) {
        case 'tools/list':
          return { result: { tools: this.tools } };

        case 'tools/call':
          return await this.handleToolCall(request.params);

        case 'resources/list':
          return { result: { resources: this.resources } };

        case 'resources/read':
          return await this.handleResourceRead(request.params);

        default:
          throw new Error(`Unknown method: ${request.method}`);
      }
    } catch (error) {
      return {
        error: {
          code: -1,
          message: error.message
        }
      };
    }
  }

  private async handleToolCall(params: any): Promise<MCPResponse> {
    const { name, arguments: args } = params;

    // Authentification et autorisation
    const userId = await this.validateMCPAccess(params.sessionId);
    
    switch (name) {
      case 'get_garden_overview':
        const overview = await this.getGardenOverview(userId, args.garden_id);
        return { result: { content: [{ type: 'text', text: JSON.stringify(overview, null, 2) }] } };

      case 'get_current_cultures':
        const cultures = await this.getCurrentCultures(userId, args.garden_id, args.status);
        return { result: { content: [{ type: 'text', text: JSON.stringify(cultures, null, 2) }] } };

      case 'get_harvest_history':
        const harvests = await this.getHarvestHistory(userId, args.garden_id, args.timeframe, args.culture_type);
        return { result: { content: [{ type: 'text', text: JSON.stringify(harvests, null, 2) }] } };

      case 'get_weather_impact':
        const weather = await this.getWeatherImpact(userId, args.garden_id, args.forecast_days);
        return { result: { content: [{ type: 'text', text: JSON.stringify(weather, null, 2) }] } };

      case 'suggest_interventions':
        const interventions = await this.suggestInterventions(userId, args.garden_id, args.urgency_filter);
        return { result: { content: [{ type: 'text', text: JSON.stringify(interventions, null, 2) }] } };

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  }

  private async getGardenOverview(userId: string, gardenId: string): Promise<any> {
    const garden = await this.prisma.jardin.findFirst({
      where: { id: gardenId, userId },
      include: {
        zones: {
          include: {
            instancesCultures: {
              where: { statut: 'active' },
              include: {
                varieteCulture: true,
                interventions: {
                  take: 3,
                  orderBy: { dateIntervention: 'desc' }
                },
                recoltes: {
                  take: 5,
                  orderBy: { dateRecolte: 'desc' }
                }
              }
            }
          }
        }
      }
    });

    if (!garden) {
      throw new Error('Garden not found or unauthorized');
    }

    // R√©cup√©ration m√©t√©o
    const weather = await this.weatherService.getCurrentWeather({
      lat: garden.latitude,
      lon: garden.longitude
    });

    // Calcul des m√©triques
    const activeCultures = garden.zones.flatMap(z => z.instancesCultures);
    const totalHarvests = activeCultures.reduce((sum, c) => sum + c.recoltes.length, 0);
    const recentInterventions = activeCultures.flatMap(c => c.interventions);

    return {
      garden: {
        id: garden.id,
        name: garden.nom,
        description: garden.description,
        location: {
          latitude: garden.latitude,
          longitude: garden.longitude,
          address: garden.adresse
        },
        area: garden.surface
      },
      weather: {
        current: weather.current,
        today: weather.forecast[0],
        alerts: weather.alerts
      },
      stats: {
        totalZones: garden.zones.length,
        activeCultures: activeCultures.length,
        totalHarvests,
        recentInterventions: recentInterventions.length
      },
      activeCultures: activeCultures.map(culture => ({
        id: culture.id,
        variety: culture.varieteCulture.nom,
        zone: culture.zone.nom,
        plantedAt: culture.datePlantation,
        status: culture.statut,
        lastIntervention: culture.interventions[0]?.dateIntervention,
        harvestCount: culture.recoltes.length
      })),
      alerts: await this.getActiveAlerts(gardenId)
    };
  }
}
```

### Interface Chat

```typescript
// src/app/ai-chat/page.tsx
export default function AIChatPage() {
  const [session, setSession] = useState<ConversationSession | null>(null);
  const [messages, setMessages] = useState<AIMessage[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      <div className="bg-white border-b p-4">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-xl font-semibold">ü§ñ Assistant Jardin IA</h1>
            <p className="text-sm text-gray-600">
              Posez vos questions sur votre potager
            </p>
          </div>
          
          <div className="flex items-center space-x-2">
            <Button variant="outline" size="sm">
              <CameraIcon className="w-4 h-4 mr-2" />
              Analyser Photo
            </Button>
            <Button variant="outline" size="sm">
              <SettingsIcon className="w-4 h-4" />
            </Button>
          </div>
        </div>
      </div>

      <div className="flex-1 flex">
        {/* Messages */}
        <div className="flex-1 flex flex-col">
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.map(message => (
              <ChatMessage key={message.id} message={message} />
            ))}
            {isLoading && <TypingIndicator />}
          </div>

          {/* Input */}
          <div className="border-t bg-white p-4">
            <ChatInput
              value={inputMessage}
              onChange={setInputMessage}
              onSend={handleSendMessage}
              disabled={isLoading}
            />
          </div>
        </div>

        {/* Sidebar contexte */}
        <div className="w-80 border-l bg-white p-4">
          <ChatContextPanel session={session} />
        </div>
      </div>
    </div>
  );
}

const ChatMessage = ({ message }: { message: AIMessage }) => {
  return (
    <div className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}>
      <div className={`max-w-3xl rounded-lg p-3 ${
        message.role === 'user' 
          ? 'bg-green-500 text-white' 
          : 'bg-white border shadow-sm'
      }`}>
        {message.attachments?.map(attachment => (
          <MessageAttachment key={attachment.id} attachment={attachment} />
        ))}
        
        <div className="prose prose-sm max-w-none">
          <ReactMarkdown>{message.content}</ReactMarkdown>
        </div>
        
        <div className="text-xs opacity-70 mt-2">
          {formatDistanceToNow(message.timestamp)}
        </div>
      </div>
    </div>
  );
};
```

## Crit√®res d'Acceptation Techniques

### IA Conversationnelle
- [ ] Chat NLP avec GPT-4/Claude/Ollama
- [ ] Contexte personnalis√© selon donn√©es jardin
- [ ] Support multi-modal (texte + images)
- [ ] Analyse d'intention et r√©ponses adapt√©es
- [ ] Sessions persistantes avec historique

### Diagnostic Photo
- [ ] Upload photos avec m√©tadonn√©es GPS
- [ ] Reconnaissance maladies/probl√®mes (>80% pr√©cision)
- [ ] Diagnostic contextualis√© vari√©t√©/saison
- [ ] Recommandations traitement personnalis√©es
- [ ] Suivi √©volution probl√®mes

### Serveur MCP
- [ ] Protocole MCP conforme sp√©cification
- [ ] API standardis√©e pour IA externes
- [ ] Authentification OAuth2 s√©curis√©e
- [ ] Permissions granulaires par scope
- [ ] Logs d√©taill√©s et monitoring

## Couverture Exigences Architecture

- **EXG-005.1** : IA conversationnelle avanc√©e
- **EXG-005.2** : Int√©gration multi-providers IA
- **EXG-002.1** : Stockage conversations et contexte
- **EXG-010.1** : Serveur MCP pour int√©grations
- **EXG-009.1** : Monitoring co√ªts et usage IA

## Tests d'Acceptation

```typescript
// tests/integration/conversational-ai.test.ts
describe('Conversational AI', () => {
  test('cr√©ation session avec contexte jardin', async () => {
    const session = await aiService.createSession('user-1', 'garden-1');
    
    expect(session.context.gardenId).toBe('garden-1');
    expect(session.context.expertise).toBeDefined();
    expect(session.messages).toHaveLength(1); // Welcome message
  });

  test('diagnostic photo maladie', async () => {
    const imageBuffer = await fs.readFile('test-plant-disease.jpg');
    const diagnosis = await aiService.diagnoseFromPhoto('user-1', imageBuffer, {
      season: 'summer',
      region: 'temperate'
    });
    
    expect(diagnosis.problems).toHaveLength(greaterThan(0));
    expect(diagnosis.recommendations).toHaveLength(greaterThan(0));
    expect(diagnosis.confidence).toBeGreaterThan(0.7);
  });

  test('serveur MCP r√©pond aux requ√™tes', async () => {
    const response = await mcpServer.handleMCPRequest({
      method: 'tools/call',
      params: {
        name: 'get_garden_overview',
        arguments: { garden_id: 'garden-1' },
        sessionId: 'valid-session'
      }
    });
    
    expect(response.result).toBeDefined();
    expect(response.error).toBeUndefined();
  });
});
```

Cette sp√©cification couvre un assistant IA complet avec diagnostic photo et serveur MCP pour int√©grations externes.