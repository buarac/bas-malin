# F5.3 - IA Conversationnelle & MCP Server

**Score Priorité :** 50/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 5 - IA AVANCÉE & PRÉDICTIONS  
**Effort estimé :** 20 jours  

## Description

Assistant IA conversationnel pour questions jardinage contextualisées et serveur MCP (Model Context Protocol) permettant aux IA externes (Claude, ChatGPT, Ollama) d'accéder et interroger les données du jardin intelligemment.

## User Stories

### US5.3.1 - Assistant IA Jardin
**En tant qu'** utilisateur débutant  
**Je veux** poser des questions naturelles sur mon jardin  
**Afin d'** obtenir des conseils personnalisés basés sur mes données réelles  

**Critères d'acceptation :**
- Chat conversationnel avec NLP avancé
- Accès contextuel aux données utilisateur
- Réponses personnalisées selon historique
- Support multi-modal (texte + images)
- Intégration données météo et calendrier

### US5.3.2 - Diagnostic Automatique Photos
**En tant qu'** jardinier  
**Je veux** diagnostiquer mes problèmes de plantes avec une photo  
**Afin de** recevoir un diagnostic et des conseils de traitement  

**Critères d'acceptation :**
- Upload photo avec géolocalisation
- Reconnaissance automatique problèmes/maladies
- Diagnostic contextualisé selon variété et saison
- Propositions de traitement adaptées
- Suivi évolution du traitement

### US5.3.3 - Serveur MCP pour IA Externes
**En tant qu'** utilisateur expert  
**Je veux** interroger mon potager via Claude/ChatGPT  
**Afin d'** utiliser mon IA préférée avec mes données  

**Critères d'acceptation :**
- Serveur MCP conforme au protocole
- Authentification sécurisée pour IA externes
- API standardisée pour requêtes jardinage
- Permissions granulaires par type de données
- Logs détaillés des interactions

## Architecture Technique

### Service IA Conversationnelle

```typescript
// src/services/ai/conversational-ai.service.ts
export interface ConversationContext {
  userId: string;
  gardenId?: string;
  sessionId: string;
  language: 'fr' | 'sr' | 'en';
  expertise: 'beginner' | 'intermediate' | 'expert';
  currentLocation?: { lat: number; lon: number; };
  currentSeason?: string;
  recentActivities?: Activity[];
}

export interface AIMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  attachments?: MessageAttachment[];
  context?: Record<string, any>;
  timestamp: Date;
  tokens?: { input: number; output: number; cost: number; };
}

export interface ConversationSession {
  id: string;
  userId: string;
  title: string;
  context: ConversationContext;
  messages: AIMessage[];
  status: 'active' | 'archived';
  aiProvider: 'openai' | 'anthropic' | 'ollama';
  totalTokens: number;
  totalCost: number;
  createdAt: Date;
  lastMessageAt: Date;
}

export class ConversationalAIService {
  private openaiClient: OpenAI;
  private anthropicClient: Anthropic;
  private ollamaClient: OllamaClient;
  private contextBuilder: ConversationContextBuilder;

  constructor(
    private prisma: PrismaClient,
    private weatherService: WeatherService,
    private gardenService: GardenService
  ) {
    this.openaiClient = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.anthropicClient = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
    this.ollamaClient = new OllamaClient({ baseURL: process.env.OLLAMA_URL });
    this.contextBuilder = new ConversationContextBuilder();
  }

  async createSession(userId: string, gardenId?: string): Promise<ConversationSession> {
    // Construire le contexte initial
    const context = await this.contextBuilder.buildContext({
      userId,
      gardenId,
      language: await this.getUserLanguage(userId),
      expertise: await this.getUserExpertise(userId)
    });

    const session = await this.prisma.conversationSession.create({
      data: {
        userId,
        title: 'Nouvelle conversation',
        context,
        status: 'active',
        aiProvider: 'openai', // Par défaut
        totalTokens: 0,
        totalCost: 0
      }
    });

    // Message de bienvenue contextualisé
    const welcomeMessage = await this.generateWelcomeMessage(context);
    await this.addMessage(session.id, {
      role: 'assistant',
      content: welcomeMessage,
      context: { type: 'welcome' }
    });

    return this.mapToConversationSession(session);
  }

  async sendMessage(
    sessionId: string,
    message: string,
    attachments?: MessageAttachment[]
  ): Promise<AIMessage> {
    const session = await this.getSession(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    // Ajouter le message utilisateur
    const userMessage = await this.addMessage(sessionId, {
      role: 'user',
      content: message,
      attachments
    });

    // Construire le contexte enrichi
    const enrichedContext = await this.enrichContext(session, message, attachments);

    // Générer la réponse selon le provider configuré
    const response = await this.generateResponse(session, enrichedContext);

    // Ajouter la réponse de l'IA
    const assistantMessage = await this.addMessage(sessionId, {
      role: 'assistant',
      content: response.content,
      context: response.context,
      tokens: response.usage
    });

    // Mettre à jour les métriques de session
    await this.updateSessionMetrics(sessionId, response.usage);

    return assistantMessage;
  }

  private async enrichContext(
    session: ConversationSession,
    message: string,
    attachments?: MessageAttachment[]
  ): Promise<EnrichedContext> {
    const context: EnrichedContext = {
      ...session.context,
      userMessage: message
    };

    // Analyse d'intention NLP
    const intent = await this.analyzeIntent(message);
    context.detectedIntent = intent;

    // Enrichissement selon l'intention
    switch (intent.type) {
      case 'plant_identification':
        if (attachments?.[0]?.type === 'image') {
          context.plantAnalysis = await this.analyzePlantImage(attachments[0]);
        }
        break;

      case 'problem_diagnosis':
        context.gardenData = await this.getRecentGardenActivity(session.context.gardenId);
        if (attachments) {
          context.problemAnalysis = await this.analyzeProblemImages(attachments);
        }
        break;

      case 'planning_advice':
        context.weatherForecast = await this.weatherService.getForecast(
          session.context.currentLocation,
          7
        );
        context.seasonalData = await this.getSeasonalRecommendations(
          session.context.currentSeason
        );
        break;

      case 'harvest_timing':
        context.cultureData = await this.getCurrentCultures(session.context.gardenId);
        context.harvestHistory = await this.getHarvestHistory(session.context.gardenId);
        break;
    }

    return context;
  }

  private async generateResponse(
    session: ConversationSession,
    context: EnrichedContext
  ): Promise<AIResponse> {
    const systemPrompt = this.buildSystemPrompt(context);
    const conversationHistory = await this.getRecentMessages(session.id, 10);

    switch (session.aiProvider) {
      case 'openai':
        return await this.generateOpenAIResponse(systemPrompt, conversationHistory, context);
      
      case 'anthropic':
        return await this.generateAnthropicResponse(systemPrompt, conversationHistory, context);
      
      case 'ollama':
        return await this.generateOllamaResponse(systemPrompt, conversationHistory, context);
      
      default:
        throw new Error(`Unsupported AI provider: ${session.aiProvider}`);
    }
  }

  private async generateOpenAIResponse(
    systemPrompt: string,
    history: AIMessage[],
    context: EnrichedContext
  ): Promise<AIResponse> {
    const messages = [
      { role: 'system', content: systemPrompt },
      ...history.map(msg => ({
        role: msg.role,
        content: msg.content
      }))
    ];

    const completion = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages: messages as any,
      temperature: 0.7,
      max_tokens: 1000,
      tools: [
        {
          type: 'function',
          function: {
            name: 'get_garden_data',
            description: 'Récupère les données du jardin de l\'utilisateur',
            parameters: {
              type: 'object',
              properties: {
                dataType: {
                  type: 'string',
                  enum: ['cultures', 'harvests', 'interventions', 'weather']
                },
                timeframe: { type: 'string' }
              }
            }
          }
        },
        {
          type: 'function',
          function: {
            name: 'analyze_plant_image',
            description: 'Analyse une image de plante pour diagnostic',
            parameters: {
              type: 'object',
              properties: {
                imageUrl: { type: 'string' },
                analysisType: {
                  type: 'string',
                  enum: ['disease', 'growth_stage', 'species_identification']
                }
              }
            }
          }
        }
      ]
    });

    const message = completion.choices[0].message;
    let finalContent = message.content || '';

    // Traitement des appels de fonctions
    if (message.tool_calls) {
      for (const toolCall of message.tool_calls) {
        const functionResult = await this.executeFunction(
          toolCall.function.name,
          JSON.parse(toolCall.function.arguments),
          context
        );
        
        finalContent += `\n\n${functionResult}`;
      }
    }

    return {
      content: finalContent,
      context: {
        model: 'gpt-4-turbo-preview',
        toolsUsed: message.tool_calls?.map(tc => tc.function.name) || []
      },
      usage: {
        input: completion.usage?.prompt_tokens || 0,
        output: completion.usage?.completion_tokens || 0,
        cost: this.calculateOpenAICost(completion.usage)
      }
    };
  }

  private buildSystemPrompt(context: EnrichedContext): string {
    const { expertise, currentSeason, language } = context;
    
    let prompt = `Tu es un assistant jardinage expert spécialisé dans les potagers intelligents.

CONTEXTE UTILISATEUR:
- Niveau: ${expertise}
- Saison: ${currentSeason}
- Langue: ${language}`;

    if (context.gardenData) {
      prompt += `
- Cultures actuelles: ${context.gardenData.activeCultures.map(c => c.name).join(', ')}
- Dernières récoltes: ${context.gardenData.recentHarvests.map(h => `${h.quantity}${h.unit} de ${h.variety}`).join(', ')}`;
    }

    if (context.weatherForecast) {
      prompt += `
- Météo prochains jours: ${context.weatherForecast.summary}`;
    }

    prompt += `

INSTRUCTIONS:
1. Réponds de manière personnalisée selon les données réelles du jardin
2. Adapte ton niveau de détail selon l'expertise utilisateur
3. Inclus des conseils pratiques et temporellement pertinents
4. Si tu analyses une image, décris précisément ce que tu vois
5. Propose toujours des actions concrètes
6. Utilise un ton bienveillant et encourageant

CAPACITÉS SPÉCIALES:
- Accès aux données jardinage en temps réel
- Analyse d'images pour diagnostic
- Corrélation avec météo et saisons
- Historique des interventions et résultats`;

    return prompt;
  }

  private async executeFunction(
    functionName: string,
    args: any,
    context: EnrichedContext
  ): Promise<string> {
    switch (functionName) {
      case 'get_garden_data':
        return await this.getGardenDataFunction(args.dataType, args.timeframe, context);
      
      case 'analyze_plant_image':
        return await this.analyzePlantImageFunction(args.imageUrl, args.analysisType);
      
      default:
        return `Fonction ${functionName} non implémentée`;
    }
  }

  async diagnoseFromPhoto(
    userId: string,
    imageData: Buffer,
    metadata: ImageMetadata
  ): Promise<PlantDiagnosis> {
    // Upload vers stockage avec métadonnées
    const imageUrl = await this.uploadDiagnosisImage(imageData, metadata);

    // Analyse avec GPT-4 Vision
    const visionAnalysis = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-vision-preview',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: `Analyse cette photo de plante et identifie:
1. L'espèce/variété si possible
2. Les problèmes visibles (maladies, parasites, carences)
3. Le stade de croissance
4. L'état général de santé
5. Tes recommandations de traitement

Contexte: ${metadata.season}, région ${metadata.region}, photo prise le ${metadata.timestamp}`
            },
            {
              type: 'image_url',
              image_url: { url: imageUrl }
            }
          ]
        }
      ],
      max_tokens: 1000
    });

    const analysisText = visionAnalysis.choices[0].message.content || '';

    // Parsing structuré de l'analyse
    const diagnosis = await this.parseVisionAnalysis(analysisText, metadata);

    // Sauvegarde du diagnostic
    await this.savePlantDiagnosis({
      userId,
      imageUrl,
      analysis: analysisText,
      diagnosis,
      metadata
    });

    return diagnosis;
  }

  // Fonctions d'analyse d'images
  private async analyzePlantImage(attachment: MessageAttachment): Promise<PlantAnalysis> {
    const completion = await this.openaiClient.chat.completions.create({
      model: 'gpt-4-vision-preview',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: 'Analyse cette image de plante et identifie l\'espèce, les problèmes visibles, et le stade de croissance.'
            },
            {
              type: 'image_url',
              image_url: { url: attachment.url }
            }
          ]
        }
      ]
    });

    return this.parseImageAnalysis(completion.choices[0].message.content || '');
  }
}
```

### Serveur MCP (Model Context Protocol)

```typescript
// src/services/mcp/mcp-server.service.ts
export interface MCPTool {
  name: string;
  description: string;
  inputSchema: object;
}

export interface MCPResource {
  uri: string;
  name: string;
  description?: string;
  mimeType?: string;
}

export class MCPServerService {
  private tools: MCPTool[] = [];
  private resources: MCPResource[] = [];

  constructor(
    private prisma: PrismaClient,
    private gardenService: GardenService,
    private weatherService: WeatherService
  ) {
    this.initializeTools();
    this.initializeResources();
  }

  private initializeTools(): void {
    this.tools = [
      {
        name: 'get_garden_overview',
        description: 'Récupère un aperçu complet du jardin avec cultures actuelles, météo et alertes',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string', description: 'ID du jardin' }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'get_current_cultures',
        description: 'Liste les cultures actuellement plantées',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            status: {
              type: 'string',
              enum: ['active', 'harvested', 'all'],
              description: 'Filtrer par statut'
            }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'get_harvest_history',
        description: 'Historique des récoltes avec quantités et dates',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            timeframe: {
              type: 'string',
              enum: ['week', 'month', 'season', 'year'],
              description: 'Période à analyser'
            },
            culture_type: { type: 'string', description: 'Filtrer par type de culture' }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'get_weather_impact',
        description: 'Analyse l\'impact météo sur les cultures',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            forecast_days: { type: 'number', minimum: 1, maximum: 14 }
          },
          required: ['garden_id']
        }
      },
      {
        name: 'suggest_interventions',
        description: 'Suggère des interventions basées sur l\'état du jardin',
        inputSchema: {
          type: 'object',
          properties: {
            garden_id: { type: 'string' },
            urgency_filter: {
              type: 'string',
              enum: ['urgent', 'soon', 'planned', 'all']
            }
          },
          required: ['garden_id']
        }
      }
    ];
  }

  private initializeResources(): void {
    this.resources = [
      {
        uri: 'basmalin://gardens/{garden_id}',
        name: 'Garden Data',
        description: 'Données complètes d\'un jardin spécifique',
        mimeType: 'application/json'
      },
      {
        uri: 'basmalin://cultures/{culture_id}',
        name: 'Culture Details',
        description: 'Détails d\'une culture spécifique',
        mimeType: 'application/json'
      },
      {
        uri: 'basmalin://weather/{garden_id}',
        name: 'Weather Data',
        description: 'Données météo pour un jardin',
        mimeType: 'application/json'
      }
    ];
  }

  // Implémentation du protocole MCP
  async handleMCPRequest(request: MCPRequest): Promise<MCPResponse> {
    try {
      switch (request.method) {
        case 'tools/list':
          return { result: { tools: this.tools } };

        case 'tools/call':
          return await this.handleToolCall(request.params);

        case 'resources/list':
          return { result: { resources: this.resources } };

        case 'resources/read':
          return await this.handleResourceRead(request.params);

        default:
          throw new Error(`Unknown method: ${request.method}`);
      }
    } catch (error) {
      return {
        error: {
          code: -1,
          message: error.message
        }
      };
    }
  }

  private async handleToolCall(params: any): Promise<MCPResponse> {
    const { name, arguments: args } = params;

    // Authentification et autorisation
    const userId = await this.validateMCPAccess(params.sessionId);
    
    switch (name) {
      case 'get_garden_overview':
        const overview = await this.getGardenOverview(userId, args.garden_id);
        return { result: { content: [{ type: 'text', text: JSON.stringify(overview, null, 2) }] } };

      case 'get_current_cultures':
        const cultures = await this.getCurrentCultures(userId, args.garden_id, args.status);
        return { result: { content: [{ type: 'text', text: JSON.stringify(cultures, null, 2) }] } };

      case 'get_harvest_history':
        const harvests = await this.getHarvestHistory(userId, args.garden_id, args.timeframe, args.culture_type);
        return { result: { content: [{ type: 'text', text: JSON.stringify(harvests, null, 2) }] } };

      case 'get_weather_impact':
        const weather = await this.getWeatherImpact(userId, args.garden_id, args.forecast_days);
        return { result: { content: [{ type: 'text', text: JSON.stringify(weather, null, 2) }] } };

      case 'suggest_interventions':
        const interventions = await this.suggestInterventions(userId, args.garden_id, args.urgency_filter);
        return { result: { content: [{ type: 'text', text: JSON.stringify(interventions, null, 2) }] } };

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  }

  private async getGardenOverview(userId: string, gardenId: string): Promise<any> {
    const garden = await this.prisma.jardin.findFirst({
      where: { id: gardenId, userId },
      include: {
        zones: {
          include: {
            instancesCultures: {
              where: { statut: 'active' },
              include: {
                varieteCulture: true,
                interventions: {
                  take: 3,
                  orderBy: { dateIntervention: 'desc' }
                },
                recoltes: {
                  take: 5,
                  orderBy: { dateRecolte: 'desc' }
                }
              }
            }
          }
        }
      }
    });

    if (!garden) {
      throw new Error('Garden not found or unauthorized');
    }

    // Récupération météo
    const weather = await this.weatherService.getCurrentWeather({
      lat: garden.latitude,
      lon: garden.longitude
    });

    // Calcul des métriques
    const activeCultures = garden.zones.flatMap(z => z.instancesCultures);
    const totalHarvests = activeCultures.reduce((sum, c) => sum + c.recoltes.length, 0);
    const recentInterventions = activeCultures.flatMap(c => c.interventions);

    return {
      garden: {
        id: garden.id,
        name: garden.nom,
        description: garden.description,
        location: {
          latitude: garden.latitude,
          longitude: garden.longitude,
          address: garden.adresse
        },
        area: garden.surface
      },
      weather: {
        current: weather.current,
        today: weather.forecast[0],
        alerts: weather.alerts
      },
      stats: {
        totalZones: garden.zones.length,
        activeCultures: activeCultures.length,
        totalHarvests,
        recentInterventions: recentInterventions.length
      },
      activeCultures: activeCultures.map(culture => ({
        id: culture.id,
        variety: culture.varieteCulture.nom,
        zone: culture.zone.nom,
        plantedAt: culture.datePlantation,
        status: culture.statut,
        lastIntervention: culture.interventions[0]?.dateIntervention,
        harvestCount: culture.recoltes.length
      })),
      alerts: await this.getActiveAlerts(gardenId)
    };
  }
}
```

### Interface Chat

```typescript
// src/app/ai-chat/page.tsx
export default function AIChatPage() {
  const [session, setSession] = useState<ConversationSession | null>(null);
  const [messages, setMessages] = useState<AIMessage[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      <div className="bg-white border-b p-4">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-xl font-semibold">🤖 Assistant Jardin IA</h1>
            <p className="text-sm text-gray-600">
              Posez vos questions sur votre potager
            </p>
          </div>
          
          <div className="flex items-center space-x-2">
            <Button variant="outline" size="sm">
              <CameraIcon className="w-4 h-4 mr-2" />
              Analyser Photo
            </Button>
            <Button variant="outline" size="sm">
              <SettingsIcon className="w-4 h-4" />
            </Button>
          </div>
        </div>
      </div>

      <div className="flex-1 flex">
        {/* Messages */}
        <div className="flex-1 flex flex-col">
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.map(message => (
              <ChatMessage key={message.id} message={message} />
            ))}
            {isLoading && <TypingIndicator />}
          </div>

          {/* Input */}
          <div className="border-t bg-white p-4">
            <ChatInput
              value={inputMessage}
              onChange={setInputMessage}
              onSend={handleSendMessage}
              disabled={isLoading}
            />
          </div>
        </div>

        {/* Sidebar contexte */}
        <div className="w-80 border-l bg-white p-4">
          <ChatContextPanel session={session} />
        </div>
      </div>
    </div>
  );
}

const ChatMessage = ({ message }: { message: AIMessage }) => {
  return (
    <div className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}>
      <div className={`max-w-3xl rounded-lg p-3 ${
        message.role === 'user' 
          ? 'bg-green-500 text-white' 
          : 'bg-white border shadow-sm'
      }`}>
        {message.attachments?.map(attachment => (
          <MessageAttachment key={attachment.id} attachment={attachment} />
        ))}
        
        <div className="prose prose-sm max-w-none">
          <ReactMarkdown>{message.content}</ReactMarkdown>
        </div>
        
        <div className="text-xs opacity-70 mt-2">
          {formatDistanceToNow(message.timestamp)}
        </div>
      </div>
    </div>
  );
};
```

## Critères d'Acceptation Techniques

### IA Conversationnelle
- [ ] Chat NLP avec GPT-4/Claude/Ollama
- [ ] Contexte personnalisé selon données jardin
- [ ] Support multi-modal (texte + images)
- [ ] Analyse d'intention et réponses adaptées
- [ ] Sessions persistantes avec historique

### Diagnostic Photo
- [ ] Upload photos avec métadonnées GPS
- [ ] Reconnaissance maladies/problèmes (>80% précision)
- [ ] Diagnostic contextualisé variété/saison
- [ ] Recommandations traitement personnalisées
- [ ] Suivi évolution problèmes

### Serveur MCP
- [ ] Protocole MCP conforme spécification
- [ ] API standardisée pour IA externes
- [ ] Authentification OAuth2 sécurisée
- [ ] Permissions granulaires par scope
- [ ] Logs détaillés et monitoring

## Couverture Exigences Architecture

- **EXG-005.1** : IA conversationnelle avancée
- **EXG-005.2** : Intégration multi-providers IA
- **EXG-002.1** : Stockage conversations et contexte
- **EXG-010.1** : Serveur MCP pour intégrations
- **EXG-009.1** : Monitoring coûts et usage IA

## Tests d'Acceptation

```typescript
// tests/integration/conversational-ai.test.ts
describe('Conversational AI', () => {
  test('création session avec contexte jardin', async () => {
    const session = await aiService.createSession('user-1', 'garden-1');
    
    expect(session.context.gardenId).toBe('garden-1');
    expect(session.context.expertise).toBeDefined();
    expect(session.messages).toHaveLength(1); // Welcome message
  });

  test('diagnostic photo maladie', async () => {
    const imageBuffer = await fs.readFile('test-plant-disease.jpg');
    const diagnosis = await aiService.diagnoseFromPhoto('user-1', imageBuffer, {
      season: 'summer',
      region: 'temperate'
    });
    
    expect(diagnosis.problems).toHaveLength(greaterThan(0));
    expect(diagnosis.recommendations).toHaveLength(greaterThan(0));
    expect(diagnosis.confidence).toBeGreaterThan(0.7);
  });

  test('serveur MCP répond aux requêtes', async () => {
    const response = await mcpServer.handleMCPRequest({
      method: 'tools/call',
      params: {
        name: 'get_garden_overview',
        arguments: { garden_id: 'garden-1' },
        sessionId: 'valid-session'
      }
    });
    
    expect(response.result).toBeDefined();
    expect(response.error).toBeUndefined();
  });
});
```

Cette spécification couvre un assistant IA complet avec diagnostic photo et serveur MCP pour intégrations externes.