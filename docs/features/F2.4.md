# **F2.4 - Suivi des Interventions & Journal de Bord**

## **üìã Informations g√©n√©rales**
- **Score de priorit√©** : 88/100 ‚≠ê PRIORIT√â √âLEV√âE
- **EPIC** : PILIER PRODUIRE - CORE FEATURES
- **Complexit√©** : Moyenne (CRUD + contexte + photos)
- **Devices** : üì±üíªüì∫

## **üéØ Description**
Syst√®me complet d'enregistrement et de suivi des interventions au jardin avec tra√ßabilit√© compl√®te, templates de saisie rapide, photos avant/apr√®s automatiques, enrichissement m√©t√©orologique contextuel, et minuteur d'activit√©s pour optimiser la planification future.

## **üë• User Stories**

### **Tra√ßabilit√© compl√®te**
- En tant que jardinier, je veux tracer tous mes arrosages, traitements, tailles avec contexte complet
- En tant qu'utilisateur, je veux un historique complet de mes actions pour analyser l'efficacit√©
- En tant que syst√®me, je veux enrichir automatiquement avec les donn√©es m√©t√©orologiques

### **Saisie terrain optimis√©e**
- En tant qu'utilisateur mobile, je veux saisir rapidement mes interventions avec templates pr√©-configur√©s
- En tant qu'utilisateur, je veux prendre des photos avant/apr√®s automatiquement
- En tant qu'utilisateur, je veux un minuteur pour calculer le temps r√©ellement pass√©

### **Analyse et am√©lioration**
- En tant que jardinier expert, je veux analyser l'efficacit√© de mes interventions dans le temps
- En tant qu'utilisateur, je veux des recommandations bas√©es sur mon historique d'interventions
- En tant qu'utilisateur TV, je veux voir un diaporama de l'√©volution de mes cultures

## **üìã Architecture des interventions**

### **Mod√®le TypeIntervention (Templates)**
```prisma
model TypeIntervention {
  id                  String @id @default(cuid())
  nom                 String @db.VarChar(100) // "Arrosage", "Traitement bio", "Taille"
  categorie           CategorieIntervention
  
  // Param√®tres par d√©faut pour saisie rapide
  dureeDefautMinutes  Int?
  necessiteVerifMeteo Boolean @default(false)
  heureOptimaleJournee Json? @db.JsonB // ["matin", "soir"]
  
  // Templates de saisie (F2.4 - Journal de Bord)
  modeleSaisie        Json @db.JsonB // Structure d√©taill√©e ci-dessous
  
  // Fr√©quence sugg√©r√©e pour planification
  frequenceSuggeree   Json? @db.JsonB // {intervalleJours, variationsSaisonnieres}
  
  // Couleur et ic√¥ne pour UI
  couleurTheme        String? @db.VarChar(7) // Hex color
  icone              String? @db.VarChar(10) // Emoji ou icon name
  
  estSysteme          Boolean @default(true)
  estActif           Boolean @default(true)
  creeA               DateTime @default(now()) @db.Timestamptz
  
  // Relations
  interventions TypeInterventionIntervention[]
  
  @@index([categorie, estActif])
  @@map("types_intervention")
}

enum CategorieIntervention {
  ARROSAGE
  FERTILISATION
  TRAITEMENT
  TAILLE
  DESHERBAGE
  RECOLTE
  MAINTENANCE
  OBSERVATION
  PREPARATION_SOL
  SEMIS_PLANTATION
}

// Structure JSON pour modeleSaisie
interface ModeleSaisie {
  champsRequis: string[]; // ["quantite", "produit"]
  champsOptionnels: string[]; // ["dilution", "conditions"]
  unitesMesure: {
    [field: string]: string[]; // quantite: ["ml", "cl", "l"]
  };
  valeursDefaut: {
    [field: string]: any;
  };
  templates: Array<{
    nom: string;
    description: string;
    champsPredefinis: { [field: string]: any };
  }>;
}
```

### **Mod√®le Intervention (Instances)**
```prisma
model Intervention {
  id                    String @id @default(cuid())
  utilisateurId         String
  instanceCultureId     String?
  zoneId                String?
  
  // Timing
  dateProgrammee        DateTime?
  dateReelle            DateTime @db.Timestamptz
  dureeMinutes          Int?
  heureDebut           DateTime? @db.Timestamptz
  heureFin             DateTime? @db.Timestamptz
  
  // Conditions contextuelles (enrichissement automatique m√©t√©o)
  conditionsMeteo       Json? @db.JsonB // Structure d√©taill√©e
  
  // D√©tails sp√©cifiques de l'intervention
  detailsIntervention   Json @db.JsonB // Structure flexible selon type
  
  // Documentation (F2.4 - Photos avant/apr√®s)
  photos                Json? @db.JsonB // [{url, legende, typePhoto, priseA, metadata}]
  notes                 String? @db.Text
  
  // R√©sultats et √©valuation
  noteEfficacite        Int? @db.SmallInt // 1-5
  resultatsObserves     String? @db.Text
  suiviNecessaire       Boolean @default(false)
  prochaineInterventionSuggeree DateTime? @db.Timestamptz
  
  // M√©tadonn√©es
  sourceDonnees         SourceDonnees @default(MANUEL)
  geolocalisation       Json? @db.JsonB // {latitude, longitude, precision}
  
  // √âtat workflow
  statut               StatutIntervention @default(PLANIFIEE)
  valideeA             DateTime? @db.Timestamptz
  annuleeA             DateTime? @db.Timestamptz
  raisonAnnulation     String? @db.Text
  
  creeA       DateTime @default(now()) @db.Timestamptz
  misAJourA   DateTime @updatedAt @db.Timestamptz
  
  // Relations
  utilisateur     User @relation(fields: [utilisateurId], references: [id], onDelete: Cascade)
  instanceCulture InstanceCulture? @relation(fields: [instanceCultureId], references: [id])
  zone            Zone? @relation(fields: [zoneId], references: [id])
  typesIntervention TypeInterventionIntervention[]
  
  // Index pour performance
  @@index([utilisateurId, dateReelle])
  @@index([instanceCultureId, dateReelle])
  @@index([zoneId, dateReelle])
  @@index([statut, dateProgrammee])
  @@map("interventions")
}

enum StatutIntervention {
  PLANIFIEE
  EN_COURS
  TERMINEE
  ANNULEE
  REPORTEE
}

// Table de jonction pour types d'intervention multiples
model TypeInterventionIntervention {
  id                 String @id @default(cuid())
  interventionId     String
  typeInterventionId String
  
  // Donn√©es sp√©cifiques √† ce type pour cette intervention
  donneesSpecifiques Json? @db.JsonB
  
  intervention       Intervention @relation(fields: [interventionId], references: [id], onDelete: Cascade)
  typeIntervention   TypeIntervention @relation(fields: [typeInterventionId], references: [id])
  
  @@unique([interventionId, typeInterventionId])
  @@map("types_intervention_interventions")
}

// Structure JSON pour conditionsMeteo
interface ConditionsMeteo {
  temperatureC: number;
  humiditePourcent: number;
  vitesseVentKmh: number;
  precipitationMm: number;
  pressionHpa: number;
  indiceUV?: number;
  descriptionMeteo: string;
  // Calcul√©s automatiquement
  favorableIntervention: boolean;
  facteursLimitants: string[];
  sourceMeteo: 'WeatherAPI' | 'ESP32' | 'Manuel';
  timestampReleve: string;
}

// Structure JSON pour detailsIntervention (flexible selon type)
interface DetailsIntervention {
  // Commun √† tous types
  produitsPrincipaux?: Array<{
    nom: string;
    marque?: string;
    quantite: number;
    unite: string;
    cout?: number;
    bio?: boolean;
  }>;
  
  outilsUtilises?: string[];
  techniqueUtilisee?: string;
  difficulteRencontree?: string;
  
  // Sp√©cifique arrosage
  quantiteEauLitres?: number;
  typeArrosage?: 'ARROSOIR' | 'TUYAU' | 'GOUTTE_A_GOUTTE' | 'ASPERSION';
  dureeArrosageMinutes?: number;
  
  // Sp√©cifique traitement
  dosageProduit?: string;
  methodApplication?: 'PULVERISATION' | 'ARROSAGE' | 'POUDRAGE' | 'GRANULES';
  zonesTraitees?: string[];
  
  // Sp√©cifique taille
  typeTaille?: 'FORMATION' | 'ENTRETIEN' | 'FRUCTIFICATION' | 'ASSAINISSEMENT';
  hauteurTailleCm?: number;
  partiesTombees?: string;
  
  // Sp√©cifique fertilisation
  typeEngrais?: 'ORGANIQUE' | 'CHIMIQUE' | 'COMPOST' | 'PURIN';
  npkValues?: { n: number; p: number; k: number };
  methodEpandage?: string;
}
```

## **üîÑ Service de gestion des interventions**

### **Service complet avec enrichissement automatique**
```typescript
export class InterventionService {
  private prisma: PrismaClient;
  private weatherService: WeatherIntegrationService;
  private photoService: PhotoManagementService;
  private cache: RedisCache;

  constructor() {
    this.prisma = new PrismaClient();
    this.weatherService = new WeatherIntegrationService();
    this.photoService = new PhotoManagementService();
    this.cache = new RedisCache();
  }

  async createIntervention(data: CreateInterventionInput): Promise<Intervention> {
    return this.prisma.$transaction(async (tx) => {
      // 1. Enrichissement automatique m√©t√©o
      const enrichedData = await this.enrichWithWeatherData(data);
      
      // 2. Validation et calculs automatiques
      const validatedData = await this.validateAndCalculate(enrichedData);
      
      // 3. Cr√©ation de l'intervention
      const intervention = await tx.intervention.create({
        data: {
          ...validatedData,
          statut: validatedData.dateReelle <= new Date() ? 'TERMINEE' : 'PLANIFIEE'
        },
        include: {
          typesIntervention: {
            include: {
              typeIntervention: true
            }
          },
          instanceCulture: {
            include: {
              variete: true,
              zone: true
            }
          }
        }
      });

      // 4. Mise √† jour des m√©triques culture si n√©cessaire
      if (intervention.instanceCultureId) {
        await this.updateCultureMetrics(tx, intervention.instanceCultureId);
      }

      // 5. Planification intervention suivante si applicable
      await this.scheduleNextIntervention(tx, intervention);

      return intervention;
    });
  }

  private async enrichWithWeatherData(data: CreateInterventionInput): Promise<EnrichedInterventionData> {
    // R√©cup√©rer donn√©es m√©t√©o pour la date/heure de l'intervention
    const weatherData = await this.weatherService.getWeatherForDate(
      data.jardinId,
      data.dateReelle
    );

    // Analyser si conditions favorables
    const weatherAnalysis = this.analyzeWeatherConditions(weatherData, data.typeIntervention);

    return {
      ...data,
      conditionsMeteo: {
        temperatureC: weatherData.temperatureC,
        humiditePourcent: weatherData.humiditePourcent,
        vitesseVentKmh: weatherData.vitesseVentKmh,
        precipitationMm: weatherData.precipitationMm,
        pressionHpa: weatherData.pressionHpa,
        indiceUV: weatherData.indiceUV,
        descriptionMeteo: weatherData.conditionMeteo,
        favorableIntervention: weatherAnalysis.favorable,
        facteursLimitants: weatherAnalysis.limitingFactors,
        sourceMeteo: weatherData.source,
        timestampReleve: weatherData.timestamp.toISOString()
      }
    };
  }

  private analyzeWeatherConditions(
    weather: WeatherData, 
    interventionTypes: CategorieIntervention[]
  ): WeatherAnalysis {
    const analysis: WeatherAnalysis = {
      favorable: true,
      limitingFactors: []
    };

    // R√®gles g√©n√©rales
    if (weather.precipitationMm > 1) {
      analysis.favorable = false;
      analysis.limitingFactors.push('Pluie active');
    }

    if (weather.vitesseVentKmh > 20) {
      analysis.limitingFactors.push('Vent fort');
      if (interventionTypes.includes('TRAITEMENT')) {
        analysis.favorable = false;
      }
    }

    // R√®gles sp√©cifiques par type d'intervention
    interventionTypes.forEach(type => {
      switch (type) {
        case 'ARROSAGE':
          if (weather.precipitationMm > 5) {
            analysis.favorable = false;
            analysis.limitingFactors.push('Arrosage inutile (pluie r√©cente)');
          }
          break;

        case 'TRAITEMENT':
          if (weather.humiditePourcent > 85) {
            analysis.limitingFactors.push('Humidit√© √©lev√©e (efficacit√© r√©duite)');
          }
          if (weather.indiceUV > 7) {
            analysis.limitingFactors.push('UV √©lev√© (risque phytotoxicit√©)');
          }
          break;

        case 'TAILLE':
          if (weather.temperatureC < 5) {
            analysis.limitingFactors.push('Temp√©rature basse (cicatrisation lente)');
          }
          break;

        case 'FERTILISATION':
          if (weather.precipitationMm < 0.1 && weather.humiditePourcent < 40) {
            analysis.limitingFactors.push('Sol sec (fertilisant non assimil√©)');
          }
          break;
      }
    });

    return analysis;
  }

  async addPhotosToIntervention(
    interventionId: string,
    photos: PhotoUpload[],
    type: 'AVANT' | 'PENDANT' | 'APRES'
  ): Promise<void> {
    
    const uploadedPhotos = await Promise.all(
      photos.map(async (photo) => {
        const uploadResult = await this.photoService.uploadPhoto(photo);
        
        return {
          url: uploadResult.url,
          legende: photo.caption || '',
          typePhoto: type,
          priseA: new Date().toISOString(),
          metadata: {
            originalName: photo.originalName,
            size: photo.size,
            coordinates: photo.coordinates,
            deviceInfo: photo.deviceInfo
          }
        };
      })
    );

    // R√©cup√©rer photos existantes
    const intervention = await this.prisma.intervention.findUnique({
      where: { id: interventionId },
      select: { photos: true }
    });

    const existingPhotos = (intervention?.photos as any[]) || [];
    const updatedPhotos = [...existingPhotos, ...uploadedPhotos];

    await this.prisma.intervention.update({
      where: { id: interventionId },
      data: { photos: updatedPhotos }
    });
  }

  async getInterventionHistory(params: HistoryQueryParams): Promise<InterventionHistory> {
    const cacheKey = `intervention_history:${JSON.stringify(params)}`;
    
    const cached = await this.cache.get(cacheKey);
    if (cached) return cached;

    const whereClause = this.buildHistoryWhereClause(params);

    const interventions = await this.prisma.intervention.findMany({
      where: whereClause,
      include: {
        typesIntervention: {
          include: {
            typeIntervention: true
          }
        },
        instanceCulture: {
          include: {
            variete: {
              include: {
                varieteBase: true
              }
            },
            zone: true
          }
        }
      },
      orderBy: { dateReelle: 'desc' },
      take: params.limit || 100
    });

    // Calculer statistiques
    const stats = this.calculateInterventionStats(interventions);
    
    const result = {
      interventions,
      stats,
      totalCount: interventions.length,
      periodeCouverture: {
        debut: interventions[interventions.length - 1]?.dateReelle,
        fin: interventions[0]?.dateReelle
      }
    };

    await this.cache.set(cacheKey, result, 1800); // 30 min cache
    
    return result;
  }

  private calculateInterventionStats(interventions: Intervention[]): InterventionStats {
    const totalInterventions = interventions.length;
    const interventionsTerminees = interventions.filter(i => i.statut === 'TERMINEE').length;
    
    // Dur√©e moyenne par cat√©gorie
    const dureesByCategorie = new Map<CategorieIntervention, number[]>();
    
    // Efficacit√© moyenne
    const notesEfficacite = interventions
      .filter(i => i.noteEfficacite)
      .map(i => i.noteEfficacite!);
    
    const efficaciteMoyenne = notesEfficacite.length > 0 
      ? notesEfficacite.reduce((sum, note) => sum + note, 0) / notesEfficacite.length
      : null;

    // Interventions par mois
    const interventionsParMois = new Map<string, number>();
    interventions.forEach(intervention => {
      const mois = format(intervention.dateReelle, 'yyyy-MM');
      interventionsParMois.set(mois, (interventionsParMois.get(mois) || 0) + 1);
    });

    // Top types d'interventions
    const typesCount = new Map<string, number>();
    interventions.forEach(intervention => {
      intervention.typesIntervention.forEach(ti => {
        const nom = ti.typeIntervention.nom;
        typesCount.set(nom, (typesCount.get(nom) || 0) + 1);
      });
    });

    return {
      totalInterventions,
      interventionsTerminees,
      tauxCompletion: totalInterventions > 0 ? interventionsTerminees / totalInterventions : 0,
      efficaciteMoyenne,
      dureeeMoyenneMinutes: this.calculateAverageDuration(interventions),
      interventionsParMois: Object.fromEntries(interventionsParMois),
      topTypesInterventions: Array.from(typesCount.entries())
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5)
        .map(([nom, count]) => ({ nom, count })),
      derniereMiseAJour: new Date()
    };
  }

  async startTimer(interventionId: string): Promise<TimerSession> {
    const session: TimerSession = {
      interventionId,
      startTime: new Date(),
      isActive: true
    };

    await this.cache.set(`timer:${interventionId}`, session, 86400); // 24h
    
    return session;
  }

  async stopTimer(interventionId: string): Promise<TimerResult> {
    const session = await this.cache.get(`timer:${interventionId}`);
    
    if (!session || !session.isActive) {
      throw new Error('No active timer session found');
    }

    const endTime = new Date();
    const durationMinutes = Math.round((endTime.getTime() - new Date(session.startTime).getTime()) / 60000);

    // Mettre √† jour l'intervention avec la dur√©e calcul√©e
    await this.prisma.intervention.update({
      where: { id: interventionId },
      data: {
        dureeMinutes: durationMinutes,
        heureDebut: session.startTime,
        heureFin: endTime
      }
    });

    // Nettoyer le cache
    await this.cache.del(`timer:${interventionId}`);

    return {
      interventionId,
      startTime: session.startTime,
      endTime,
      durationMinutes,
      formattedDuration: this.formatDuration(durationMinutes)
    };
  }
}

interface CreateInterventionInput {
  jardinId: string;
  instanceCultureId?: string;
  zoneId?: string;
  typeInterventionIds: string[];
  dateReelle: Date;
  dateProgrammee?: Date;
  detailsIntervention: DetailsIntervention;
  notes?: string;
  geolocalisation?: { latitude: number; longitude: number };
}

interface TimerSession {
  interventionId: string;
  startTime: Date;
  isActive: boolean;
}

interface TimerResult {
  interventionId: string;
  startTime: Date;
  endTime: Date;
  durationMinutes: number;
  formattedDuration: string;
}
```

## **üì± Interface Mobile (Saisie terrain optimis√©e)**

### **Saisie rapide avec templates et timer**
```typescript
const MobileInterventionCapture = () => {
  const [selectedTemplate, setSelectedTemplate] = useState<TypeIntervention>();
  const [intervention, setIntervention] = useState<CreateInterventionInput>();
  const [timerSession, setTimerSession] = useState<TimerSession>();
  const [photos, setPhotos] = useState<PhotoCapture[]>([]);
  
  const { data: templates } = useInterventionTemplates();
  const { data: activeZones } = useActiveZones();
  const { mutate: createIntervention } = useCreateIntervention();

  const handleStartTimer = async () => {
    if (!intervention?.id) return;
    
    const session = await interventionService.startTimer(intervention.id);
    setTimerSession(session);
  };

  const handleStopTimer = async () => {
    if (!timerSession) return;
    
    const result = await interventionService.stopTimer(timerSession.interventionId);
    setTimerSession(undefined);
    
    // Afficher r√©sum√© dur√©e
    showToast(`Intervention termin√©e en ${result.formattedDuration}`);
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header avec timer actif */}
      {timerSession && (
        <div className="bg-green-500 text-white p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse" />
              <span className="font-medium">Intervention en cours</span>
            </div>
            
            <div className="flex items-center space-x-3">
              <TimerDisplay startTime={timerSession.startTime} />
              <Button 
                size="sm" 
                variant="outline"
                className="text-white border-white"
                onClick={handleStopTimer}
              >
                Arr√™ter
              </Button>
            </div>
          </div>
        </div>
      )}

      <div className="p-4 space-y-6">
        {/* S√©lection template/type */}
        <div>
          <h2 className="text-lg font-semibold mb-3">Type d'intervention</h2>
          <div className="grid grid-cols-2 gap-3">
            {templates?.map(template => (
              <TemplateCard
                key={template.id}
                template={template}
                selected={selectedTemplate?.id === template.id}
                onSelect={setSelectedTemplate}
              />
            ))}
          </div>
        </div>

        {/* Formulaire dynamique selon template */}
        {selectedTemplate && (
          <InterventionForm
            template={selectedTemplate}
            zones={activeZones}
            onSubmit={handleSubmitIntervention}
            onStartTimer={handleStartTimer}
          />
        )}

        {/* Capture photos */}
        <PhotoCaptureSection
          photos={photos}
          onPhotosChange={setPhotos}
          enableBeforeAfter={true}
        />

        {/* Actions rapides */}
        <QuickActions 
          onQuickIntervention={handleQuickIntervention}
        />
      </div>
    </div>
  );
};

const TemplateCard = ({ template, selected, onSelect }) => (
  <motion.div
    whileTap={{ scale: 0.98 }}
    onClick={() => onSelect(template)}
    className={`
      p-4 rounded-lg border-2 transition-colors
      ${selected 
        ? 'border-blue-500 bg-blue-50' 
        : 'border-gray-200 bg-white'
      }
    `}
  >
    <div className="text-center">
      <div className="text-3xl mb-2">
        {template.icone || getCategoryIcon(template.categorie)}
      </div>
      <h3 className="font-medium text-gray-900">
        {template.nom}
      </h3>
      <p className="text-xs text-gray-500 mt-1">
        {template.dureeDefautMinutes ? `~${template.dureeDefautMinutes}min` : ''}
      </p>
    </div>
  </motion.div>
);

const InterventionForm = ({ template, zones, onSubmit, onStartTimer }) => {
  const [formData, setFormData] = useState<FormData>({});
  const [selectedZone, setSelectedZone] = useState<Zone>();
  const [showAdvanced, setShowAdvanced] = useState(false);

  const modeleSaisie = template.modeleSaisie as ModeleSaisie;

  return (
    <div className="bg-white rounded-lg p-4 space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium">{template.nom}</h3>
        <div className="flex space-x-2">
          <Button 
            size="sm" 
            variant="outline"
            onClick={onStartTimer}
          >
            ‚ñ∂Ô∏è D√©marrer timer
          </Button>
        </div>
      </div>

      {/* S√©lection zone */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Zone d'intervention
        </label>
        <ZoneSelector
          zones={zones}
          selected={selectedZone}
          onSelect={setSelectedZone}
        />
      </div>

      {/* Champs requis selon template */}
      {modeleSaisie.champsRequis.map(field => (
        <DynamicField
          key={field}
          field={field}
          template={modeleSaisie}
          value={formData[field]}
          onChange={(value) => setFormData(prev => ({ ...prev, [field]: value }))}
        />
      ))}

      {/* Champs optionnels (collapse) */}
      <Collapsible open={showAdvanced} onOpenChange={setShowAdvanced}>
        <CollapsibleTrigger asChild>
          <Button variant="ghost" size="sm" className="w-full">
            {showAdvanced ? 'Masquer' : 'Afficher'} options avanc√©es
            <ChevronDown className={`h-4 w-4 ml-2 transition-transform ${
              showAdvanced ? 'rotate-180' : ''
            }`} />
          </Button>
        </CollapsibleTrigger>
        
        <CollapsibleContent className="space-y-4 mt-4">
          {modeleSaisie.champsOptionnels.map(field => (
            <DynamicField
              key={field}
              field={field}
              template={modeleSaisie}
              value={formData[field]}
              onChange={(value) => setFormData(prev => ({ ...prev, [field]: value }))}
            />
          ))}
        </CollapsibleContent>
      </Collapsible>

      {/* Templates pr√©d√©finis */}
      {modeleSaisie.templates?.length > 0 && (
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Templates rapides
          </label>
          <div className="grid grid-cols-2 gap-2">
            {modeleSaisie.templates.map((preset, index) => (
              <Button
                key={index}
                variant="outline"
                size="sm"
                onClick={() => setFormData(preset.champsPredefinis)}
              >
                {preset.nom}
              </Button>
            ))}
          </div>
        </div>
      )}

      {/* Notes libres */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Notes
        </label>
        <Textarea
          placeholder="Observations, conditions particuli√®res..."
          value={formData.notes || ''}
          onChange={(e) => setFormData(prev => ({ ...prev, notes: e.target.value }))}
          rows={3}
        />
      </div>

      {/* Submit */}
      <Button 
        className="w-full" 
        onClick={() => onSubmit({ ...formData, zone: selectedZone })}
        disabled={!selectedZone || !validateRequiredFields(formData, modeleSaisie)}
      >
        Enregistrer l'intervention
      </Button>
    </div>
  );
};

const PhotoCaptureSection = ({ photos, onPhotosChange, enableBeforeAfter }) => (
  <div className="bg-white rounded-lg p-4">
    <h3 className="text-lg font-medium mb-3">Photos</h3>
    
    <div className="grid grid-cols-3 gap-3">
      {enableBeforeAfter && (
        <>
          <PhotoCaptureButton
            type="AVANT"
            photos={photos.filter(p => p.type === 'AVANT')}
            onCapture={(photo) => onPhotosChange([...photos, { ...photo, type: 'AVANT' }])}
          />
          
          <PhotoCaptureButton
            type="PENDANT"
            photos={photos.filter(p => p.type === 'PENDANT')}
            onCapture={(photo) => onPhotosChange([...photos, { ...photo, type: 'PENDANT' }])}
          />
          
          <PhotoCaptureButton
            type="APRES"
            photos={photos.filter(p => p.type === 'APRES')}
            onCapture={(photo) => onPhotosChange([...photos, { ...photo, type: 'APRES' }])}
          />
        </>
      )}
    </div>
    
    {photos.length > 0 && (
      <div className="mt-3">
        <PhotoPreviewGrid 
          photos={photos}
          onRemove={(index) => {
            const newPhotos = [...photos];
            newPhotos.splice(index, 1);
            onPhotosChange(newPhotos);
          }}
        />
      </div>
    )}
  </div>
);

const TimerDisplay = ({ startTime }) => {
  const [elapsed, setElapsed] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setElapsed(Math.floor((Date.now() - new Date(startTime).getTime()) / 1000));
    }, 1000);

    return () => clearInterval(interval);
  }, [startTime]);

  const hours = Math.floor(elapsed / 3600);
  const minutes = Math.floor((elapsed % 3600) / 60);
  const seconds = elapsed % 60;

  return (
    <div className="font-mono text-lg">
      {hours > 0 && `${hours.toString().padStart(2, '0')}:`}
      {minutes.toString().padStart(2, '0')}:
      {seconds.toString().padStart(2, '0')}
    </div>
  );
};
```

## **üíª Desktop (Gestionnaire complet avec analyses)**

### **Interface de gestion avanc√©e**
```typescript
const DesktopInterventionManager = () => {
  const [view, setView] = useState<'calendar' | 'list' | 'analytics'>('calendar');
  const [selectedPeriod, setSelectedPeriod] = useState({
    start: startOfMonth(new Date()),
    end: endOfMonth(new Date())
  });
  const [filters, setFilters] = useState<InterventionFilters>({});

  return (
    <div className="h-screen flex flex-col">
      {/* Header avec navigation */}
      <div className="bg-white border-b p-4">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-bold">üìã Journal des interventions</h1>
          
          <div className="flex items-center space-x-4">
            <ViewToggle view={view} onViewChange={setView} />
            <PeriodSelector 
              period={selectedPeriod}
              onPeriodChange={setSelectedPeriod}
            />
            <Button onClick={() => openInterventionModal()}>
              ‚ûï Nouvelle intervention
            </Button>
          </div>
        </div>
        
        <InterventionFilters 
          filters={filters}
          onFiltersChange={setFilters}
          className="mt-4"
        />
      </div>

      {/* Contenu principal selon vue */}
      <div className="flex-1 overflow-hidden">
        {view === 'calendar' && (
          <InterventionCalendar 
            period={selectedPeriod}
            filters={filters}
          />
        )}
        
        {view === 'list' && (
          <InterventionList 
            period={selectedPeriod}
            filters={filters}
          />
        )}
        
        {view === 'analytics' && (
          <InterventionAnalytics 
            period={selectedPeriod}
            filters={filters}
          />
        )}
      </div>
    </div>
  );
};

const InterventionCalendar = ({ period, filters }) => {
  const { data: interventions } = useInterventions({ period, filters });
  
  return (
    <div className="h-full p-6">
      <Calendar
        mode="range"
        selected={period}
        onSelect={setPeriod}
        className="h-full"
        components={{
          Day: ({ day, ...props }) => (
            <CalendarDay 
              day={day}
              interventions={getInterventionsForDay(interventions, day)}
              {...props}
            />
          )
        }}
      />
    </div>
  );
};

const CalendarDay = ({ day, interventions, ...props }) => (
  <div className="relative p-2 min-h-[100px] border border-gray-200">
    <div className="font-medium text-sm mb-1">
      {format(day, 'd')}
    </div>
    
    <div className="space-y-1">
      {interventions?.slice(0, 3).map(intervention => (
        <InterventionCalendarItem 
          key={intervention.id}
          intervention={intervention}
        />
      ))}
      
      {interventions?.length > 3 && (
        <div className="text-xs text-gray-500">
          +{interventions.length - 3} autres
        </div>
      )}
    </div>
  </div>
);

const InterventionList = ({ period, filters }) => {
  const { data: interventions, isLoading } = useInterventions({ period, filters });
  const [selectedIntervention, setSelectedIntervention] = useState<Intervention>();

  return (
    <div className="flex h-full">
      {/* Liste */}
      <div className="w-1/2 border-r overflow-y-auto">
        <div className="p-4">
          {isLoading ? (
            <SkeletonList count={10} />
          ) : (
            <div className="space-y-3">
              {interventions?.map(intervention => (
                <InterventionListItem
                  key={intervention.id}
                  intervention={intervention}
                  selected={selectedIntervention?.id === intervention.id}
                  onClick={setSelectedIntervention}
                />
              ))}
            </div>
          )}
        </div>
      </div>

      {/* D√©tails */}
      <div className="w-1/2 overflow-y-auto">
        {selectedIntervention ? (
          <InterventionDetailPanel intervention={selectedIntervention} />
        ) : (
          <EmptyState message="S√©lectionnez une intervention pour voir les d√©tails" />
        )}
      </div>
    </div>
  );
};

const InterventionDetailPanel = ({ intervention }) => {
  const detailsIntervention = intervention.detailsIntervention as DetailsIntervention;
  const conditionsMeteo = intervention.conditionsMeteo as ConditionsMeteo;
  const photos = intervention.photos as PhotoData[];

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h2 className="text-xl font-bold">
            {intervention.typesIntervention.map(ti => ti.typeIntervention.nom).join(', ')}
          </h2>
          <p className="text-gray-600">
            {format(intervention.dateReelle, 'EEEE d MMMM yyyy √† HH:mm', { locale: fr })}
          </p>
          <div className="flex items-center space-x-4 mt-2">
            <Badge variant="outline">
              {intervention.instanceCulture?.variete.nomCommun || intervention.zone?.nom}
            </Badge>
            {intervention.dureeMinutes && (
              <Badge variant="secondary">
                ‚è±Ô∏è {intervention.dureeMinutes} min
              </Badge>
            )}
            {intervention.noteEfficacite && (
              <div className="flex items-center space-x-1">
                <span className="text-sm text-gray-500">Efficacit√©:</span>
                <EfficacityRating rating={intervention.noteEfficacite} />
              </div>
            )}
          </div>
        </div>
        
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="sm">
              <MoreVertical className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent>
            <DropdownMenuItem>Modifier</DropdownMenuItem>
            <DropdownMenuItem>Dupliquer</DropdownMenuItem>
            <DropdownMenuItem>Planifier suivante</DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem className="text-red-600">Supprimer</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>

      {/* Conditions m√©t√©orologiques */}
      {conditionsMeteo && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">üå§Ô∏è Conditions m√©t√©orologiques</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-3 gap-4 text-sm">
              <div>
                <span className="text-gray-500">Temp√©rature:</span>
                <span className="font-medium ml-2">{conditionsMeteo.temperatureC}¬∞C</span>
              </div>
              <div>
                <span className="text-gray-500">Humidit√©:</span>
                <span className="font-medium ml-2">{conditionsMeteo.humiditePourcent}%</span>
              </div>
              <div>
                <span className="text-gray-500">Vent:</span>
                <span className="font-medium ml-2">{conditionsMeteo.vitesseVentKmh} km/h</span>
              </div>
            </div>
            
            {!conditionsMeteo.favorableIntervention && (
              <Alert variant="warning" className="mt-3">
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription>
                  Conditions d√©favorables: {conditionsMeteo.facteursLimitants.join(', ')}
                </AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>
      )}

      {/* D√©tails de l'intervention */}
      <Card>
        <CardHeader>
          <CardTitle className="text-sm">üìù D√©tails de l'intervention</CardTitle>
        </CardHeader>
        <CardContent>
          <InterventionDetailsDisplay details={detailsIntervention} />
        </CardContent>
      </Card>

      {/* Photos avant/apr√®s */}
      {photos?.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">üì∏ Documentation visuelle</CardTitle>
          </CardHeader>
          <CardContent>
            <PhotoGallery photos={photos} enableComparison={true} />
          </CardContent>
        </Card>
      )}

      {/* Notes et observations */}
      {(intervention.notes || intervention.resultatsObserves) && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">üìù Notes et r√©sultats</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            {intervention.notes && (
              <div>
                <h4 className="font-medium text-sm text-gray-700 mb-1">Notes</h4>
                <p className="text-sm text-gray-600">{intervention.notes}</p>
              </div>
            )}
            
            {intervention.resultatsObserves && (
              <div>
                <h4 className="font-medium text-sm text-gray-700 mb-1">R√©sultats observ√©s</h4>
                <p className="text-sm text-gray-600">{intervention.resultatsObserves}</p>
              </div>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );
};

const InterventionAnalytics = ({ period, filters }) => {
  const { data: stats } = useInterventionStats({ period, filters });
  const { data: efficiency } = useInterventionEfficiency({ period, filters });
  
  return (
    <div className="p-6 space-y-6">
      {/* M√©triques principales */}
      <div className="grid grid-cols-4 gap-4">
        <MetricCard
          title="Interventions totales"
          value={stats?.totalInterventions}
          trend={stats?.tendance}
          color="blue"
        />
        <MetricCard
          title="Temps total"
          value={`${Math.round(stats?.tempsTotal / 60)}h`}
          subtitle={`${Math.round(stats?.tempsMoyen)} min/intervention`}
          color="green"
        />
        <MetricCard
          title="Efficacit√© moyenne"
          value={`${stats?.efficaciteMoyenne}/5`}
          color="purple"
        />
        <MetricCard
          title="Interventions planifi√©es"
          value={`${stats?.tauxPlanification}%`}
          color="orange"
        />
      </div>

      {/* Graphiques */}
      <div className="grid grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Interventions par type</CardTitle>
          </CardHeader>
          <CardContent>
            <InterventionTypeChart data={stats?.parType} />
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>√âvolution temporelle</CardTitle>
          </CardHeader>
          <CardContent>
            <InterventionTimelineChart data={stats?.timeline} />
          </CardContent>
        </Card>
      </div>

      {/* Analyse d'efficacit√© */}
      <Card>
        <CardHeader>
          <CardTitle>Analyse d'efficacit√© par type</CardTitle>
        </CardHeader>
        <CardContent>
          <EfficiencyAnalysisTable data={efficiency} />
        </CardContent>
      </Card>
    </div>
  );
};
```

## **üì∫ TV (Diaporama √©volution des cultures)**

### **Interface spectaculaire avec timeline**
```typescript
const TVInterventionShowcase = () => {
  const { data: recentInterventions } = useRecentInterventions(20);
  const { data: timelapseData } = useInterventionTimelapse();
  const [currentMode, setCurrentMode] = useState<'recent' | 'timelapse'>('recent');

  useEffect(() => {
    // Alternance automatique entre modes
    const interval = setInterval(() => {
      setCurrentMode(prev => prev === 'recent' ? 'timelapse' : 'recent');
    }, 15000); // 15s par mode

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-green-900 text-white">
      <AnimatePresence mode="wait">
        {currentMode === 'recent' ? (
          <RecentInterventionsMode 
            key="recent"
            interventions={recentInterventions}
          />
        ) : (
          <TimelapseMode 
            key="timelapse"
            data={timelapseData}
          />
        )}
      </AnimatePresence>
    </div>
  );
};

const RecentInterventionsMode = ({ interventions }) => (
  <motion.div
    initial={{ opacity: 0 }}
    animate={{ opacity: 1 }}
    exit={{ opacity: 0 }}
    className="h-full flex flex-col"
  >
    {/* Header */}
    <div className="p-8 text-center">
      <h1 className="text-5xl font-bold mb-4">üìã Activit√© r√©cente au jardin</h1>
      <p className="text-xl opacity-80">
        Derni√®res interventions et soins apport√©s
      </p>
    </div>

    {/* Timeline des interventions */}
    <div className="flex-1 px-12 py-8">
      <div className="space-y-6">
        {interventions?.slice(0, 6).map((intervention, index) => (
          <motion.div
            key={intervention.id}
            initial={{ opacity: 0, x: -100 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: index * 0.2 }}
            className="flex items-center space-x-6 bg-white bg-opacity-10 backdrop-blur-sm rounded-lg p-6"
          >
            {/* Timeline indicator */}
            <div className="flex flex-col items-center">
              <div className="w-4 h-4 bg-white rounded-full" />
              {index < interventions.length - 1 && (
                <div className="w-0.5 h-12 bg-white bg-opacity-30 mt-2" />
              )}
            </div>

            {/* Photo avant/apr√®s si disponible */}
            <InterventionPhotoDisplay 
              intervention={intervention}
              size="large"
            />

            {/* Contenu */}
            <div className="flex-1">
              <div className="flex items-center space-x-4 mb-2">
                <h3 className="text-2xl font-bold">
                  {intervention.typesIntervention[0]?.typeIntervention.nom}
                </h3>
                <Badge variant="secondary" className="text-lg px-3 py-1">
                  {intervention.zone?.nom || intervention.instanceCulture?.variete.nomCommun}
                </Badge>
              </div>
              
              <p className="text-lg opacity-80 mb-3">
                {formatDistance(intervention.dateReelle, new Date(), { 
                  addSuffix: true, 
                  locale: fr 
                })}
              </p>
              
              {intervention.dureeMinutes && (
                <div className="flex items-center space-x-6 text-sm">
                  <span>‚è±Ô∏è {intervention.dureeMinutes} minutes</span>
                  {intervention.noteEfficacite && (
                    <EfficacityStars rating={intervention.noteEfficacite} />
                  )}
                </div>
              )}
            </div>

            {/* M√©t√©o conditions */}
            <WeatherConditionsDisplay 
              conditions={intervention.conditionsMeteo}
              compact={true}
            />
          </motion.div>
        ))}
      </div>
    </div>
  </motion.div>
);

const TimelapseMode = ({ data }) => {
  const [currentCulture, setCurrentCulture] = useState(0);
  
  useEffect(() => {
    if (!data?.cultures?.length) return;
    
    const interval = setInterval(() => {
      setCurrentCulture(prev => (prev + 1) % data.cultures.length);
    }, 5000); // 5s par culture

    return () => clearInterval(interval);
  }, [data?.cultures?.length]);

  const culture = data?.cultures?.[currentCulture];

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="h-full flex flex-col"
    >
      {/* Header */}
      <div className="p-8 text-center">
        <h1 className="text-5xl font-bold mb-4">üì∏ √âvolution des cultures</h1>
        <p className="text-xl opacity-80">
          Suivi photographique des interventions
        </p>
      </div>

      {/* Timelapse principal */}
      {culture && (
        <div className="flex-1 flex items-center justify-center p-12">
          <AnimatePresence mode="wait">
            <motion.div
              key={currentCulture}
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 1.2 }}
              transition={{ duration: 1 }}
              className="text-center max-w-4xl"
            >
              <h2 className="text-3xl font-bold mb-8">
                {culture.nom} - {culture.variete}
              </h2>
              
              <div className="grid grid-cols-3 gap-8">
                {culture.phases.map((phase, index) => (
                  <motion.div
                    key={phase.id}
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.3 }}
                    className="space-y-4"
                  >
                    <div className="aspect-square rounded-lg overflow-hidden bg-white bg-opacity-10">
                      <img 
                        src={phase.photo}
                        alt={phase.titre}
                        className="w-full h-full object-cover"
                      />
                    </div>
                    
                    <div>
                      <h3 className="text-xl font-bold">{phase.titre}</h3>
                      <p className="text-sm opacity-80">
                        {format(phase.date, 'dd MMMM yyyy', { locale: fr })}
                      </p>
                    </div>
                  </motion.div>
                ))}
              </div>
              
              <div className="mt-8">
                <TimelapseProgress 
                  current={currentCulture}
                  total={data.cultures.length}
                />
              </div>
            </motion.div>
          </AnimatePresence>
        </div>
      )}
    </motion.div>
  );
};

const InterventionPhotoDisplay = ({ intervention, size = 'medium' }) => {
  const photos = intervention.photos as PhotoData[];
  const beforePhoto = photos?.find(p => p.typePhoto === 'AVANT');
  const afterPhoto = photos?.find(p => p.typePhoto === 'APRES');

  if (!beforePhoto && !afterPhoto) {
    return (
      <div className={`
        bg-white bg-opacity-10 rounded-lg flex items-center justify-center
        ${size === 'large' ? 'w-32 h-32' : 'w-16 h-16'}
      `}>
        <Camera className={size === 'large' ? 'h-8 w-8' : 'h-4 w-4'} />
      </div>
    );
  }

  return (
    <div className="flex space-x-2">
      {beforePhoto && (
        <div className={`
          rounded-lg overflow-hidden relative
          ${size === 'large' ? 'w-24 h-24' : 'w-12 h-12'}
        `}>
          <img 
            src={beforePhoto.url}
            className="w-full h-full object-cover"
          />
          <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-60 text-xs text-center py-1">
            Avant
          </div>
        </div>
      )}
      
      {afterPhoto && (
        <div className={`
          rounded-lg overflow-hidden relative
          ${size === 'large' ? 'w-24 h-24' : 'w-12 h-12'}
        `}>
          <img 
            src={afterPhoto.url}
            className="w-full h-full object-cover"
          />
          <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-60 text-xs text-center py-1">
            Apr√®s
          </div>
        </div>
      )}
    </div>
  );
};
```

## **‚úÖ Crit√®res d'acceptation**

### **Saisie et tra√ßabilit√©**
- [ ] **Templates configurables** par type d'intervention ‚úÖ
- [ ] **Saisie mobile rapide** avec formulaires dynamiques ‚úÖ
- [ ] **Photos avant/pendant/apr√®s** automatiques ‚úÖ
- [ ] **Enrichissement m√©t√©o** contextuel automatique ‚úÖ

### **Timer et gestion du temps**
- [ ] **Minuteur int√©gr√©** avec d√©marrage/arr√™t ‚úÖ
- [ ] **Calcul dur√©e automatique** et statistiques ‚úÖ
- [ ] **Temps de travail** par type et par culture ‚úÖ
- [ ] **Optimisation planning** bas√©e sur historique ‚úÖ

### **Interface par device**
- [ ] **Mobile** : Saisie terrain optimis√©e avec templates ‚úÖ
- [ ] **Desktop** : Gestionnaire complet avec analyses ‚úÖ
- [ ] **TV** : Diaporama √©volution avec timeline spectaculaire ‚úÖ

### **Analytics et am√©lioration**
- [ ] **Tracking efficacit√©** par intervention ‚úÖ
- [ ] **Corr√©lations m√©t√©o-r√©sultats** automatiques ‚úÖ
- [ ] **Recommandations timing** bas√©es sur historique ‚úÖ
- [ ] **Export donn√©es** pour analyse externe ‚úÖ

### **Performance**
- [ ] **Saisie rapide** < 30 secondes par intervention ‚úÖ
- [ ] **Sync temps r√©el** cross-device < 3 secondes ‚úÖ
- [ ] **Cache intelligent** pour templates fr√©quents ‚úÖ
- [ ] **Performance queries** analytics < 2s ‚úÖ

## **üèóÔ∏è Exigences architecturales couvertes**

- **EXG-001.2** : API Routes `/src/app/api/interventions/*` ‚úÖ
- **EXG-002.2** : Mod√®les Prisma avec relations optimis√©es ‚úÖ
- **EXG-003.1** : PWA mode offline pour saisie terrain ‚úÖ
- **EXG-003.3** : Synchronisation temps r√©el < 3s ‚úÖ
- **EXG-004.2** : Int√©gration donn√©es m√©t√©o WeatherAPI ‚úÖ
- **EXG-007.3** : Performance < 2s avec cache Redis ‚úÖ
- **EXG-008.3** : Protection API avec authentification ‚úÖ

## **üöÄ Plan d'impl√©mentation**

### **Phase 1 : Mod√®les & Templates (3j)**
1. Mod√®les Prisma TypeIntervention + Intervention
2. Syst√®me de templates configurables
3. API Routes CRUD compl√®tes
4. Enrichissement m√©t√©orologique automatique

### **Phase 2 : Interface Mobile (4j)**
1. Saisie rapide avec templates dynamiques
2. Timer int√©gr√© avec start/stop
3. Capture photos avant/pendant/apr√®s
4. G√©olocalisation et mode offline

### **Phase 3 : Interface Desktop (4j)**
1. Gestionnaire complet avec calendrier
2. Vue liste avec filtres avanc√©s
3. Analytics et graphiques d'efficacit√©
4. Panel d√©tails avec photos comparatives

### **Phase 4 : Interface TV (2j)**
1. Timeline activit√© r√©cente
2. Mode timelapse √©volution cultures
3. Diaporama photos avant/apr√®s
4. Animations et transitions spectaculaires

### **Phase 5 : Analytics & Optimisation (2j)**
1. Calculs automatiques efficacit√©
2. Corr√©lations m√©t√©o-r√©sultats
3. Recommandations timing optimales
4. Tests performance et cache

**Dur√©e totale estim√©e : 15 jours**