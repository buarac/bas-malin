# F2.6 - Optimisation Rendement

**Score Priorité :** 70/100  
**Statut :** PRIORITÉ MODÉRÉE  
**Epic :** EPIC 2 - PILIER PRODUIRE  
**Effort estimé :** 14 jours  

## Description

Système d'optimisation intelligent du rendement basé sur l'analyse de données historiques, modélisation prédictive IA et recommandations personnalisées pour maximiser la productivité du jardin selon les contraintes et objectifs de l'utilisateur.

## User Stories

### US2.6.1 - Analyse de Performance
**En tant qu'** expert jardinier  
**Je veux** analyser les performances de mes cultures  
**Afin d'** identifier les facteurs d'amélioration du rendement  

**Critères d'acceptation :**
- Calcul automatique du rendement par zone/variété/saison
- Comparaison avec standards de référence
- Identification des facteurs limitants (eau, nutrition, luminosité)
- Analyse de corrélation entre interventions et résultats
- Scoring de performance avec détail par critère

### US2.6.2 - Recommandations d'Optimisation
**En tant qu'** utilisateur occasionnel  
**Je veux** recevoir des conseils pour améliorer mon rendement  
**Afin d'** avoir un jardin plus productif sans expertise approfondie  

**Critères d'acceptation :**
- Suggestions d'amélioration personnalisées
- Plan d'action priorisé par impact/effort
- Estimation des gains de rendement potentiels
- Guides pratiques étape par étape
- Suivi de mise en œuvre des recommandations

### US2.6.3 - Modélisation Prédictive
**En tant qu'** planificateur de jardin  
**Je veux** prédire le rendement de mes futures plantations  
**Afin d'** optimiser l'allocation de l'espace et des ressources  

**Critères d'acceptation :**
- Prédiction rendement selon variété/zone/saison
- Simulation de scénarios d'optimisation
- Optimisation automatique de la rotation des cultures
- Calcul du retour sur investissement prévu
- Planning optimal des semis pour production continue

## Architecture Technique

### Service d'Optimisation

```typescript
// src/services/optimization/yield-optimization.service.ts
export interface YieldAnalysis {
  gardenId: string;
  period: DateRange;
  overallScore: number; // 0-100
  categories: YieldCategory[];
  benchmarks: YieldBenchmark[];
  trends: YieldTrend[];
  limitingFactors: LimitingFactor[];
}

export interface YieldCategory {
  name: string;
  score: number;
  metrics: YieldMetric[];
  recommendations: OptimizationRecommendation[];
}

export interface YieldMetric {
  name: string;
  value: number;
  unit: string;
  benchmark: number;
  status: 'excellent' | 'good' | 'average' | 'poor';
  trend: 'improving' | 'stable' | 'declining';
  impact: 'high' | 'medium' | 'low';
}

export interface OptimizationRecommendation {
  id: string;
  title: string;
  description: string;
  category: OptimizationCategory;
  priority: 'critical' | 'high' | 'medium' | 'low';
  effort: 'minimal' | 'moderate' | 'significant';
  impact: number; // Gain de rendement estimé en %
  cost: number; // Coût estimé
  roi: number; // Retour sur investissement
  actions: OptimizationAction[];
  timeline: string;
  prerequisites: string[];
}

export type OptimizationCategory = 
  | 'soil_nutrition'
  | 'water_management'
  | 'light_optimization'
  | 'plant_spacing'
  | 'variety_selection'
  | 'pest_control'
  | 'timing_optimization'
  | 'automation_setup';

export class YieldOptimizationService {
  private aiModelService: AIModelService;
  private benchmarkService: BenchmarkService;
  private predictionEngine: YieldPredictionEngine;

  constructor(
    private prisma: PrismaClient,
    private weatherService: WeatherService,
    private iotService: IoTService,
    private aiService: AIService
  ) {
    this.aiModelService = new AIModelService();
    this.benchmarkService = new BenchmarkService();
    this.predictionEngine = new YieldPredictionEngine();
  }

  async analyzeYieldPerformance(
    gardenId: string, 
    period: DateRange
  ): Promise<YieldAnalysis> {
    // Collecte des données de rendement
    const yieldData = await this.collectYieldData(gardenId, period);
    
    // Analyse comparative avec benchmarks
    const benchmarks = await this.benchmarkService.getBenchmarks(gardenId);
    
    // Calcul des métriques de performance
    const metrics = await this.calculateYieldMetrics(yieldData, benchmarks);
    
    // Identification des facteurs limitants
    const limitingFactors = await this.identifyLimitingFactors(gardenId, period);
    
    // Analyse des tendances
    const trends = await this.analyzeTrends(yieldData);
    
    // Scoring global
    const overallScore = this.calculateOverallScore(metrics);
    
    return {
      gardenId,
      period,
      overallScore,
      categories: this.groupMetricsByCategory(metrics),
      benchmarks,
      trends,
      limitingFactors
    };
  }

  private async collectYieldData(
    gardenId: string, 
    period: DateRange
  ): Promise<YieldDataCollection> {
    // Données de récolte
    const harvests = await this.prisma.recolte.findMany({
      where: {
        instanceCulture: {
          zone: { jardinId: gardenId }
        },
        dateRecolte: {
          gte: period.start,
          lte: period.end
        }
      },
      include: {
        instanceCulture: {
          include: {
            varieteCulture: true,
            zone: true
          }
        }
      }
    });

    // Données d'interventions
    const interventions = await this.prisma.intervention.findMany({
      where: {
        instanceCulture: {
          zone: { jardinId: gardenId }
        },
        dateIntervention: {
          gte: period.start,
          lte: period.end
        }
      }
    });

    // Données environnementales
    const environmentalData = await this.iotService.getHistoricalData(gardenId, period);
    
    // Données météo
    const weatherData = await this.weatherService.getHistoricalWeather(gardenId, period);

    return {
      harvests,
      interventions,
      environmentalData,
      weatherData,
      period
    };
  }

  private async calculateYieldMetrics(
    data: YieldDataCollection,
    benchmarks: YieldBenchmark[]
  ): Promise<YieldMetric[]> {
    const metrics: YieldMetric[] = [];

    // Rendement par m²
    const yieldPerArea = this.calculateYieldPerArea(data.harvests);
    metrics.push({
      name: 'Rendement par m²',
      value: yieldPerArea,
      unit: 'kg/m²',
      benchmark: benchmarks.find(b => b.metric === 'yield_per_area')?.value || 0,
      status: this.getMetricStatus(yieldPerArea, benchmarks),
      trend: this.calculateTrend('yield_per_area', data),
      impact: 'high'
    });

    // Efficacité de l'eau
    const waterEfficiency = this.calculateWaterEfficiency(data);
    metrics.push({
      name: 'Efficacité hydrique',
      value: waterEfficiency,
      unit: 'kg/L',
      benchmark: benchmarks.find(b => b.metric === 'water_efficiency')?.value || 0,
      status: this.getMetricStatus(waterEfficiency, benchmarks),
      trend: this.calculateTrend('water_efficiency', data),
      impact: 'high'
    });

    // Temps de croissance
    const growthTime = this.calculateAverageGrowthTime(data.harvests);
    metrics.push({
      name: 'Temps de croissance moyen',
      value: growthTime,
      unit: 'jours',
      benchmark: benchmarks.find(b => b.metric === 'growth_time')?.value || 0,
      status: this.getMetricStatus(growthTime, benchmarks, true), // Inverse: moins = mieux
      trend: this.calculateTrend('growth_time', data),
      impact: 'medium'
    });

    // Taux de réussite
    const successRate = this.calculateSuccessRate(data);
    metrics.push({
      name: 'Taux de réussite',
      value: successRate,
      unit: '%',
      benchmark: benchmarks.find(b => b.metric === 'success_rate')?.value || 80,
      status: this.getMetricStatus(successRate, benchmarks),
      trend: this.calculateTrend('success_rate', data),
      impact: 'high'
    });

    // Continuité de production
    const productionContinuity = this.calculateProductionContinuity(data.harvests);
    metrics.push({
      name: 'Continuité de production',
      value: productionContinuity,
      unit: 'jours/an',
      benchmark: benchmarks.find(b => b.metric === 'production_continuity')?.value || 200,
      status: this.getMetricStatus(productionContinuity, benchmarks),
      trend: this.calculateTrend('production_continuity', data),
      impact: 'medium'
    });

    return metrics;
  }

  async generateOptimizationRecommendations(
    analysis: YieldAnalysis
  ): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    // Analyse avec IA pour recommandations personnalisées
    const aiRecommendations = await this.aiService.generateOptimizationRecommendations({
      analysis,
      gardenContext: await this.getGardenContext(analysis.gardenId),
      userPreferences: await this.getUserPreferences(analysis.gardenId)
    });

    // Recommandations basées sur facteurs limitants
    for (const factor of analysis.limitingFactors) {
      const factorRecommendations = await this.generateFactorRecommendations(factor);
      recommendations.push(...factorRecommendations);
    }

    // Recommandations basées sur benchmarks
    for (const category of analysis.categories) {
      const lowPerformingMetrics = category.metrics.filter(m => m.status === 'poor' || m.status === 'average');
      
      for (const metric of lowPerformingMetrics) {
        const metricRecommendations = await this.generateMetricRecommendations(metric, category);
        recommendations.push(...metricRecommendations);
      }
    }

    // Fusion et priorisation
    const mergedRecommendations = this.mergeAndPrioritizeRecommendations([
      ...aiRecommendations,
      ...recommendations
    ]);

    // Calcul ROI et effort
    const enrichedRecommendations = await this.enrichRecommendationsWithROI(mergedRecommendations);

    return enrichedRecommendations.sort((a, b) => b.roi - a.roi);
  }

  private async generateFactorRecommendations(
    factor: LimitingFactor
  ): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    switch (factor.type) {
      case 'water_stress':
        recommendations.push({
          id: generateId(),
          title: 'Optimiser l\'irrigation',
          description: 'Installation d\'un système d\'arrosage automatique avec capteurs d\'humidité',
          category: 'water_management',
          priority: 'high',
          effort: 'moderate',
          impact: 25, // +25% de rendement estimé
          cost: 200,
          roi: 3.5,
          actions: [
            {
              id: 'install_moisture_sensors',
              title: 'Installer capteurs d\'humidité sol',
              description: 'Placement stratégique de 3-4 capteurs dans les zones critiques',
              estimatedTime: '2h',
              materials: ['Capteurs ESP32', 'Sondes d\'humidité', 'Boîtiers étanches'],
              cost: 80
            },
            {
              id: 'setup_automated_irrigation',
              title: 'Configurer arrosage automatique',
              description: 'Mise en place du système avec programmation intelligente',
              estimatedTime: '4h',
              materials: ['Électrovannes', 'Tuyaux goutte-à-goutte', 'Contrôleur'],
              cost: 120
            }
          ],
          timeline: '1 week',
          prerequisites: ['Accès à l\'eau', 'Alimentation électrique']
        });
        break;

      case 'nutrient_deficiency':
        recommendations.push({
          id: generateId(),
          title: 'Programme de fertilisation optimisé',
          description: 'Plan de fertilisation basé sur les analyses de sol et besoins spécifiques',
          category: 'soil_nutrition',
          priority: 'high',
          effort: 'minimal',
          impact: 20,
          cost: 50,
          roi: 6.0,
          actions: [
            {
              id: 'soil_analysis',
              title: 'Analyse complète du sol',
              description: 'Test NPK, pH, matière organique et oligoéléments',
              estimatedTime: '30min',
              cost: 25
            },
            {
              id: 'fertilization_plan',
              title: 'Appliquer plan de fertilisation',
              description: 'Programme personnalisé selon les déficiences identifiées',
              estimatedTime: '1h/mois',
              cost: 25
            }
          ],
          timeline: '2 weeks',
          prerequisites: ['Identification des déficiences']
        });
        break;

      case 'poor_spacing':
        recommendations.push({
          id: generateId(),
          title: 'Optimiser l\'espacement des plants',
          description: 'Réorganisation pour maximiser l\'utilisation de l\'espace et la luminosité',
          category: 'plant_spacing',
          priority: 'medium',
          effort: 'moderate',
          impact: 15,
          cost: 0,
          roi: Infinity, // Pas de coût, que du bénéfice
          actions: [
            {
              id: 'spacing_audit',
              title: 'Audit espacement actuel',
              description: 'Mesure et documentation des espacements actuels',
              estimatedTime: '1h',
              cost: 0
            },
            {
              id: 'replant_optimization',
              title: 'Réorganiser les plantations',
              description: 'Appliquer les espacements optimaux lors du prochain cycle',
              estimatedTime: '3h',
              cost: 0
            }
          ],
          timeline: 'Next planting cycle',
          prerequisites: ['Fin du cycle actuel']
        });
        break;
    }

    return recommendations;
  }

  async predictYield(
    gardenId: string,
    scenario: OptimizationScenario
  ): Promise<YieldPrediction> {
    // Collecte des données historiques
    const historicalData = await this.collectHistoricalDataForPrediction(gardenId);
    
    // Application du scénario aux données
    const modifiedData = this.applyScenarioToData(historicalData, scenario);
    
    // Prédiction avec modèle IA
    const prediction = await this.predictionEngine.predict(modifiedData);
    
    // Calcul des intervalles de confiance
    const confidenceIntervals = this.calculateConfidenceIntervals(prediction);
    
    return {
      baselineYield: historicalData.averageYield,
      predictedYield: prediction.value,
      improvement: prediction.value - historicalData.averageYield,
      improvementPercentage: ((prediction.value - historicalData.averageYield) / historicalData.averageYield) * 100,
      confidence: prediction.confidence,
      confidenceIntervals,
      factors: prediction.contributingFactors,
      timeline: scenario.timeline
    };
  }
}
```

### Moteur de Prédiction

```typescript
// src/services/optimization/yield-prediction-engine.ts
export class YieldPredictionEngine {
  private models: Map<string, PredictionModel> = new Map();

  constructor(private aiService: AIService) {
    this.initializeModels();
  }

  private initializeModels(): void {
    // Modèle pour légumes feuilles
    this.models.set('leafy_greens', {
      type: 'ensemble',
      features: [
        'temperature_avg', 'humidity_avg', 'light_hours',
        'water_frequency', 'nutrients_npk', 'plant_density',
        'growth_days', 'season', 'variety_vigor'
      ],
      weights: {
        temperature_avg: 0.25,
        light_hours: 0.20,
        nutrients_npk: 0.18,
        water_frequency: 0.15,
        plant_density: 0.12,
        humidity_avg: 0.05,
        growth_days: 0.03,
        season: 0.02
      }
    });

    // Modèle pour légumes fruits
    this.models.set('fruiting_vegetables', {
      type: 'ensemble',
      features: [
        'temperature_range', 'pollination_rate', 'water_consistency',
        'nutrients_balance', 'support_structure', 'pruning_frequency',
        'disease_pressure', 'harvest_timing'
      ],
      weights: {
        temperature_range: 0.22,
        pollination_rate: 0.20,
        nutrients_balance: 0.18,
        water_consistency: 0.15,
        support_structure: 0.10,
        pruning_frequency: 0.08,
        disease_pressure: 0.04,
        harvest_timing: 0.03
      }
    });

    // Modèle pour légumes racines
    this.models.set('root_vegetables', {
      type: 'ensemble',
      features: [
        'soil_structure', 'soil_depth', 'drainage', 'organic_matter',
        'compaction_level', 'temperature_soil', 'moisture_consistency'
      ],
      weights: {
        soil_structure: 0.28,
        soil_depth: 0.22,
        drainage: 0.18,
        organic_matter: 0.15,
        compaction_level: 0.10,
        temperature_soil: 0.04,
        moisture_consistency: 0.03
      }
    });
  }

  async predict(data: ModifiedHistoricalData): Promise<PredictionResult> {
    const predictions: ModelPrediction[] = [];
    
    // Prédiction par modèle selon type de culture
    for (const [cropType, instances] of Object.entries(data.cropInstances)) {
      const model = this.models.get(cropType);
      if (!model) continue;

      const features = this.extractFeatures(instances, model.features);
      const prediction = await this.runModelPrediction(model, features);
      
      predictions.push({
        cropType,
        prediction: prediction.value,
        confidence: prediction.confidence,
        contributingFactors: this.analyzeContributingFactors(prediction, model)
      });
    }

    // Agrégation des prédictions
    const aggregatedPrediction = this.aggregatePredictions(predictions, data.cropDistribution);
    
    // Validation avec modèle IA externe
    const aiValidation = await this.aiService.validateYieldPrediction({
      prediction: aggregatedPrediction,
      historicalData: data.historical,
      scenario: data.scenario
    });

    return {
      value: aggregatedPrediction.value,
      confidence: Math.min(aggregatedPrediction.confidence, aiValidation.confidence),
      contributingFactors: this.mergeContributingFactors(
        aggregatedPrediction.factors, 
        aiValidation.factors
      ),
      modelAccuracy: this.calculateModelAccuracy(data.historical),
      validationNotes: aiValidation.notes
    };
  }

  private extractFeatures(instances: CropInstance[], featureNames: string[]): FeatureVector {
    const features: FeatureVector = {};

    for (const featureName of featureNames) {
      switch (featureName) {
        case 'temperature_avg':
          features[featureName] = this.calculateAverageTemperature(instances);
          break;
        case 'light_hours':
          features[featureName] = this.calculateAverageLightHours(instances);
          break;
        case 'water_frequency':
          features[featureName] = this.calculateWaterFrequency(instances);
          break;
        case 'plant_density':
          features[featureName] = this.calculatePlantDensity(instances);
          break;
        case 'nutrients_npk':
          features[featureName] = this.calculateNutrientScore(instances);
          break;
        // ... autres features
      }
    }

    return features;
  }

  private async runModelPrediction(
    model: PredictionModel,
    features: FeatureVector
  ): Promise<ModelPredictionResult> {
    // Normalisation des features
    const normalizedFeatures = this.normalizeFeatures(features, model);
    
    // Calcul de la prédiction pondérée
    let prediction = 0;
    let totalWeight = 0;

    for (const [feature, value] of Object.entries(normalizedFeatures)) {
      const weight = model.weights[feature] || 0;
      prediction += value * weight;
      totalWeight += weight;
    }

    // Normalisation finale
    prediction = prediction / totalWeight;

    // Calcul de la confiance basé sur la complétude des données
    const confidence = this.calculateConfidence(features, model);

    // Application de facteurs correctifs
    const correctedPrediction = this.applyCorrectiveFactors(prediction, features);

    return {
      value: correctedPrediction,
      confidence,
      rawPrediction: prediction,
      features: normalizedFeatures
    };
  }

  private calculateConfidence(features: FeatureVector, model: PredictionModel): number {
    // Confiance basée sur:
    // 1. Complétude des données (% de features disponibles)
    const completeness = Object.keys(features).length / model.features.length;
    
    // 2. Qualité des données (pas de valeurs aberrantes)
    const dataQuality = this.assessDataQuality(features);
    
    // 3. Similarité avec données d'entraînement
    const similarity = this.calculateSimilarityToTrainingData(features);

    return Math.min(completeness * 0.4 + dataQuality * 0.3 + similarity * 0.3, 1.0);
  }
}
```

### Interface d'Optimisation

```typescript
// src/app/optimization/page.tsx
export default function YieldOptimizationPage() {
  const [analysis, setAnalysis] = useState<YieldAnalysis | null>(null);
  const [recommendations, setRecommendations] = useState<OptimizationRecommendation[]>([]);
  const [selectedPeriod, setSelectedPeriod] = useState<DateRange>({
    start: new Date(Date.now() - 365*24*60*60*1000),
    end: new Date()
  });
  const [loading, setLoading] = useState(false);

  const runOptimizationAnalysis = async () => {
    setLoading(true);
    try {
      const result = await yieldOptimizationService.analyzeYieldPerformance(
        'current-garden', 
        selectedPeriod
      );
      setAnalysis(result);
      
      const recs = await yieldOptimizationService.generateOptimizationRecommendations(result);
      setRecommendations(recs);
    } catch (error) {
      console.error('Optimization analysis failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold">Optimisation du Rendement</h1>
            <p className="text-gray-600 mt-1">
              Analysez et optimisez les performances de votre jardin
            </p>
          </div>
          
          <div className="flex items-center space-x-4">
            <PeriodSelector value={selectedPeriod} onChange={setSelectedPeriod} />
            <Button 
              onClick={runOptimizationAnalysis}
              disabled={loading}
              leftIcon={loading ? <Loader2Icon className="animate-spin" /> : <AnalyticsIcon />}
            >
              {loading ? 'Analyse...' : 'Analyser'}
            </Button>
          </div>
        </div>

        {analysis && (
          <div className="space-y-8">
            {/* Score global */}
            <Card className="p-6">
              <div className="flex items-center justify-between mb-6">
                <div>
                  <h2 className="text-xl font-semibold">Performance Globale</h2>
                  <p className="text-gray-600">Score basé sur tous les indicateurs clés</p>
                </div>
                <div className="text-right">
                  <div className="text-4xl font-bold text-green-600">
                    {analysis.overallScore}/100
                  </div>
                  <div className="text-sm text-gray-500">
                    {getScoreLabel(analysis.overallScore)}
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                {analysis.categories.map(category => (
                  <div key={category.name} className="text-center p-4 bg-gray-50 rounded-lg">
                    <div className="text-2xl font-semibold">{category.score}</div>
                    <div className="text-sm text-gray-600">{category.name}</div>
                  </div>
                ))}
              </div>
            </Card>

            {/* Métriques détaillées */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {analysis.categories.map(category => (
                <MetricsCategoryCard key={category.name} category={category} />
              ))}
            </div>

            {/* Facteurs limitants */}
            {analysis.limitingFactors.length > 0 && (
              <Card className="p-6">
                <h3 className="text-lg font-semibold mb-4">Facteurs Limitants Identifiés</h3>
                <div className="space-y-3">
                  {analysis.limitingFactors.map((factor, index) => (
                    <LimitingFactorCard key={index} factor={factor} />
                  ))}
                </div>
              </Card>
            )}

            {/* Recommandations */}
            <Card className="p-6">
              <h3 className="text-lg font-semibold mb-4">
                Recommandations d'Optimisation ({recommendations.length})
              </h3>
              <div className="space-y-4">
                {recommendations.slice(0, 5).map(recommendation => (
                  <RecommendationCard 
                    key={recommendation.id} 
                    recommendation={recommendation}
                    onImplement={(id) => console.log('Implement:', id)}
                  />
                ))}
              </div>
              
              {recommendations.length > 5 && (
                <Button variant="outline" className="mt-4">
                  Voir toutes les recommandations ({recommendations.length - 5} autres)
                </Button>
              )}
            </Card>
          </div>
        )}
      </div>
    </div>
  );
}

const MetricsCategoryCard = ({ category }: { category: YieldCategory }) => {
  return (
    <Card className="p-6">
      <div className="flex justify-between items-center mb-4">
        <h3 className="font-semibold">{category.name}</h3>
        <Badge variant={getScoreVariant(category.score)}>
          {category.score}/100
        </Badge>
      </div>
      
      <div className="space-y-3">
        {category.metrics.map(metric => (
          <div key={metric.name} className="flex justify-between items-center">
            <div className="flex-1">
              <div className="flex items-center">
                <span className="text-sm font-medium">{metric.name}</span>
                <TrendIcon trend={metric.trend} className="ml-2 w-4 h-4" />
              </div>
              <div className="text-xs text-gray-500">
                vs benchmark: {metric.benchmark} {metric.unit}
              </div>
            </div>
            <div className="text-right">
              <div className="font-semibold">
                {metric.value.toFixed(1)} {metric.unit}
              </div>
              <Badge size="sm" variant={getStatusVariant(metric.status)}>
                {metric.status}
              </Badge>
            </div>
          </div>
        ))}
      </div>
    </Card>
  );
};

const RecommendationCard = ({ recommendation, onImplement }: {
  recommendation: OptimizationRecommendation;
  onImplement: (id: string) => void;
}) => {
  const [expanded, setExpanded] = useState(false);

  return (
    <Card className="p-4 border-l-4 border-l-blue-500">
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <h4 className="font-semibold">{recommendation.title}</h4>
            <Badge variant={getPriorityVariant(recommendation.priority)}>
              {recommendation.priority}
            </Badge>
            <Badge variant="outline">
              +{recommendation.impact}% rendement
            </Badge>
            <Badge variant="secondary">
              ROI: {recommendation.roi.toFixed(1)}x
            </Badge>
          </div>
          
          <p className="text-sm text-gray-600 mb-3">
            {recommendation.description}
          </p>
          
          <div className="flex items-center gap-4 text-xs text-gray-500">
            <span>⏱️ {recommendation.timeline}</span>
            <span>💪 Effort: {recommendation.effort}</span>
            <span>💰 Coût: {recommendation.cost}€</span>
          </div>
        </div>
        
        <div className="flex gap-2 ml-4">
          <Button
            size="sm"
            variant="outline"
            onClick={() => setExpanded(!expanded)}
          >
            {expanded ? 'Réduire' : 'Détails'}
          </Button>
          <Button
            size="sm"
            onClick={() => onImplement(recommendation.id)}
          >
            Implémenter
          </Button>
        </div>
      </div>

      {expanded && (
        <div className="mt-4 pt-4 border-t">
          <h5 className="font-medium mb-2">Plan d'action:</h5>
          <div className="space-y-2">
            {recommendation.actions.map((action, index) => (
              <div key={action.id} className="flex items-start space-x-3 text-sm">
                <div className="flex-shrink-0 w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center text-xs font-medium">
                  {index + 1}
                </div>
                <div className="flex-1">
                  <div className="font-medium">{action.title}</div>
                  <div className="text-gray-600">{action.description}</div>
                  <div className="text-xs text-gray-500 mt-1">
                    Temps estimé: {action.estimatedTime} • Coût: {action.cost}€
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </Card>
  );
};
```

## API Routes

```typescript
// src/app/api/optimization/analyze/route.ts
export async function POST(request: Request) {
  try {
    const { gardenId, period } = await request.json();
    
    const analysis = await yieldOptimizationService.analyzeYieldPerformance(
      gardenId,
      {
        start: new Date(period.start),
        end: new Date(period.end)
      }
    );

    return NextResponse.json(analysis);

  } catch (error) {
    console.error('Yield analysis failed:', error);
    return NextResponse.json(
      { error: 'Analysis failed' },
      { status: 500 }
    );
  }
}

// src/app/api/optimization/recommendations/route.ts
export async function POST(request: Request) {
  try {
    const { analysis } = await request.json();
    
    const recommendations = await yieldOptimizationService.generateOptimizationRecommendations(analysis);

    return NextResponse.json({ recommendations });

  } catch (error) {
    console.error('Recommendations generation failed:', error);
    return NextResponse.json(
      { error: 'Recommendations generation failed' },
      { status: 500 }
    );
  }
}

// src/app/api/optimization/predict/route.ts
export async function POST(request: Request) {
  try {
    const { gardenId, scenario } = await request.json();
    
    const prediction = await yieldOptimizationService.predictYield(gardenId, scenario);

    return NextResponse.json(prediction);

  } catch (error) {
    console.error('Yield prediction failed:', error);
    return NextResponse.json(
      { error: 'Prediction failed' },
      { status: 500 }
    );
  }
}
```

## Critères d'Acceptation Techniques

### Analyse de Performance
- [ ] Calcul de 10+ métriques de rendement
- [ ] Comparaison avec benchmarks régionaux
- [ ] Identification automatique facteurs limitants
- [ ] Analyse de tendances sur 2+ ans de données

### Recommandations
- [ ] Score ROI calculé pour chaque recommandation
- [ ] Priorisation multicritères (impact/effort/coût)
- [ ] Plans d'action détaillés avec timeline
- [ ] Personnalisation selon profil utilisateur

### Prédictions
- [ ] Précision > 80% sur données de test
- [ ] Intervalles de confiance calibrés
- [ ] Simulation de scénarios d'optimisation
- [ ] Validation croisée avec données réelles

## Couverture Exigences Architecture

- **EXG-005.1** : IA pour analyse et recommandations
- **EXG-005.2** : Modèles prédictifs de rendement
- **EXG-002.1** : Requêtes analytiques optimisées
- **EXG-003.1** : Interface responsive d'analyse
- **EXG-009.1** : Métriques de performance suivies

## Tests d'Acceptation

```typescript
// tests/integration/yield-optimization.test.ts
describe('Yield Optimization', () => {
  test('analyse de performance calcule métriques correctement', async () => {
    const gardenData = createTestGardenData();
    
    const analysis = await yieldOptimizationService.analyzeYieldPerformance(
      gardenData.id,
      { start: new Date('2024-01-01'), end: new Date('2024-12-31') }
    );
    
    expect(analysis.overallScore).toBeGreaterThan(0);
    expect(analysis.categories).toHaveLength(greaterThan(3));
    expect(analysis.limitingFactors).toBeDefined();
  });

  test('recommandations incluent ROI calculé', async () => {
    const analysis = createTestAnalysis();
    
    const recommendations = await yieldOptimizationService.generateOptimizationRecommendations(analysis);
    
    recommendations.forEach(rec => {
      expect(rec.roi).toBeGreaterThan(0);
      expect(rec.impact).toBeGreaterThan(0);
      expect(rec.actions).toHaveLength(greaterThan(0));
    });
  });

  test('prédiction de rendement fonctionne', async () => {
    const scenario = createOptimizationScenario();
    
    const prediction = await yieldOptimizationService.predictYield('test-garden', scenario);
    
    expect(prediction.predictedYield).toBeGreaterThan(prediction.baselineYield);
    expect(prediction.confidence).toBeGreaterThan(0.6);
    expect(prediction.improvementPercentage).toBeGreaterThan(0);
  });
});
```

Cette spécification couvre un système complet d'optimisation du rendement avec analyse de performance, recommandations intelligentes et prédictions basées sur l'IA pour maximiser la productivité du jardin.