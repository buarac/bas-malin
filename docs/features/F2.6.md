# F2.6 - Optimisation Rendement

**Score Priorit√© :** 70/100  
**Statut :** PRIORIT√â MOD√âR√âE  
**Epic :** EPIC 2 - PILIER PRODUIRE  
**Effort estim√© :** 14 jours  

## Description

Syst√®me d'optimisation intelligent du rendement bas√© sur l'analyse de donn√©es historiques, mod√©lisation pr√©dictive IA et recommandations personnalis√©es pour maximiser la productivit√© du jardin selon les contraintes et objectifs de l'utilisateur.

## User Stories

### US2.6.1 - Analyse de Performance
**En tant qu'** expert jardinier  
**Je veux** analyser les performances de mes cultures  
**Afin d'** identifier les facteurs d'am√©lioration du rendement  

**Crit√®res d'acceptation :**
- Calcul automatique du rendement par zone/vari√©t√©/saison
- Comparaison avec standards de r√©f√©rence
- Identification des facteurs limitants (eau, nutrition, luminosit√©)
- Analyse de corr√©lation entre interventions et r√©sultats
- Scoring de performance avec d√©tail par crit√®re

### US2.6.2 - Recommandations d'Optimisation
**En tant qu'** utilisateur occasionnel  
**Je veux** recevoir des conseils pour am√©liorer mon rendement  
**Afin d'** avoir un jardin plus productif sans expertise approfondie  

**Crit√®res d'acceptation :**
- Suggestions d'am√©lioration personnalis√©es
- Plan d'action prioris√© par impact/effort
- Estimation des gains de rendement potentiels
- Guides pratiques √©tape par √©tape
- Suivi de mise en ≈ìuvre des recommandations

### US2.6.3 - Mod√©lisation Pr√©dictive
**En tant qu'** planificateur de jardin  
**Je veux** pr√©dire le rendement de mes futures plantations  
**Afin d'** optimiser l'allocation de l'espace et des ressources  

**Crit√®res d'acceptation :**
- Pr√©diction rendement selon vari√©t√©/zone/saison
- Simulation de sc√©narios d'optimisation
- Optimisation automatique de la rotation des cultures
- Calcul du retour sur investissement pr√©vu
- Planning optimal des semis pour production continue

## Architecture Technique

### Service d'Optimisation

```typescript
// src/services/optimization/yield-optimization.service.ts
export interface YieldAnalysis {
  gardenId: string;
  period: DateRange;
  overallScore: number; // 0-100
  categories: YieldCategory[];
  benchmarks: YieldBenchmark[];
  trends: YieldTrend[];
  limitingFactors: LimitingFactor[];
}

export interface YieldCategory {
  name: string;
  score: number;
  metrics: YieldMetric[];
  recommendations: OptimizationRecommendation[];
}

export interface YieldMetric {
  name: string;
  value: number;
  unit: string;
  benchmark: number;
  status: 'excellent' | 'good' | 'average' | 'poor';
  trend: 'improving' | 'stable' | 'declining';
  impact: 'high' | 'medium' | 'low';
}

export interface OptimizationRecommendation {
  id: string;
  title: string;
  description: string;
  category: OptimizationCategory;
  priority: 'critical' | 'high' | 'medium' | 'low';
  effort: 'minimal' | 'moderate' | 'significant';
  impact: number; // Gain de rendement estim√© en %
  cost: number; // Co√ªt estim√©
  roi: number; // Retour sur investissement
  actions: OptimizationAction[];
  timeline: string;
  prerequisites: string[];
}

export type OptimizationCategory = 
  | 'soil_nutrition'
  | 'water_management'
  | 'light_optimization'
  | 'plant_spacing'
  | 'variety_selection'
  | 'pest_control'
  | 'timing_optimization'
  | 'automation_setup';

export class YieldOptimizationService {
  private aiModelService: AIModelService;
  private benchmarkService: BenchmarkService;
  private predictionEngine: YieldPredictionEngine;

  constructor(
    private prisma: PrismaClient,
    private weatherService: WeatherService,
    private iotService: IoTService,
    private aiService: AIService
  ) {
    this.aiModelService = new AIModelService();
    this.benchmarkService = new BenchmarkService();
    this.predictionEngine = new YieldPredictionEngine();
  }

  async analyzeYieldPerformance(
    gardenId: string, 
    period: DateRange
  ): Promise<YieldAnalysis> {
    // Collecte des donn√©es de rendement
    const yieldData = await this.collectYieldData(gardenId, period);
    
    // Analyse comparative avec benchmarks
    const benchmarks = await this.benchmarkService.getBenchmarks(gardenId);
    
    // Calcul des m√©triques de performance
    const metrics = await this.calculateYieldMetrics(yieldData, benchmarks);
    
    // Identification des facteurs limitants
    const limitingFactors = await this.identifyLimitingFactors(gardenId, period);
    
    // Analyse des tendances
    const trends = await this.analyzeTrends(yieldData);
    
    // Scoring global
    const overallScore = this.calculateOverallScore(metrics);
    
    return {
      gardenId,
      period,
      overallScore,
      categories: this.groupMetricsByCategory(metrics),
      benchmarks,
      trends,
      limitingFactors
    };
  }

  private async collectYieldData(
    gardenId: string, 
    period: DateRange
  ): Promise<YieldDataCollection> {
    // Donn√©es de r√©colte
    const harvests = await this.prisma.recolte.findMany({
      where: {
        instanceCulture: {
          zone: { jardinId: gardenId }
        },
        dateRecolte: {
          gte: period.start,
          lte: period.end
        }
      },
      include: {
        instanceCulture: {
          include: {
            varieteCulture: true,
            zone: true
          }
        }
      }
    });

    // Donn√©es d'interventions
    const interventions = await this.prisma.intervention.findMany({
      where: {
        instanceCulture: {
          zone: { jardinId: gardenId }
        },
        dateIntervention: {
          gte: period.start,
          lte: period.end
        }
      }
    });

    // Donn√©es environnementales
    const environmentalData = await this.iotService.getHistoricalData(gardenId, period);
    
    // Donn√©es m√©t√©o
    const weatherData = await this.weatherService.getHistoricalWeather(gardenId, period);

    return {
      harvests,
      interventions,
      environmentalData,
      weatherData,
      period
    };
  }

  private async calculateYieldMetrics(
    data: YieldDataCollection,
    benchmarks: YieldBenchmark[]
  ): Promise<YieldMetric[]> {
    const metrics: YieldMetric[] = [];

    // Rendement par m¬≤
    const yieldPerArea = this.calculateYieldPerArea(data.harvests);
    metrics.push({
      name: 'Rendement par m¬≤',
      value: yieldPerArea,
      unit: 'kg/m¬≤',
      benchmark: benchmarks.find(b => b.metric === 'yield_per_area')?.value || 0,
      status: this.getMetricStatus(yieldPerArea, benchmarks),
      trend: this.calculateTrend('yield_per_area', data),
      impact: 'high'
    });

    // Efficacit√© de l'eau
    const waterEfficiency = this.calculateWaterEfficiency(data);
    metrics.push({
      name: 'Efficacit√© hydrique',
      value: waterEfficiency,
      unit: 'kg/L',
      benchmark: benchmarks.find(b => b.metric === 'water_efficiency')?.value || 0,
      status: this.getMetricStatus(waterEfficiency, benchmarks),
      trend: this.calculateTrend('water_efficiency', data),
      impact: 'high'
    });

    // Temps de croissance
    const growthTime = this.calculateAverageGrowthTime(data.harvests);
    metrics.push({
      name: 'Temps de croissance moyen',
      value: growthTime,
      unit: 'jours',
      benchmark: benchmarks.find(b => b.metric === 'growth_time')?.value || 0,
      status: this.getMetricStatus(growthTime, benchmarks, true), // Inverse: moins = mieux
      trend: this.calculateTrend('growth_time', data),
      impact: 'medium'
    });

    // Taux de r√©ussite
    const successRate = this.calculateSuccessRate(data);
    metrics.push({
      name: 'Taux de r√©ussite',
      value: successRate,
      unit: '%',
      benchmark: benchmarks.find(b => b.metric === 'success_rate')?.value || 80,
      status: this.getMetricStatus(successRate, benchmarks),
      trend: this.calculateTrend('success_rate', data),
      impact: 'high'
    });

    // Continuit√© de production
    const productionContinuity = this.calculateProductionContinuity(data.harvests);
    metrics.push({
      name: 'Continuit√© de production',
      value: productionContinuity,
      unit: 'jours/an',
      benchmark: benchmarks.find(b => b.metric === 'production_continuity')?.value || 200,
      status: this.getMetricStatus(productionContinuity, benchmarks),
      trend: this.calculateTrend('production_continuity', data),
      impact: 'medium'
    });

    return metrics;
  }

  async generateOptimizationRecommendations(
    analysis: YieldAnalysis
  ): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    // Analyse avec IA pour recommandations personnalis√©es
    const aiRecommendations = await this.aiService.generateOptimizationRecommendations({
      analysis,
      gardenContext: await this.getGardenContext(analysis.gardenId),
      userPreferences: await this.getUserPreferences(analysis.gardenId)
    });

    // Recommandations bas√©es sur facteurs limitants
    for (const factor of analysis.limitingFactors) {
      const factorRecommendations = await this.generateFactorRecommendations(factor);
      recommendations.push(...factorRecommendations);
    }

    // Recommandations bas√©es sur benchmarks
    for (const category of analysis.categories) {
      const lowPerformingMetrics = category.metrics.filter(m => m.status === 'poor' || m.status === 'average');
      
      for (const metric of lowPerformingMetrics) {
        const metricRecommendations = await this.generateMetricRecommendations(metric, category);
        recommendations.push(...metricRecommendations);
      }
    }

    // Fusion et priorisation
    const mergedRecommendations = this.mergeAndPrioritizeRecommendations([
      ...aiRecommendations,
      ...recommendations
    ]);

    // Calcul ROI et effort
    const enrichedRecommendations = await this.enrichRecommendationsWithROI(mergedRecommendations);

    return enrichedRecommendations.sort((a, b) => b.roi - a.roi);
  }

  private async generateFactorRecommendations(
    factor: LimitingFactor
  ): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    switch (factor.type) {
      case 'water_stress':
        recommendations.push({
          id: generateId(),
          title: 'Optimiser l\'irrigation',
          description: 'Installation d\'un syst√®me d\'arrosage automatique avec capteurs d\'humidit√©',
          category: 'water_management',
          priority: 'high',
          effort: 'moderate',
          impact: 25, // +25% de rendement estim√©
          cost: 200,
          roi: 3.5,
          actions: [
            {
              id: 'install_moisture_sensors',
              title: 'Installer capteurs d\'humidit√© sol',
              description: 'Placement strat√©gique de 3-4 capteurs dans les zones critiques',
              estimatedTime: '2h',
              materials: ['Capteurs ESP32', 'Sondes d\'humidit√©', 'Bo√Ætiers √©tanches'],
              cost: 80
            },
            {
              id: 'setup_automated_irrigation',
              title: 'Configurer arrosage automatique',
              description: 'Mise en place du syst√®me avec programmation intelligente',
              estimatedTime: '4h',
              materials: ['√âlectrovannes', 'Tuyaux goutte-√†-goutte', 'Contr√¥leur'],
              cost: 120
            }
          ],
          timeline: '1 week',
          prerequisites: ['Acc√®s √† l\'eau', 'Alimentation √©lectrique']
        });
        break;

      case 'nutrient_deficiency':
        recommendations.push({
          id: generateId(),
          title: 'Programme de fertilisation optimis√©',
          description: 'Plan de fertilisation bas√© sur les analyses de sol et besoins sp√©cifiques',
          category: 'soil_nutrition',
          priority: 'high',
          effort: 'minimal',
          impact: 20,
          cost: 50,
          roi: 6.0,
          actions: [
            {
              id: 'soil_analysis',
              title: 'Analyse compl√®te du sol',
              description: 'Test NPK, pH, mati√®re organique et oligo√©l√©ments',
              estimatedTime: '30min',
              cost: 25
            },
            {
              id: 'fertilization_plan',
              title: 'Appliquer plan de fertilisation',
              description: 'Programme personnalis√© selon les d√©ficiences identifi√©es',
              estimatedTime: '1h/mois',
              cost: 25
            }
          ],
          timeline: '2 weeks',
          prerequisites: ['Identification des d√©ficiences']
        });
        break;

      case 'poor_spacing':
        recommendations.push({
          id: generateId(),
          title: 'Optimiser l\'espacement des plants',
          description: 'R√©organisation pour maximiser l\'utilisation de l\'espace et la luminosit√©',
          category: 'plant_spacing',
          priority: 'medium',
          effort: 'moderate',
          impact: 15,
          cost: 0,
          roi: Infinity, // Pas de co√ªt, que du b√©n√©fice
          actions: [
            {
              id: 'spacing_audit',
              title: 'Audit espacement actuel',
              description: 'Mesure et documentation des espacements actuels',
              estimatedTime: '1h',
              cost: 0
            },
            {
              id: 'replant_optimization',
              title: 'R√©organiser les plantations',
              description: 'Appliquer les espacements optimaux lors du prochain cycle',
              estimatedTime: '3h',
              cost: 0
            }
          ],
          timeline: 'Next planting cycle',
          prerequisites: ['Fin du cycle actuel']
        });
        break;
    }

    return recommendations;
  }

  async predictYield(
    gardenId: string,
    scenario: OptimizationScenario
  ): Promise<YieldPrediction> {
    // Collecte des donn√©es historiques
    const historicalData = await this.collectHistoricalDataForPrediction(gardenId);
    
    // Application du sc√©nario aux donn√©es
    const modifiedData = this.applyScenarioToData(historicalData, scenario);
    
    // Pr√©diction avec mod√®le IA
    const prediction = await this.predictionEngine.predict(modifiedData);
    
    // Calcul des intervalles de confiance
    const confidenceIntervals = this.calculateConfidenceIntervals(prediction);
    
    return {
      baselineYield: historicalData.averageYield,
      predictedYield: prediction.value,
      improvement: prediction.value - historicalData.averageYield,
      improvementPercentage: ((prediction.value - historicalData.averageYield) / historicalData.averageYield) * 100,
      confidence: prediction.confidence,
      confidenceIntervals,
      factors: prediction.contributingFactors,
      timeline: scenario.timeline
    };
  }
}
```

### Moteur de Pr√©diction

```typescript
// src/services/optimization/yield-prediction-engine.ts
export class YieldPredictionEngine {
  private models: Map<string, PredictionModel> = new Map();

  constructor(private aiService: AIService) {
    this.initializeModels();
  }

  private initializeModels(): void {
    // Mod√®le pour l√©gumes feuilles
    this.models.set('leafy_greens', {
      type: 'ensemble',
      features: [
        'temperature_avg', 'humidity_avg', 'light_hours',
        'water_frequency', 'nutrients_npk', 'plant_density',
        'growth_days', 'season', 'variety_vigor'
      ],
      weights: {
        temperature_avg: 0.25,
        light_hours: 0.20,
        nutrients_npk: 0.18,
        water_frequency: 0.15,
        plant_density: 0.12,
        humidity_avg: 0.05,
        growth_days: 0.03,
        season: 0.02
      }
    });

    // Mod√®le pour l√©gumes fruits
    this.models.set('fruiting_vegetables', {
      type: 'ensemble',
      features: [
        'temperature_range', 'pollination_rate', 'water_consistency',
        'nutrients_balance', 'support_structure', 'pruning_frequency',
        'disease_pressure', 'harvest_timing'
      ],
      weights: {
        temperature_range: 0.22,
        pollination_rate: 0.20,
        nutrients_balance: 0.18,
        water_consistency: 0.15,
        support_structure: 0.10,
        pruning_frequency: 0.08,
        disease_pressure: 0.04,
        harvest_timing: 0.03
      }
    });

    // Mod√®le pour l√©gumes racines
    this.models.set('root_vegetables', {
      type: 'ensemble',
      features: [
        'soil_structure', 'soil_depth', 'drainage', 'organic_matter',
        'compaction_level', 'temperature_soil', 'moisture_consistency'
      ],
      weights: {
        soil_structure: 0.28,
        soil_depth: 0.22,
        drainage: 0.18,
        organic_matter: 0.15,
        compaction_level: 0.10,
        temperature_soil: 0.04,
        moisture_consistency: 0.03
      }
    });
  }

  async predict(data: ModifiedHistoricalData): Promise<PredictionResult> {
    const predictions: ModelPrediction[] = [];
    
    // Pr√©diction par mod√®le selon type de culture
    for (const [cropType, instances] of Object.entries(data.cropInstances)) {
      const model = this.models.get(cropType);
      if (!model) continue;

      const features = this.extractFeatures(instances, model.features);
      const prediction = await this.runModelPrediction(model, features);
      
      predictions.push({
        cropType,
        prediction: prediction.value,
        confidence: prediction.confidence,
        contributingFactors: this.analyzeContributingFactors(prediction, model)
      });
    }

    // Agr√©gation des pr√©dictions
    const aggregatedPrediction = this.aggregatePredictions(predictions, data.cropDistribution);
    
    // Validation avec mod√®le IA externe
    const aiValidation = await this.aiService.validateYieldPrediction({
      prediction: aggregatedPrediction,
      historicalData: data.historical,
      scenario: data.scenario
    });

    return {
      value: aggregatedPrediction.value,
      confidence: Math.min(aggregatedPrediction.confidence, aiValidation.confidence),
      contributingFactors: this.mergeContributingFactors(
        aggregatedPrediction.factors, 
        aiValidation.factors
      ),
      modelAccuracy: this.calculateModelAccuracy(data.historical),
      validationNotes: aiValidation.notes
    };
  }

  private extractFeatures(instances: CropInstance[], featureNames: string[]): FeatureVector {
    const features: FeatureVector = {};

    for (const featureName of featureNames) {
      switch (featureName) {
        case 'temperature_avg':
          features[featureName] = this.calculateAverageTemperature(instances);
          break;
        case 'light_hours':
          features[featureName] = this.calculateAverageLightHours(instances);
          break;
        case 'water_frequency':
          features[featureName] = this.calculateWaterFrequency(instances);
          break;
        case 'plant_density':
          features[featureName] = this.calculatePlantDensity(instances);
          break;
        case 'nutrients_npk':
          features[featureName] = this.calculateNutrientScore(instances);
          break;
        // ... autres features
      }
    }

    return features;
  }

  private async runModelPrediction(
    model: PredictionModel,
    features: FeatureVector
  ): Promise<ModelPredictionResult> {
    // Normalisation des features
    const normalizedFeatures = this.normalizeFeatures(features, model);
    
    // Calcul de la pr√©diction pond√©r√©e
    let prediction = 0;
    let totalWeight = 0;

    for (const [feature, value] of Object.entries(normalizedFeatures)) {
      const weight = model.weights[feature] || 0;
      prediction += value * weight;
      totalWeight += weight;
    }

    // Normalisation finale
    prediction = prediction / totalWeight;

    // Calcul de la confiance bas√© sur la compl√©tude des donn√©es
    const confidence = this.calculateConfidence(features, model);

    // Application de facteurs correctifs
    const correctedPrediction = this.applyCorrectiveFactors(prediction, features);

    return {
      value: correctedPrediction,
      confidence,
      rawPrediction: prediction,
      features: normalizedFeatures
    };
  }

  private calculateConfidence(features: FeatureVector, model: PredictionModel): number {
    // Confiance bas√©e sur:
    // 1. Compl√©tude des donn√©es (% de features disponibles)
    const completeness = Object.keys(features).length / model.features.length;
    
    // 2. Qualit√© des donn√©es (pas de valeurs aberrantes)
    const dataQuality = this.assessDataQuality(features);
    
    // 3. Similarit√© avec donn√©es d'entra√Ænement
    const similarity = this.calculateSimilarityToTrainingData(features);

    return Math.min(completeness * 0.4 + dataQuality * 0.3 + similarity * 0.3, 1.0);
  }
}
```

### Interface d'Optimisation

```typescript
// src/app/optimization/page.tsx
export default function YieldOptimizationPage() {
  const [analysis, setAnalysis] = useState<YieldAnalysis | null>(null);
  const [recommendations, setRecommendations] = useState<OptimizationRecommendation[]>([]);
  const [selectedPeriod, setSelectedPeriod] = useState<DateRange>({
    start: new Date(Date.now() - 365*24*60*60*1000),
    end: new Date()
  });
  const [loading, setLoading] = useState(false);

  const runOptimizationAnalysis = async () => {
    setLoading(true);
    try {
      const result = await yieldOptimizationService.analyzeYieldPerformance(
        'current-garden', 
        selectedPeriod
      );
      setAnalysis(result);
      
      const recs = await yieldOptimizationService.generateOptimizationRecommendations(result);
      setRecommendations(recs);
    } catch (error) {
      console.error('Optimization analysis failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold">Optimisation du Rendement</h1>
            <p className="text-gray-600 mt-1">
              Analysez et optimisez les performances de votre jardin
            </p>
          </div>
          
          <div className="flex items-center space-x-4">
            <PeriodSelector value={selectedPeriod} onChange={setSelectedPeriod} />
            <Button 
              onClick={runOptimizationAnalysis}
              disabled={loading}
              leftIcon={loading ? <Loader2Icon className="animate-spin" /> : <AnalyticsIcon />}
            >
              {loading ? 'Analyse...' : 'Analyser'}
            </Button>
          </div>
        </div>

        {analysis && (
          <div className="space-y-8">
            {/* Score global */}
            <Card className="p-6">
              <div className="flex items-center justify-between mb-6">
                <div>
                  <h2 className="text-xl font-semibold">Performance Globale</h2>
                  <p className="text-gray-600">Score bas√© sur tous les indicateurs cl√©s</p>
                </div>
                <div className="text-right">
                  <div className="text-4xl font-bold text-green-600">
                    {analysis.overallScore}/100
                  </div>
                  <div className="text-sm text-gray-500">
                    {getScoreLabel(analysis.overallScore)}
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                {analysis.categories.map(category => (
                  <div key={category.name} className="text-center p-4 bg-gray-50 rounded-lg">
                    <div className="text-2xl font-semibold">{category.score}</div>
                    <div className="text-sm text-gray-600">{category.name}</div>
                  </div>
                ))}
              </div>
            </Card>

            {/* M√©triques d√©taill√©es */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {analysis.categories.map(category => (
                <MetricsCategoryCard key={category.name} category={category} />
              ))}
            </div>

            {/* Facteurs limitants */}
            {analysis.limitingFactors.length > 0 && (
              <Card className="p-6">
                <h3 className="text-lg font-semibold mb-4">Facteurs Limitants Identifi√©s</h3>
                <div className="space-y-3">
                  {analysis.limitingFactors.map((factor, index) => (
                    <LimitingFactorCard key={index} factor={factor} />
                  ))}
                </div>
              </Card>
            )}

            {/* Recommandations */}
            <Card className="p-6">
              <h3 className="text-lg font-semibold mb-4">
                Recommandations d'Optimisation ({recommendations.length})
              </h3>
              <div className="space-y-4">
                {recommendations.slice(0, 5).map(recommendation => (
                  <RecommendationCard 
                    key={recommendation.id} 
                    recommendation={recommendation}
                    onImplement={(id) => console.log('Implement:', id)}
                  />
                ))}
              </div>
              
              {recommendations.length > 5 && (
                <Button variant="outline" className="mt-4">
                  Voir toutes les recommandations ({recommendations.length - 5} autres)
                </Button>
              )}
            </Card>
          </div>
        )}
      </div>
    </div>
  );
}

const MetricsCategoryCard = ({ category }: { category: YieldCategory }) => {
  return (
    <Card className="p-6">
      <div className="flex justify-between items-center mb-4">
        <h3 className="font-semibold">{category.name}</h3>
        <Badge variant={getScoreVariant(category.score)}>
          {category.score}/100
        </Badge>
      </div>
      
      <div className="space-y-3">
        {category.metrics.map(metric => (
          <div key={metric.name} className="flex justify-between items-center">
            <div className="flex-1">
              <div className="flex items-center">
                <span className="text-sm font-medium">{metric.name}</span>
                <TrendIcon trend={metric.trend} className="ml-2 w-4 h-4" />
              </div>
              <div className="text-xs text-gray-500">
                vs benchmark: {metric.benchmark} {metric.unit}
              </div>
            </div>
            <div className="text-right">
              <div className="font-semibold">
                {metric.value.toFixed(1)} {metric.unit}
              </div>
              <Badge size="sm" variant={getStatusVariant(metric.status)}>
                {metric.status}
              </Badge>
            </div>
          </div>
        ))}
      </div>
    </Card>
  );
};

const RecommendationCard = ({ recommendation, onImplement }: {
  recommendation: OptimizationRecommendation;
  onImplement: (id: string) => void;
}) => {
  const [expanded, setExpanded] = useState(false);

  return (
    <Card className="p-4 border-l-4 border-l-blue-500">
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <h4 className="font-semibold">{recommendation.title}</h4>
            <Badge variant={getPriorityVariant(recommendation.priority)}>
              {recommendation.priority}
            </Badge>
            <Badge variant="outline">
              +{recommendation.impact}% rendement
            </Badge>
            <Badge variant="secondary">
              ROI: {recommendation.roi.toFixed(1)}x
            </Badge>
          </div>
          
          <p className="text-sm text-gray-600 mb-3">
            {recommendation.description}
          </p>
          
          <div className="flex items-center gap-4 text-xs text-gray-500">
            <span>‚è±Ô∏è {recommendation.timeline}</span>
            <span>üí™ Effort: {recommendation.effort}</span>
            <span>üí∞ Co√ªt: {recommendation.cost}‚Ç¨</span>
          </div>
        </div>
        
        <div className="flex gap-2 ml-4">
          <Button
            size="sm"
            variant="outline"
            onClick={() => setExpanded(!expanded)}
          >
            {expanded ? 'R√©duire' : 'D√©tails'}
          </Button>
          <Button
            size="sm"
            onClick={() => onImplement(recommendation.id)}
          >
            Impl√©menter
          </Button>
        </div>
      </div>

      {expanded && (
        <div className="mt-4 pt-4 border-t">
          <h5 className="font-medium mb-2">Plan d'action:</h5>
          <div className="space-y-2">
            {recommendation.actions.map((action, index) => (
              <div key={action.id} className="flex items-start space-x-3 text-sm">
                <div className="flex-shrink-0 w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center text-xs font-medium">
                  {index + 1}
                </div>
                <div className="flex-1">
                  <div className="font-medium">{action.title}</div>
                  <div className="text-gray-600">{action.description}</div>
                  <div className="text-xs text-gray-500 mt-1">
                    Temps estim√©: {action.estimatedTime} ‚Ä¢ Co√ªt: {action.cost}‚Ç¨
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </Card>
  );
};
```

## API Routes

```typescript
// src/app/api/optimization/analyze/route.ts
export async function POST(request: Request) {
  try {
    const { gardenId, period } = await request.json();
    
    const analysis = await yieldOptimizationService.analyzeYieldPerformance(
      gardenId,
      {
        start: new Date(period.start),
        end: new Date(period.end)
      }
    );

    return NextResponse.json(analysis);

  } catch (error) {
    console.error('Yield analysis failed:', error);
    return NextResponse.json(
      { error: 'Analysis failed' },
      { status: 500 }
    );
  }
}

// src/app/api/optimization/recommendations/route.ts
export async function POST(request: Request) {
  try {
    const { analysis } = await request.json();
    
    const recommendations = await yieldOptimizationService.generateOptimizationRecommendations(analysis);

    return NextResponse.json({ recommendations });

  } catch (error) {
    console.error('Recommendations generation failed:', error);
    return NextResponse.json(
      { error: 'Recommendations generation failed' },
      { status: 500 }
    );
  }
}

// src/app/api/optimization/predict/route.ts
export async function POST(request: Request) {
  try {
    const { gardenId, scenario } = await request.json();
    
    const prediction = await yieldOptimizationService.predictYield(gardenId, scenario);

    return NextResponse.json(prediction);

  } catch (error) {
    console.error('Yield prediction failed:', error);
    return NextResponse.json(
      { error: 'Prediction failed' },
      { status: 500 }
    );
  }
}
```

## Crit√®res d'Acceptation Techniques

### Analyse de Performance
- [ ] Calcul de 10+ m√©triques de rendement
- [ ] Comparaison avec benchmarks r√©gionaux
- [ ] Identification automatique facteurs limitants
- [ ] Analyse de tendances sur 2+ ans de donn√©es

### Recommandations
- [ ] Score ROI calcul√© pour chaque recommandation
- [ ] Priorisation multicrit√®res (impact/effort/co√ªt)
- [ ] Plans d'action d√©taill√©s avec timeline
- [ ] Personnalisation selon profil utilisateur

### Pr√©dictions
- [ ] Pr√©cision > 80% sur donn√©es de test
- [ ] Intervalles de confiance calibr√©s
- [ ] Simulation de sc√©narios d'optimisation
- [ ] Validation crois√©e avec donn√©es r√©elles

## Couverture Exigences Architecture

- **EXG-005.1** : IA pour analyse et recommandations
- **EXG-005.2** : Mod√®les pr√©dictifs de rendement
- **EXG-002.1** : Requ√™tes analytiques optimis√©es
- **EXG-003.1** : Interface responsive d'analyse
- **EXG-009.1** : M√©triques de performance suivies

## Tests d'Acceptation

```typescript
// tests/integration/yield-optimization.test.ts
describe('Yield Optimization', () => {
  test('analyse de performance calcule m√©triques correctement', async () => {
    const gardenData = createTestGardenData();
    
    const analysis = await yieldOptimizationService.analyzeYieldPerformance(
      gardenData.id,
      { start: new Date('2024-01-01'), end: new Date('2024-12-31') }
    );
    
    expect(analysis.overallScore).toBeGreaterThan(0);
    expect(analysis.categories).toHaveLength(greaterThan(3));
    expect(analysis.limitingFactors).toBeDefined();
  });

  test('recommandations incluent ROI calcul√©', async () => {
    const analysis = createTestAnalysis();
    
    const recommendations = await yieldOptimizationService.generateOptimizationRecommendations(analysis);
    
    recommendations.forEach(rec => {
      expect(rec.roi).toBeGreaterThan(0);
      expect(rec.impact).toBeGreaterThan(0);
      expect(rec.actions).toHaveLength(greaterThan(0));
    });
  });

  test('pr√©diction de rendement fonctionne', async () => {
    const scenario = createOptimizationScenario();
    
    const prediction = await yieldOptimizationService.predictYield('test-garden', scenario);
    
    expect(prediction.predictedYield).toBeGreaterThan(prediction.baselineYield);
    expect(prediction.confidence).toBeGreaterThan(0.6);
    expect(prediction.improvementPercentage).toBeGreaterThan(0);
  });
});
```

Cette sp√©cification couvre un syst√®me complet d'optimisation du rendement avec analyse de performance, recommandations intelligentes et pr√©dictions bas√©es sur l'IA pour maximiser la productivit√© du jardin.