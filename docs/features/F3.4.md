# F3.4 - Modèles Prédictifs

**Score Priorité :** 50/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 3 - PILIER COMPRENDRE  
**Effort estimé :** 18 jours  

## Description

Système de modèles prédictifs avancés utilisant machine learning pour anticiper les besoins du jardin, prédire les rendements, détecter les risques de maladies et optimiser automatiquement les interventions selon les patterns historiques et conditions environnementales.

## User Stories

### US3.4.1 - Prédiction de Rendement
**En tant qu'** planificateur de jardin  
**Je veux** prédire le rendement de mes cultures  
**Afin d'** optimiser la planification et l'allocation des ressources  

**Critères d'acceptation :**
- Modèles ML entraînés sur données historiques
- Prédictions avec intervalles de confiance
- Facteurs explicatifs des prédictions
- Mise à jour continue avec nouvelles données
- Précision > 80% sur données test

### US3.4.2 - Détection Précoce Problèmes
**En tant qu'** jardinier préventif  
**Je veux** être alerté avant l'apparition de problèmes  
**Afin de** prendre des mesures correctives à temps  

**Critères d'acceptation :**
- Détection anomalies dans données capteurs
- Prédiction risques maladies/parasites
- Alertes préventives avec recommandations
- Apprentissage des faux positifs
- Adaptation selon région climatique

### US3.4.3 - Optimisation Automatique
**En tant qu'** utilisateur expert  
**Je veux** que le système optimise automatiquement les paramètres  
**Afin de** maximiser les résultats avec minimal d'effort  

**Critères d'acceptation :**
- Optimisation cycles d'arrosage
- Suggestion timing optimal interventions
- Adaptation selon météo prévue
- Apprentissage préférences utilisateur
- Mode manuel avec explications

## Architecture Technique

### Service de Modèles Prédictifs

```typescript
// src/services/prediction/prediction-models.service.ts
export interface PredictionModel {
  id: string;
  name: string;
  type: ModelType;
  version: string;
  accuracy: number;
  features: ModelFeature[];
  hyperparameters: Record<string, any>;
  trainingData: TrainingDataInfo;
  lastTrained: Date;
  isActive: boolean;
}

export type ModelType = 
  | 'yield_prediction'
  | 'disease_detection'
  | 'growth_prediction'
  | 'resource_optimization'
  | 'anomaly_detection';

export interface ModelFeature {
  name: string;
  type: 'numerical' | 'categorical' | 'temporal';
  importance: number;
  preprocessing: PreprocessingConfig;
}

export interface PredictionResult {
  prediction: number | string;
  confidence: number;
  explanation: PredictionExplanation;
  alternatives?: AlternativePrediction[];
  recommendations: string[];
}

export class PredictionModelsService {
  private models: Map<string, LoadedModel> = new Map();
  private trainingQueue: Queue<TrainingJob>;

  constructor(
    private prisma: PrismaClient,
    private mlService: MLService,
    private featureService: FeatureEngineeringService
  ) {
    this.trainingQueue = new Queue('model-training');
    this.initializeModels();
  }

  async predictYield(
    gardenId: string,
    cultureId: string,
    horizon: number = 30 // jours
  ): Promise<YieldPrediction> {
    const model = this.models.get('yield_prediction_v2');
    if (!model) {
      throw new Error('Yield prediction model not available');
    }

    // Collecte des features
    const features = await this.featureService.extractYieldFeatures({
      gardenId,
      cultureId,
      horizon,
      includeWeather: true,
      includeSoil: true,
      includeHistory: true
    });

    // Prédiction
    const result = await model.predict(features);
    
    // Post-traitement
    const processedResult = this.postProcessYieldPrediction(result, features);

    // Explication
    const explanation = await this.explainPrediction(model, features, result);

    return {
      expectedYield: processedResult.value,
      confidence: result.confidence,
      unit: 'kg',
      timeframe: `${horizon} jours`,
      factors: explanation.topFactors,
      recommendations: await this.generateYieldRecommendations(processedResult, features),
      uncertainty: {
        lower: processedResult.value * (1 - result.uncertainty),
        upper: processedResult.value * (1 + result.uncertainty)
      }
    };
  }

  async detectAnomalies(
    gardenId: string,
    timeWindow: number = 24 // heures
  ): Promise<AnomalyDetectionResult[]> {
    const model = this.models.get('anomaly_detection_v1');
    if (!model) {
      throw new Error('Anomaly detection model not available');
    }

    // Collecte des données récentes
    const sensorData = await this.collectRecentSensorData(gardenId, timeWindow);
    
    const anomalies: AnomalyDetectionResult[] = [];

    // Analyse par type de capteur
    for (const [sensorType, readings] of Object.entries(sensorData)) {
      const features = this.prepareFeaturesForAnomaly(readings);
      const result = await model.predict(features);

      if (result.anomalyScore > 0.7) { // Seuil d'anomalie
        const anomaly = await this.analyzeAnomaly({
          sensorType,
          readings,
          anomalyScore: result.anomalyScore,
          gardenId
        });

        anomalies.push(anomaly);
      }
    }

    return anomalies;
  }

  async predictDiseaseRisk(
    gardenId: string,
    cultureId: string
  ): Promise<DiseaseRiskPrediction[]> {
    const model = this.models.get('disease_risk_v1');
    if (!model) {
      throw new Error('Disease risk model not available');
    }

    // Features spécifiques aux maladies
    const features = await this.featureService.extractDiseaseFeatures({
      gardenId,
      cultureId,
      weatherHistory: 14, // 2 semaines
      includeNeighborhood: true // Données voisinage pour contagion
    });

    const commonDiseases = [
      'mildiou', 'oïdium', 'rouille', 'alternariose', 'fusariose'
    ];

    const predictions: DiseaseRiskPrediction[] = [];

    for (const disease of commonDiseases) {
      const diseaseFeatures = { ...features, disease_type: disease };
      const result = await model.predict(diseaseFeatures);

      if (result.probability > 0.3) { // Risque significatif
        predictions.push({
          disease,
          riskLevel: this.categorizeRisk(result.probability),
          probability: result.probability,
          timeframe: result.expectedOnset || '7-14 jours',
          preventionMeasures: await this.getPreventionMeasures(disease, features),
          symptoms: await this.getDiseaseSymptoms(disease)
        });
      }
    }

    return predictions.sort((a, b) => b.probability - a.probability);
  }

  async optimizeIrrigation(
    gardenId: string,
    zoneId: string
  ): Promise<IrrigationOptimization> {
    const model = this.models.get('irrigation_optimization_v1');
    if (!model) {
      throw new Error('Irrigation optimization model not available');
    }

    // Collecte données pour optimisation
    const features = await this.featureService.extractIrrigationFeatures({
      gardenId,
      zoneId,
      weatherForecast: 7,
      soilType: true,
      cropRequirements: true,
      historicalEfficiency: true
    });

    const result = await model.predict(features);

    return {
      recommendedSchedule: this.parseIrrigationSchedule(result.schedule),
      waterAmount: result.waterAmount,
      frequency: result.frequency,
      optimalTiming: result.timing,
      expectedSavings: result.waterSavings,
      reasoning: result.explanation,
      adaptations: {
        rainAdjustment: result.rainSensitivity,
        temperatureAdjustment: result.temperatureSensitivity
      }
    };
  }

  async trainModel(modelType: ModelType, config: TrainingConfig): Promise<TrainingResult> {
    const trainingJob = await this.createTrainingJob(modelType, config);
    
    // Ajout à la queue de training
    await this.trainingQueue.add('train-model', {
      jobId: trainingJob.id,
      modelType,
      config
    }, {
      removeOnComplete: 10,
      removeOnFail: 5
    });

    return {
      jobId: trainingJob.id,
      status: 'queued',
      estimatedDuration: this.estimateTrainingTime(modelType, config)
    };
  }

  private async executeTraining(jobId: string, modelType: ModelType, config: TrainingConfig): Promise<void> {
    try {
      // Préparation des données d'entraînement
      const trainingData = await this.prepareTrainingData(modelType, config);
      
      // Division train/validation/test
      const { trainSet, validationSet, testSet } = this.splitDataset(trainingData, {
        train: 0.7,
        validation: 0.15,
        test: 0.15
      });

      // Feature engineering
      const processedTrainSet = await this.featureService.processTrainingFeatures(
        trainSet, 
        modelType
      );

      // Entraînement du modèle
      const modelConfig = this.getModelConfig(modelType);
      const trainedModel = await this.mlService.trainModel(
        modelConfig,
        processedTrainSet,
        validationSet
      );

      // Évaluation sur test set
      const evaluation = await this.evaluateModel(trainedModel, testSet);
      
      // Sauvegarde si performance acceptable
      if (evaluation.accuracy >= config.minimumAccuracy) {
        await this.saveModel(trainedModel, evaluation, jobId);
        await this.deployModel(trainedModel, modelType);
      } else {
        throw new Error(`Model accuracy ${evaluation.accuracy} below threshold ${config.minimumAccuracy}`);
      }

      await this.markTrainingSuccess(jobId, evaluation);

    } catch (error) {
      await this.markTrainingFailure(jobId, error.message);
      throw error;
    }
  }

  private async prepareTrainingData(
    modelType: ModelType, 
    config: TrainingConfig
  ): Promise<TrainingDataset> {
    switch (modelType) {
      case 'yield_prediction':
        return await this.prepareYieldTrainingData(config);
      
      case 'disease_detection':
        return await this.prepareDiseaseTrainingData(config);
      
      case 'anomaly_detection':
        return await this.prepareAnomalyTrainingData(config);
      
      default:
        throw new Error(`Unsupported model type: ${modelType}`);
    }
  }

  private async prepareYieldTrainingData(config: TrainingConfig): Promise<TrainingDataset> {
    // Récupération des données de récolte avec contexte
    const harvests = await this.prisma.recolte.findMany({
      where: {
        dateRecolte: {
          gte: new Date(Date.now() - config.dataWindow * 24 * 60 * 60 * 1000)
        }
      },
      include: {
        instanceCulture: {
          include: {
            varieteCulture: true,
            zone: {
              include: {
                jardin: true
              }
            },
            interventions: true
          }
        }
      }
    });

    const trainingExamples: TrainingExample[] = [];

    for (const harvest of harvests) {
      // Extraction des features pour cette récolte
      const features = await this.featureService.extractHistoricalFeatures({
        harvest,
        weatherWindow: 90, // 3 mois de météo
        interventionWindow: 180, // 6 mois d'interventions
        soilData: true
      });

      trainingExamples.push({
        features,
        target: harvest.poids || harvest.quantite,
        metadata: {
          harvestId: harvest.id,
          varietyId: harvest.instanceCulture.varieteCultureId,
          gardenId: harvest.instanceCulture.zone.jardinId
        }
      });
    }

    return {
      examples: trainingExamples,
      featureNames: Object.keys(trainingExamples[0]?.features || {}),
      targetType: 'regression',
      metadata: {
        totalExamples: trainingExamples.length,
        dateRange: {
          start: new Date(Date.now() - config.dataWindow * 24 * 60 * 60 * 1000),
          end: new Date()
        }
      }
    };
  }

  private getModelConfig(modelType: ModelType): ModelConfiguration {
    const configs = {
      yield_prediction: {
        algorithm: 'random_forest',
        hyperparameters: {
          n_estimators: 100,
          max_depth: 10,
          min_samples_split: 5,
          random_state: 42
        },
        features: {
          numerical: ['temperature_avg', 'humidity_avg', 'rainfall_sum', 'growth_days'],
          categorical: ['variety_type', 'soil_type', 'season'],
          temporal: ['planting_week', 'harvest_week']
        }
      },
      
      disease_detection: {
        algorithm: 'gradient_boosting',
        hyperparameters: {
          n_estimators: 200,
          learning_rate: 0.1,
          max_depth: 6
        },
        features: {
          numerical: ['humidity_7d', 'temperature_variance', 'leaf_wetness'],
          categorical: ['crop_type', 'prev_disease_history'],
          temporal: ['week_of_year']
        }
      },

      anomaly_detection: {
        algorithm: 'isolation_forest',
        hyperparameters: {
          contamination: 0.1,
          random_state: 42
        },
        features: {
          numerical: ['sensor_value', 'value_change_rate', 'time_since_last'],
          derived: ['rolling_mean_24h', 'rolling_std_24h']
        }
      }
    };

    return configs[modelType];
  }
}
```

### Interface de Prédictions

```typescript
// src/app/predictions/page.tsx
export default function PredictionsPage() {
  const [activeModel, setActiveModel] = useState<ModelType>('yield_prediction');
  const [predictions, setPredictions] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-2xl font-bold">Modèles Prédictifs</h1>
            <p className="text-gray-600">Intelligence artificielle pour anticiper et optimiser</p>
          </div>
          
          <Button onClick={() => setLoading(true)}>
            <RefreshIcon className="w-4 h-4 mr-2" />
            Actualiser Prédictions
          </Button>
        </div>

        <div className="grid grid-cols-12 gap-6">
          {/* Sidebar modèles */}
          <div className="col-span-3">
            <ModelSelector 
              activeModel={activeModel}
              onModelSelect={setActiveModel}
            />
          </div>

          {/* Contenu principal */}
          <div className="col-span-9">
            {activeModel === 'yield_prediction' && <YieldPredictionPanel />}
            {activeModel === 'disease_detection' && <DiseaseDetectionPanel />}
            {activeModel === 'anomaly_detection' && <AnomalyDetectionPanel />}
            {activeModel === 'resource_optimization' && <OptimizationPanel />}
          </div>
        </div>
      </div>
    </div>
  );
}

const YieldPredictionPanel = () => {
  const { predictions, generate } = useYieldPredictions();

  return (
    <div className="space-y-6">
      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">Prédictions de Rendement</h3>
        
        <div className="grid grid-cols-2 gap-4 mb-6">
          {predictions.map(prediction => (
            <YieldPredictionCard key={prediction.id} prediction={prediction} />
          ))}
        </div>

        <Button onClick={generate}>
          Générer Nouvelles Prédictions
        </Button>
      </Card>

      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">Facteurs Influents</h3>
        <FeatureImportanceChart model="yield_prediction" />
      </Card>
    </div>
  );
};

const YieldPredictionCard = ({ prediction }: { prediction: YieldPrediction }) => {
  return (
    <Card className="p-4 border-l-4 border-l-green-500">
      <div className="flex justify-between items-start mb-2">
        <h4 className="font-semibold">{prediction.cultureName}</h4>
        <Badge variant="outline">
          {Math.round(prediction.confidence * 100)}% confiance
        </Badge>
      </div>
      
      <div className="text-2xl font-bold text-green-600 mb-1">
        {prediction.expectedYield.toFixed(1)} {prediction.unit}
      </div>
      
      <div className="text-sm text-gray-600 mb-3">
        Fourchette: {prediction.uncertainty.lower.toFixed(1)} - {prediction.uncertainty.upper.toFixed(1)} {prediction.unit}
      </div>

      <div className="space-y-1">
        <div className="text-xs font-medium text-gray-700">Facteurs clés:</div>
        {prediction.factors.slice(0, 3).map((factor, index) => (
          <div key={index} className="text-xs text-gray-600">
            • {factor.name}: {factor.impact > 0 ? '+' : ''}{(factor.impact * 100).toFixed(1)}%
          </div>
        ))}
      </div>
    </Card>
  );
};

const DiseaseDetectionPanel = () => {
  const { risks, analyze } = useDiseaseRiskPredictions();

  return (
    <div className="space-y-6">
      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">Détection Précoce Maladies</h3>
        
        {risks.length > 0 ? (
          <div className="space-y-3">
            {risks.map(risk => (
              <DiseaseRiskCard key={`${risk.disease}-${risk.cultureId}`} risk={risk} />
            ))}
          </div>
        ) : (
          <div className="text-center py-8 text-gray-500">
            <ShieldCheckIcon className="w-12 h-12 mx-auto mb-2" />
            <p>Aucun risque détecté actuellement</p>
          </div>
        )}

        <Button onClick={analyze} className="mt-4">
          Analyser Nouveaux Risques
        </Button>
      </Card>
    </div>
  );
};

const DiseaseRiskCard = ({ risk }: { risk: DiseaseRiskPrediction }) => {
  const riskColors = {
    low: 'border-l-green-500 bg-green-50',
    medium: 'border-l-yellow-500 bg-yellow-50', 
    high: 'border-l-red-500 bg-red-50'
  };

  return (
    <Card className={`p-4 border-l-4 ${riskColors[risk.riskLevel]}`}>
      <div className="flex justify-between items-start mb-2">
        <h4 className="font-semibold capitalize">{risk.disease}</h4>
        <Badge variant={risk.riskLevel === 'high' ? 'destructive' : 'outline'}>
          {risk.riskLevel} ({Math.round(risk.probability * 100)}%)
        </Badge>
      </div>
      
      <p className="text-sm text-gray-600 mb-3">
        Apparition probable: {risk.timeframe}
      </p>

      <div className="space-y-2">
        <div className="text-xs font-medium text-gray-700">Mesures préventives:</div>
        {risk.preventionMeasures.slice(0, 2).map((measure, index) => (
          <div key={index} className="text-xs text-gray-600">
            • {measure}
          </div>
        ))}
      </div>
    </Card>
  );
};

const ModelSelector = ({ activeModel, onModelSelect }: {
  activeModel: ModelType;
  onModelSelect: (model: ModelType) => void;
}) => {
  const models = [
    {
      id: 'yield_prediction',
      name: 'Prédiction Rendement',
      icon: '📈',
      accuracy: 0.85,
      status: 'active'
    },
    {
      id: 'disease_detection',
      name: 'Détection Maladies',
      icon: '🔍',
      accuracy: 0.78,
      status: 'active'
    },
    {
      id: 'anomaly_detection',
      name: 'Détection Anomalies',
      icon: '⚠️',
      accuracy: 0.82,
      status: 'active'
    },
    {
      id: 'resource_optimization',
      name: 'Optimisation Ressources',
      icon: '⚡',
      accuracy: 0.75,
      status: 'training'
    }
  ];

  return (
    <div className="space-y-2">
      <h3 className="font-semibold mb-3">Modèles Disponibles</h3>
      
      {models.map(model => (
        <button
          key={model.id}
          onClick={() => onModelSelect(model.id as ModelType)}
          className={`w-full p-3 rounded-lg border text-left transition-colors ${
            activeModel === model.id
              ? 'border-green-500 bg-green-50'
              : 'border-gray-200 hover:bg-gray-50'
          }`}
        >
          <div className="flex items-center justify-between mb-1">
            <span className="text-lg">{model.icon}</span>
            <Badge 
              variant={model.status === 'active' ? 'default' : 'secondary'}
              className="text-xs"
            >
              {model.status}
            </Badge>
          </div>
          
          <div className="font-medium text-sm">{model.name}</div>
          
          {model.status === 'active' && (
            <div className="text-xs text-gray-500 mt-1">
              Précision: {Math.round(model.accuracy * 100)}%
            </div>
          )}
        </button>
      ))}
    </div>
  );
};
```

## Critères d'Acceptation Techniques

### Précision des Modèles
- [ ] Prédiction rendement: précision > 80%
- [ ] Détection maladies: rappel > 75%, précision > 70%
- [ ] Détection anomalies: taux faux positifs < 10%
- [ ] Optimisation ressources: amélioration mesurable > 15%

### Performance ML
- [ ] Temps prédiction < 2s
- [ ] Réentraînement automatique mensuel
- [ ] A/B testing nouveaux modèles
- [ ] Monitoring drift des données

### Explicabilité
- [ ] Importance des features calculée
- [ ] Explications en langage naturel
- [ ] Intervalles de confiance calibrés
- [ ] Facteurs de décision détaillés

## Couverture Exigences Architecture

- **EXG-005.1** : ML avancé avec modèles prédictifs
- **EXG-005.2** : Apprentissage continu et adaptation
- **EXG-002.1** : Stockage optimisé données ML
- **EXG-009.1** : Monitoring performance modèles

## Tests d'Acceptation

```typescript
// tests/integration/prediction-models.test.ts
describe('Prediction Models', () => {
  test('prédiction rendement avec intervalles confiance', async () => {
    const prediction = await predictionService.predictYield('garden-1', 'culture-1');
    
    expect(prediction.expectedYield).toBeGreaterThan(0);
    expect(prediction.confidence).toBeGreaterThan(0.6);
    expect(prediction.uncertainty.lower).toBeLessThan(prediction.expectedYield);
    expect(prediction.uncertainty.upper).toBeGreaterThan(prediction.expectedYield);
  });

  test('détection anomalies fonctionne', async () => {
    const anomalies = await predictionService.detectAnomalies('garden-1', 24);
    
    anomalies.forEach(anomaly => {
      expect(anomaly.anomalyScore).toBeGreaterThan(0.7);
      expect(anomaly.recommendations).toHaveLength(greaterThan(0));
    });
  });

  test('modèle se réentraîne automatiquement', async () => {
    const trainingResult = await predictionService.trainModel('yield_prediction', {
      dataWindow: 365,
      minimumAccuracy: 0.75
    });
    
    expect(trainingResult.jobId).toBeDefined();
    expect(trainingResult.status).toBe('queued');
  });
});
```

Cette spécification couvre un système complet de modèles prédictifs ML pour anticiper et optimiser automatiquement la gestion du jardin.