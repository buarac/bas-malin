# F3.4 - Mod√®les Pr√©dictifs

**Score Priorit√© :** 50/100  
**Statut :** PRIORIT√â FAIBLE  
**Epic :** EPIC 3 - PILIER COMPRENDRE  
**Effort estim√© :** 18 jours  

## Description

Syst√®me de mod√®les pr√©dictifs avanc√©s utilisant machine learning pour anticiper les besoins du jardin, pr√©dire les rendements, d√©tecter les risques de maladies et optimiser automatiquement les interventions selon les patterns historiques et conditions environnementales.

## User Stories

### US3.4.1 - Pr√©diction de Rendement
**En tant qu'** planificateur de jardin  
**Je veux** pr√©dire le rendement de mes cultures  
**Afin d'** optimiser la planification et l'allocation des ressources  

**Crit√®res d'acceptation :**
- Mod√®les ML entra√Æn√©s sur donn√©es historiques
- Pr√©dictions avec intervalles de confiance
- Facteurs explicatifs des pr√©dictions
- Mise √† jour continue avec nouvelles donn√©es
- Pr√©cision > 80% sur donn√©es test

### US3.4.2 - D√©tection Pr√©coce Probl√®mes
**En tant qu'** jardinier pr√©ventif  
**Je veux** √™tre alert√© avant l'apparition de probl√®mes  
**Afin de** prendre des mesures correctives √† temps  

**Crit√®res d'acceptation :**
- D√©tection anomalies dans donn√©es capteurs
- Pr√©diction risques maladies/parasites
- Alertes pr√©ventives avec recommandations
- Apprentissage des faux positifs
- Adaptation selon r√©gion climatique

### US3.4.3 - Optimisation Automatique
**En tant qu'** utilisateur expert  
**Je veux** que le syst√®me optimise automatiquement les param√®tres  
**Afin de** maximiser les r√©sultats avec minimal d'effort  

**Crit√®res d'acceptation :**
- Optimisation cycles d'arrosage
- Suggestion timing optimal interventions
- Adaptation selon m√©t√©o pr√©vue
- Apprentissage pr√©f√©rences utilisateur
- Mode manuel avec explications

## Architecture Technique

### Service de Mod√®les Pr√©dictifs

```typescript
// src/services/prediction/prediction-models.service.ts
export interface PredictionModel {
  id: string;
  name: string;
  type: ModelType;
  version: string;
  accuracy: number;
  features: ModelFeature[];
  hyperparameters: Record<string, any>;
  trainingData: TrainingDataInfo;
  lastTrained: Date;
  isActive: boolean;
}

export type ModelType = 
  | 'yield_prediction'
  | 'disease_detection'
  | 'growth_prediction'
  | 'resource_optimization'
  | 'anomaly_detection';

export interface ModelFeature {
  name: string;
  type: 'numerical' | 'categorical' | 'temporal';
  importance: number;
  preprocessing: PreprocessingConfig;
}

export interface PredictionResult {
  prediction: number | string;
  confidence: number;
  explanation: PredictionExplanation;
  alternatives?: AlternativePrediction[];
  recommendations: string[];
}

export class PredictionModelsService {
  private models: Map<string, LoadedModel> = new Map();
  private trainingQueue: Queue<TrainingJob>;

  constructor(
    private prisma: PrismaClient,
    private mlService: MLService,
    private featureService: FeatureEngineeringService
  ) {
    this.trainingQueue = new Queue('model-training');
    this.initializeModels();
  }

  async predictYield(
    gardenId: string,
    cultureId: string,
    horizon: number = 30 // jours
  ): Promise<YieldPrediction> {
    const model = this.models.get('yield_prediction_v2');
    if (!model) {
      throw new Error('Yield prediction model not available');
    }

    // Collecte des features
    const features = await this.featureService.extractYieldFeatures({
      gardenId,
      cultureId,
      horizon,
      includeWeather: true,
      includeSoil: true,
      includeHistory: true
    });

    // Pr√©diction
    const result = await model.predict(features);
    
    // Post-traitement
    const processedResult = this.postProcessYieldPrediction(result, features);

    // Explication
    const explanation = await this.explainPrediction(model, features, result);

    return {
      expectedYield: processedResult.value,
      confidence: result.confidence,
      unit: 'kg',
      timeframe: `${horizon} jours`,
      factors: explanation.topFactors,
      recommendations: await this.generateYieldRecommendations(processedResult, features),
      uncertainty: {
        lower: processedResult.value * (1 - result.uncertainty),
        upper: processedResult.value * (1 + result.uncertainty)
      }
    };
  }

  async detectAnomalies(
    gardenId: string,
    timeWindow: number = 24 // heures
  ): Promise<AnomalyDetectionResult[]> {
    const model = this.models.get('anomaly_detection_v1');
    if (!model) {
      throw new Error('Anomaly detection model not available');
    }

    // Collecte des donn√©es r√©centes
    const sensorData = await this.collectRecentSensorData(gardenId, timeWindow);
    
    const anomalies: AnomalyDetectionResult[] = [];

    // Analyse par type de capteur
    for (const [sensorType, readings] of Object.entries(sensorData)) {
      const features = this.prepareFeaturesForAnomaly(readings);
      const result = await model.predict(features);

      if (result.anomalyScore > 0.7) { // Seuil d'anomalie
        const anomaly = await this.analyzeAnomaly({
          sensorType,
          readings,
          anomalyScore: result.anomalyScore,
          gardenId
        });

        anomalies.push(anomaly);
      }
    }

    return anomalies;
  }

  async predictDiseaseRisk(
    gardenId: string,
    cultureId: string
  ): Promise<DiseaseRiskPrediction[]> {
    const model = this.models.get('disease_risk_v1');
    if (!model) {
      throw new Error('Disease risk model not available');
    }

    // Features sp√©cifiques aux maladies
    const features = await this.featureService.extractDiseaseFeatures({
      gardenId,
      cultureId,
      weatherHistory: 14, // 2 semaines
      includeNeighborhood: true // Donn√©es voisinage pour contagion
    });

    const commonDiseases = [
      'mildiou', 'o√Ødium', 'rouille', 'alternariose', 'fusariose'
    ];

    const predictions: DiseaseRiskPrediction[] = [];

    for (const disease of commonDiseases) {
      const diseaseFeatures = { ...features, disease_type: disease };
      const result = await model.predict(diseaseFeatures);

      if (result.probability > 0.3) { // Risque significatif
        predictions.push({
          disease,
          riskLevel: this.categorizeRisk(result.probability),
          probability: result.probability,
          timeframe: result.expectedOnset || '7-14 jours',
          preventionMeasures: await this.getPreventionMeasures(disease, features),
          symptoms: await this.getDiseaseSymptoms(disease)
        });
      }
    }

    return predictions.sort((a, b) => b.probability - a.probability);
  }

  async optimizeIrrigation(
    gardenId: string,
    zoneId: string
  ): Promise<IrrigationOptimization> {
    const model = this.models.get('irrigation_optimization_v1');
    if (!model) {
      throw new Error('Irrigation optimization model not available');
    }

    // Collecte donn√©es pour optimisation
    const features = await this.featureService.extractIrrigationFeatures({
      gardenId,
      zoneId,
      weatherForecast: 7,
      soilType: true,
      cropRequirements: true,
      historicalEfficiency: true
    });

    const result = await model.predict(features);

    return {
      recommendedSchedule: this.parseIrrigationSchedule(result.schedule),
      waterAmount: result.waterAmount,
      frequency: result.frequency,
      optimalTiming: result.timing,
      expectedSavings: result.waterSavings,
      reasoning: result.explanation,
      adaptations: {
        rainAdjustment: result.rainSensitivity,
        temperatureAdjustment: result.temperatureSensitivity
      }
    };
  }

  async trainModel(modelType: ModelType, config: TrainingConfig): Promise<TrainingResult> {
    const trainingJob = await this.createTrainingJob(modelType, config);
    
    // Ajout √† la queue de training
    await this.trainingQueue.add('train-model', {
      jobId: trainingJob.id,
      modelType,
      config
    }, {
      removeOnComplete: 10,
      removeOnFail: 5
    });

    return {
      jobId: trainingJob.id,
      status: 'queued',
      estimatedDuration: this.estimateTrainingTime(modelType, config)
    };
  }

  private async executeTraining(jobId: string, modelType: ModelType, config: TrainingConfig): Promise<void> {
    try {
      // Pr√©paration des donn√©es d'entra√Ænement
      const trainingData = await this.prepareTrainingData(modelType, config);
      
      // Division train/validation/test
      const { trainSet, validationSet, testSet } = this.splitDataset(trainingData, {
        train: 0.7,
        validation: 0.15,
        test: 0.15
      });

      // Feature engineering
      const processedTrainSet = await this.featureService.processTrainingFeatures(
        trainSet, 
        modelType
      );

      // Entra√Ænement du mod√®le
      const modelConfig = this.getModelConfig(modelType);
      const trainedModel = await this.mlService.trainModel(
        modelConfig,
        processedTrainSet,
        validationSet
      );

      // √âvaluation sur test set
      const evaluation = await this.evaluateModel(trainedModel, testSet);
      
      // Sauvegarde si performance acceptable
      if (evaluation.accuracy >= config.minimumAccuracy) {
        await this.saveModel(trainedModel, evaluation, jobId);
        await this.deployModel(trainedModel, modelType);
      } else {
        throw new Error(`Model accuracy ${evaluation.accuracy} below threshold ${config.minimumAccuracy}`);
      }

      await this.markTrainingSuccess(jobId, evaluation);

    } catch (error) {
      await this.markTrainingFailure(jobId, error.message);
      throw error;
    }
  }

  private async prepareTrainingData(
    modelType: ModelType, 
    config: TrainingConfig
  ): Promise<TrainingDataset> {
    switch (modelType) {
      case 'yield_prediction':
        return await this.prepareYieldTrainingData(config);
      
      case 'disease_detection':
        return await this.prepareDiseaseTrainingData(config);
      
      case 'anomaly_detection':
        return await this.prepareAnomalyTrainingData(config);
      
      default:
        throw new Error(`Unsupported model type: ${modelType}`);
    }
  }

  private async prepareYieldTrainingData(config: TrainingConfig): Promise<TrainingDataset> {
    // R√©cup√©ration des donn√©es de r√©colte avec contexte
    const harvests = await this.prisma.recolte.findMany({
      where: {
        dateRecolte: {
          gte: new Date(Date.now() - config.dataWindow * 24 * 60 * 60 * 1000)
        }
      },
      include: {
        instanceCulture: {
          include: {
            varieteCulture: true,
            zone: {
              include: {
                jardin: true
              }
            },
            interventions: true
          }
        }
      }
    });

    const trainingExamples: TrainingExample[] = [];

    for (const harvest of harvests) {
      // Extraction des features pour cette r√©colte
      const features = await this.featureService.extractHistoricalFeatures({
        harvest,
        weatherWindow: 90, // 3 mois de m√©t√©o
        interventionWindow: 180, // 6 mois d'interventions
        soilData: true
      });

      trainingExamples.push({
        features,
        target: harvest.poids || harvest.quantite,
        metadata: {
          harvestId: harvest.id,
          varietyId: harvest.instanceCulture.varieteCultureId,
          gardenId: harvest.instanceCulture.zone.jardinId
        }
      });
    }

    return {
      examples: trainingExamples,
      featureNames: Object.keys(trainingExamples[0]?.features || {}),
      targetType: 'regression',
      metadata: {
        totalExamples: trainingExamples.length,
        dateRange: {
          start: new Date(Date.now() - config.dataWindow * 24 * 60 * 60 * 1000),
          end: new Date()
        }
      }
    };
  }

  private getModelConfig(modelType: ModelType): ModelConfiguration {
    const configs = {
      yield_prediction: {
        algorithm: 'random_forest',
        hyperparameters: {
          n_estimators: 100,
          max_depth: 10,
          min_samples_split: 5,
          random_state: 42
        },
        features: {
          numerical: ['temperature_avg', 'humidity_avg', 'rainfall_sum', 'growth_days'],
          categorical: ['variety_type', 'soil_type', 'season'],
          temporal: ['planting_week', 'harvest_week']
        }
      },
      
      disease_detection: {
        algorithm: 'gradient_boosting',
        hyperparameters: {
          n_estimators: 200,
          learning_rate: 0.1,
          max_depth: 6
        },
        features: {
          numerical: ['humidity_7d', 'temperature_variance', 'leaf_wetness'],
          categorical: ['crop_type', 'prev_disease_history'],
          temporal: ['week_of_year']
        }
      },

      anomaly_detection: {
        algorithm: 'isolation_forest',
        hyperparameters: {
          contamination: 0.1,
          random_state: 42
        },
        features: {
          numerical: ['sensor_value', 'value_change_rate', 'time_since_last'],
          derived: ['rolling_mean_24h', 'rolling_std_24h']
        }
      }
    };

    return configs[modelType];
  }
}
```

### Interface de Pr√©dictions

```typescript
// src/app/predictions/page.tsx
export default function PredictionsPage() {
  const [activeModel, setActiveModel] = useState<ModelType>('yield_prediction');
  const [predictions, setPredictions] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-2xl font-bold">Mod√®les Pr√©dictifs</h1>
            <p className="text-gray-600">Intelligence artificielle pour anticiper et optimiser</p>
          </div>
          
          <Button onClick={() => setLoading(true)}>
            <RefreshIcon className="w-4 h-4 mr-2" />
            Actualiser Pr√©dictions
          </Button>
        </div>

        <div className="grid grid-cols-12 gap-6">
          {/* Sidebar mod√®les */}
          <div className="col-span-3">
            <ModelSelector 
              activeModel={activeModel}
              onModelSelect={setActiveModel}
            />
          </div>

          {/* Contenu principal */}
          <div className="col-span-9">
            {activeModel === 'yield_prediction' && <YieldPredictionPanel />}
            {activeModel === 'disease_detection' && <DiseaseDetectionPanel />}
            {activeModel === 'anomaly_detection' && <AnomalyDetectionPanel />}
            {activeModel === 'resource_optimization' && <OptimizationPanel />}
          </div>
        </div>
      </div>
    </div>
  );
}

const YieldPredictionPanel = () => {
  const { predictions, generate } = useYieldPredictions();

  return (
    <div className="space-y-6">
      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">Pr√©dictions de Rendement</h3>
        
        <div className="grid grid-cols-2 gap-4 mb-6">
          {predictions.map(prediction => (
            <YieldPredictionCard key={prediction.id} prediction={prediction} />
          ))}
        </div>

        <Button onClick={generate}>
          G√©n√©rer Nouvelles Pr√©dictions
        </Button>
      </Card>

      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">Facteurs Influents</h3>
        <FeatureImportanceChart model="yield_prediction" />
      </Card>
    </div>
  );
};

const YieldPredictionCard = ({ prediction }: { prediction: YieldPrediction }) => {
  return (
    <Card className="p-4 border-l-4 border-l-green-500">
      <div className="flex justify-between items-start mb-2">
        <h4 className="font-semibold">{prediction.cultureName}</h4>
        <Badge variant="outline">
          {Math.round(prediction.confidence * 100)}% confiance
        </Badge>
      </div>
      
      <div className="text-2xl font-bold text-green-600 mb-1">
        {prediction.expectedYield.toFixed(1)} {prediction.unit}
      </div>
      
      <div className="text-sm text-gray-600 mb-3">
        Fourchette: {prediction.uncertainty.lower.toFixed(1)} - {prediction.uncertainty.upper.toFixed(1)} {prediction.unit}
      </div>

      <div className="space-y-1">
        <div className="text-xs font-medium text-gray-700">Facteurs cl√©s:</div>
        {prediction.factors.slice(0, 3).map((factor, index) => (
          <div key={index} className="text-xs text-gray-600">
            ‚Ä¢ {factor.name}: {factor.impact > 0 ? '+' : ''}{(factor.impact * 100).toFixed(1)}%
          </div>
        ))}
      </div>
    </Card>
  );
};

const DiseaseDetectionPanel = () => {
  const { risks, analyze } = useDiseaseRiskPredictions();

  return (
    <div className="space-y-6">
      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">D√©tection Pr√©coce Maladies</h3>
        
        {risks.length > 0 ? (
          <div className="space-y-3">
            {risks.map(risk => (
              <DiseaseRiskCard key={`${risk.disease}-${risk.cultureId}`} risk={risk} />
            ))}
          </div>
        ) : (
          <div className="text-center py-8 text-gray-500">
            <ShieldCheckIcon className="w-12 h-12 mx-auto mb-2" />
            <p>Aucun risque d√©tect√© actuellement</p>
          </div>
        )}

        <Button onClick={analyze} className="mt-4">
          Analyser Nouveaux Risques
        </Button>
      </Card>
    </div>
  );
};

const DiseaseRiskCard = ({ risk }: { risk: DiseaseRiskPrediction }) => {
  const riskColors = {
    low: 'border-l-green-500 bg-green-50',
    medium: 'border-l-yellow-500 bg-yellow-50', 
    high: 'border-l-red-500 bg-red-50'
  };

  return (
    <Card className={`p-4 border-l-4 ${riskColors[risk.riskLevel]}`}>
      <div className="flex justify-between items-start mb-2">
        <h4 className="font-semibold capitalize">{risk.disease}</h4>
        <Badge variant={risk.riskLevel === 'high' ? 'destructive' : 'outline'}>
          {risk.riskLevel} ({Math.round(risk.probability * 100)}%)
        </Badge>
      </div>
      
      <p className="text-sm text-gray-600 mb-3">
        Apparition probable: {risk.timeframe}
      </p>

      <div className="space-y-2">
        <div className="text-xs font-medium text-gray-700">Mesures pr√©ventives:</div>
        {risk.preventionMeasures.slice(0, 2).map((measure, index) => (
          <div key={index} className="text-xs text-gray-600">
            ‚Ä¢ {measure}
          </div>
        ))}
      </div>
    </Card>
  );
};

const ModelSelector = ({ activeModel, onModelSelect }: {
  activeModel: ModelType;
  onModelSelect: (model: ModelType) => void;
}) => {
  const models = [
    {
      id: 'yield_prediction',
      name: 'Pr√©diction Rendement',
      icon: 'üìà',
      accuracy: 0.85,
      status: 'active'
    },
    {
      id: 'disease_detection',
      name: 'D√©tection Maladies',
      icon: 'üîç',
      accuracy: 0.78,
      status: 'active'
    },
    {
      id: 'anomaly_detection',
      name: 'D√©tection Anomalies',
      icon: '‚ö†Ô∏è',
      accuracy: 0.82,
      status: 'active'
    },
    {
      id: 'resource_optimization',
      name: 'Optimisation Ressources',
      icon: '‚ö°',
      accuracy: 0.75,
      status: 'training'
    }
  ];

  return (
    <div className="space-y-2">
      <h3 className="font-semibold mb-3">Mod√®les Disponibles</h3>
      
      {models.map(model => (
        <button
          key={model.id}
          onClick={() => onModelSelect(model.id as ModelType)}
          className={`w-full p-3 rounded-lg border text-left transition-colors ${
            activeModel === model.id
              ? 'border-green-500 bg-green-50'
              : 'border-gray-200 hover:bg-gray-50'
          }`}
        >
          <div className="flex items-center justify-between mb-1">
            <span className="text-lg">{model.icon}</span>
            <Badge 
              variant={model.status === 'active' ? 'default' : 'secondary'}
              className="text-xs"
            >
              {model.status}
            </Badge>
          </div>
          
          <div className="font-medium text-sm">{model.name}</div>
          
          {model.status === 'active' && (
            <div className="text-xs text-gray-500 mt-1">
              Pr√©cision: {Math.round(model.accuracy * 100)}%
            </div>
          )}
        </button>
      ))}
    </div>
  );
};
```

## Crit√®res d'Acceptation Techniques

### Pr√©cision des Mod√®les
- [ ] Pr√©diction rendement: pr√©cision > 80%
- [ ] D√©tection maladies: rappel > 75%, pr√©cision > 70%
- [ ] D√©tection anomalies: taux faux positifs < 10%
- [ ] Optimisation ressources: am√©lioration mesurable > 15%

### Performance ML
- [ ] Temps pr√©diction < 2s
- [ ] R√©entra√Ænement automatique mensuel
- [ ] A/B testing nouveaux mod√®les
- [ ] Monitoring drift des donn√©es

### Explicabilit√©
- [ ] Importance des features calcul√©e
- [ ] Explications en langage naturel
- [ ] Intervalles de confiance calibr√©s
- [ ] Facteurs de d√©cision d√©taill√©s

## Couverture Exigences Architecture

- **EXG-005.1** : ML avanc√© avec mod√®les pr√©dictifs
- **EXG-005.2** : Apprentissage continu et adaptation
- **EXG-002.1** : Stockage optimis√© donn√©es ML
- **EXG-009.1** : Monitoring performance mod√®les

## Tests d'Acceptation

```typescript
// tests/integration/prediction-models.test.ts
describe('Prediction Models', () => {
  test('pr√©diction rendement avec intervalles confiance', async () => {
    const prediction = await predictionService.predictYield('garden-1', 'culture-1');
    
    expect(prediction.expectedYield).toBeGreaterThan(0);
    expect(prediction.confidence).toBeGreaterThan(0.6);
    expect(prediction.uncertainty.lower).toBeLessThan(prediction.expectedYield);
    expect(prediction.uncertainty.upper).toBeGreaterThan(prediction.expectedYield);
  });

  test('d√©tection anomalies fonctionne', async () => {
    const anomalies = await predictionService.detectAnomalies('garden-1', 24);
    
    anomalies.forEach(anomaly => {
      expect(anomaly.anomalyScore).toBeGreaterThan(0.7);
      expect(anomaly.recommendations).toHaveLength(greaterThan(0));
    });
  });

  test('mod√®le se r√©entra√Æne automatiquement', async () => {
    const trainingResult = await predictionService.trainModel('yield_prediction', {
      dataWindow: 365,
      minimumAccuracy: 0.75
    });
    
    expect(trainingResult.jobId).toBeDefined();
    expect(trainingResult.status).toBe('queued');
  });
});
```

Cette sp√©cification couvre un syst√®me complet de mod√®les pr√©dictifs ML pour anticiper et optimiser automatiquement la gestion du jardin.