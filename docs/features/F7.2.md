# F7.2 - API & Intégrations

**Score Priorité :** 55/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 7 - EXTENSIONS  
**Effort estimé :** 15 jours  

## Description

API REST complète et SDK pour intégrations tierces, webhooks bidirectionnels, authentification OAuth2 et marketplace d'extensions permettant aux développeurs de créer des applications connectées à l'écosystème Baš-Malin.

## User Stories

### US7.2.1 - API Publique Complète
**En tant que** développeur tiers  
**Je veux** accéder aux données Baš-Malin via une API REST  
**Afin de** créer des applications et intégrations personnalisées  

**Critères d'acceptation :**
- API REST complète avec tous les endpoints CRUD
- Documentation OpenAPI/Swagger interactive
- Rate limiting et quotas par utilisateur
- Authentification OAuth2 sécurisée
- SDK JavaScript/Python/PHP

### US7.2.2 - Système de Webhooks
**En tant qu'** intégrateur système  
**Je veux** recevoir des notifications temps réel des événements  
**Afin de** synchroniser avec mes systèmes externes  

**Critères d'acceptation :**
- Webhooks configurables par type d'événement
- Retry automatique avec backoff exponentiel
- Signature HMAC pour sécurité
- Logs détaillés des livraisons
- Test des endpoints webhook

### US7.2.3 - Marketplace d'Extensions
**En tant qu'** utilisateur avancé  
**Je veux** installer des extensions développées par la communauté  
**Afin d'** étendre les fonctionnalités de base  

**Critères d'acceptation :**
- Store d'extensions avec recherche et catégories
- Installation/désinstallation en un clic
- Sandbox sécurisé pour exécution extensions
- Système de permissions granulaires
- Reviews et ratings communautaires

## Architecture Technique

### API Service

```typescript
// src/services/api/api.service.ts
export interface APIKey {
  id: string;
  userId: string;
  name: string;
  key: string;
  permissions: APIPermission[];
  rateLimit: RateLimit;
  isActive: boolean;
  lastUsed?: Date;
  createdAt: Date;
  expiresAt?: Date;
}

export interface APIPermission {
  resource: string; // 'gardens', 'cultures', 'harvests', etc.
  actions: ('read' | 'write' | 'delete')[];
  scope?: 'own' | 'all'; // Portée des données accessibles
}

export interface RateLimit {
  requestsPerMinute: number;
  requestsPerHour: number;
  requestsPerDay: number;
  burstLimit: number;
}

export class APIService {
  private rateLimiter: RateLimiterService;
  private authService: OAuth2Service;

  constructor(
    private prisma: PrismaClient,
    private redis: Redis
  ) {
    this.rateLimiter = new RateLimiterService(redis);
    this.authService = new OAuth2Service();
  }

  async authenticateRequest(request: Request): Promise<AuthResult> {
    const authHeader = request.headers.get('authorization');
    
    if (!authHeader) {
      throw new APIError('Missing authorization header', 401);
    }

    if (authHeader.startsWith('Bearer ')) {
      // OAuth2 token
      const token = authHeader.substring(7);
      return await this.authService.validateToken(token);
    } else if (authHeader.startsWith('ApiKey ')) {
      // API Key
      const apiKey = authHeader.substring(7);
      return await this.validateAPIKey(apiKey);
    }

    throw new APIError('Invalid authorization format', 401);
  }

  async validateAPIKey(keyValue: string): Promise<AuthResult> {
    // Hash de la clé pour recherche sécurisée
    const keyHash = await this.hashAPIKey(keyValue);
    
    const apiKey = await this.prisma.apiKey.findUnique({
      where: { keyHash },
      include: { user: true }
    });

    if (!apiKey || !apiKey.isActive) {
      throw new APIError('Invalid or inactive API key', 401);
    }

    if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
      throw new APIError('API key expired', 401);
    }

    // Mise à jour dernière utilisation
    await this.prisma.apiKey.update({
      where: { id: apiKey.id },
      data: { lastUsed: new Date() }
    });

    return {
      userId: apiKey.userId,
      user: apiKey.user,
      permissions: apiKey.permissions,
      rateLimit: apiKey.rateLimit
    };
  }

  async checkRateLimit(userId: string, rateLimit: RateLimit): Promise<void> {
    const limits = [
      { key: `rate_limit:${userId}:minute`, limit: rateLimit.requestsPerMinute, window: 60 },
      { key: `rate_limit:${userId}:hour`, limit: rateLimit.requestsPerHour, window: 3600 },
      { key: `rate_limit:${userId}:day`, limit: rateLimit.requestsPerDay, window: 86400 }
    ];

    for (const { key, limit, window } of limits) {
      const current = await this.rateLimiter.increment(key, window);
      
      if (current > limit) {
        throw new APIError(`Rate limit exceeded: ${limit} requests per ${window}s`, 429);
      }
    }
  }

  async createAPIKey(
    userId: string, 
    config: CreateAPIKeyConfig
  ): Promise<{ apiKey: APIKey; secret: string }> {
    // Génération clé sécurisée
    const secret = this.generateSecureKey();
    const keyHash = await this.hashAPIKey(secret);

    const apiKey = await this.prisma.apiKey.create({
      data: {
        userId,
        name: config.name,
        keyHash,
        permissions: config.permissions,
        rateLimit: config.rateLimit || this.getDefaultRateLimit(),
        isActive: true,
        expiresAt: config.expiresAt
      }
    });

    return {
      apiKey: this.mapToAPIKey(apiKey),
      secret // Retourné une seule fois
    };
  }

  private generateSecureKey(): string {
    return `bm_${crypto.randomBytes(32).toString('hex')}`;
  }
}

// Middleware d'authentification API
export function apiAuthMiddleware() {
  return async (request: Request, context: any) => {
    try {
      const authResult = await apiService.authenticateRequest(request);
      
      // Vérification rate limiting
      await apiService.checkRateLimit(authResult.userId, authResult.rateLimit);
      
      // Injection des infos d'auth dans le contexte
      context.user = authResult.user;
      context.permissions = authResult.permissions;
      
      return undefined; // Continue
    } catch (error) {
      return new Response(
        JSON.stringify({ error: error.message }),
        { 
          status: error.status || 500,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }
  };
}
```

### Service Webhooks

```typescript
// src/services/webhooks/webhook.service.ts
export interface Webhook {
  id: string;
  userId: string;
  url: string;
  events: WebhookEvent[];
  isActive: boolean;
  secret: string;
  headers?: Record<string, string>;
  retryConfig: RetryConfig;
  stats: WebhookStats;
}

export type WebhookEvent = 
  | 'harvest.created'
  | 'intervention.completed'
  | 'alert.triggered'
  | 'garden.updated'
  | 'culture.planted'
  | 'sensor.reading';

export interface WebhookDelivery {
  id: string;
  webhookId: string;
  event: WebhookEvent;
  payload: any;
  status: 'pending' | 'delivered' | 'failed' | 'retrying';
  attempts: number;
  lastAttempt?: Date;
  nextAttempt?: Date;
  response?: WebhookResponse;
}

export class WebhookService {
  private deliveryQueue: Queue<WebhookDelivery>;

  constructor(
    private prisma: PrismaClient,
    private httpClient: AxiosInstance
  ) {
    this.deliveryQueue = new Queue('webhook-delivery');
    this.setupDeliveryProcessor();
  }

  async createWebhook(userId: string, config: CreateWebhookConfig): Promise<Webhook> {
    // Validation de l'URL
    await this.validateWebhookUrl(config.url);

    const secret = this.generateWebhookSecret();

    const webhook = await this.prisma.webhook.create({
      data: {
        userId,
        url: config.url,
        events: config.events,
        secret,
        headers: config.headers || {},
        retryConfig: config.retryConfig || this.getDefaultRetryConfig(),
        isActive: true
      }
    });

    return this.mapToWebhook(webhook);
  }

  async triggerWebhooks(event: WebhookEvent, payload: any, userId?: string): Promise<void> {
    // Recherche des webhooks actifs pour cet événement
    const webhooks = await this.prisma.webhook.findMany({
      where: {
        isActive: true,
        events: { has: event },
        ...(userId && { userId })
      }
    });

    // Création des livraisons
    for (const webhook of webhooks) {
      const delivery = await this.prisma.webhookDelivery.create({
        data: {
          webhookId: webhook.id,
          event,
          payload,
          status: 'pending',
          attempts: 0
        }
      });

      // Ajout à la queue de livraison
      await this.deliveryQueue.add(
        'deliver',
        { deliveryId: delivery.id },
        { 
          delay: 0,
          removeOnComplete: 100,
          removeOnFail: 50
        }
      );
    }
  }

  private setupDeliveryProcessor(): void {
    this.deliveryQueue.process('deliver', async (job) => {
      const { deliveryId } = job.data;
      await this.deliverWebhook(deliveryId);
    });
  }

  private async deliverWebhook(deliveryId: string): Promise<void> {
    const delivery = await this.prisma.webhookDelivery.findUnique({
      where: { id: deliveryId },
      include: { webhook: true }
    });

    if (!delivery || !delivery.webhook.isActive) {
      return;
    }

    try {
      // Signature HMAC du payload
      const signature = this.generateSignature(
        JSON.stringify(delivery.payload),
        delivery.webhook.secret
      );

      const headers = {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': signature,
        'X-Webhook-Event': delivery.event,
        'X-Webhook-Delivery': delivery.id,
        ...delivery.webhook.headers
      };

      const response = await this.httpClient.post(
        delivery.webhook.url,
        {
          event: delivery.event,
          data: delivery.payload,
          timestamp: new Date().toISOString()
        },
        {
          headers,
          timeout: 30000 // 30s timeout
        }
      );

      // Succès
      await this.markDeliverySuccess(delivery.id, {
        status: response.status,
        headers: response.headers,
        duration: Date.now() - new Date(delivery.createdAt).getTime()
      });

    } catch (error) {
      await this.handleDeliveryFailure(delivery, error);
    }
  }

  private async handleDeliveryFailure(
    delivery: WebhookDelivery, 
    error: any
  ): Promise<void> {
    const newAttempts = delivery.attempts + 1;
    const maxAttempts = delivery.webhook.retryConfig.maxAttempts;

    if (newAttempts >= maxAttempts) {
      // Échec définitif
      await this.prisma.webhookDelivery.update({
        where: { id: delivery.id },
        data: {
          status: 'failed',
          attempts: newAttempts,
          lastAttempt: new Date(),
          response: {
            error: error.message,
            code: error.code
          }
        }
      });

      // Désactiver webhook si trop d'échecs consécutifs
      await this.checkWebhookHealth(delivery.webhook.id);
    } else {
      // Programmer retry avec backoff exponentiel
      const delay = this.calculateRetryDelay(newAttempts, delivery.webhook.retryConfig);
      const nextAttempt = new Date(Date.now() + delay);

      await this.prisma.webhookDelivery.update({
        where: { id: delivery.id },
        data: {
          status: 'retrying',
          attempts: newAttempts,
          lastAttempt: new Date(),
          nextAttempt
        }
      });

      // Programmer nouveau delivery
      await this.deliveryQueue.add(
        'deliver',
        { deliveryId: delivery.id },
        { delay }
      );
    }
  }

  private calculateRetryDelay(attempt: number, config: RetryConfig): number {
    // Backoff exponentiel avec jitter
    const baseDelay = config.baseDelay || 1000; // 1s
    const maxDelay = config.maxDelay || 300000; // 5min
    
    const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
    const jitter = Math.random() * 0.1 * exponentialDelay;
    
    return Math.min(exponentialDelay + jitter, maxDelay);
  }

  private generateSignature(payload: string, secret: string): string {
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(payload);
    return `sha256=${hmac.digest('hex')}`;
  }

  async testWebhook(webhookId: string): Promise<WebhookTestResult> {
    const webhook = await this.prisma.webhook.findUnique({
      where: { id: webhookId }
    });

    if (!webhook) {
      throw new Error('Webhook not found');
    }

    try {
      const testPayload = {
        event: 'test',
        data: { message: 'Test webhook delivery' },
        timestamp: new Date().toISOString()
      };

      const signature = this.generateSignature(
        JSON.stringify(testPayload),
        webhook.secret
      );

      const response = await this.httpClient.post(
        webhook.url,
        testPayload,
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Webhook-Signature': signature,
            'X-Webhook-Event': 'test'
          },
          timeout: 10000
        }
      );

      return {
        success: true,
        status: response.status,
        responseTime: response.headers['x-response-time'] || 'unknown'
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        code: error.code
      };
    }
  }
}
```

### API Routes Documentation

```typescript
// src/app/api/v1/gardens/route.ts
/**
 * @swagger
 * /api/v1/gardens:
 *   get:
 *     tags: [Gardens]
 *     summary: List user gardens
 *     security:
 *       - ApiKeyAuth: []
 *       - OAuth2: [read:gardens]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *         description: Page number
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *         description: Items per page
 *     responses:
 *       200:
 *         description: List of gardens
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 gardens:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Garden'
 *                 pagination:
 *                   $ref: '#/components/schemas/Pagination'
 *       401:
 *         $ref: '#/components/responses/Unauthorized'
 *       429:
 *         $ref: '#/components/responses/RateLimitExceeded'
 */
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 100);

  const { user, permissions } = await apiAuthMiddleware()(request, {});
  
  if (!permissions.some(p => p.resource === 'gardens' && p.actions.includes('read'))) {
    return new Response(
      JSON.stringify({ error: 'Insufficient permissions' }),
      { status: 403 }
    );
  }

  const gardens = await prisma.jardin.findMany({
    where: { userId: user.id },
    skip: (page - 1) * limit,
    take: limit,
    include: {
      zones: {
        include: {
          instancesCultures: {
            where: { statut: 'active' },
            include: { varieteCulture: true }
          }
        }
      },
      _count: {
        select: {
          zones: true
        }
      }
    }
  });

  const total = await prisma.jardin.count({
    where: { userId: user.id }
  });

  return NextResponse.json({
    gardens: gardens.map(garden => ({
      id: garden.id,
      name: garden.nom,
      description: garden.description,
      location: {
        latitude: garden.latitude,
        longitude: garden.longitude,
        address: garden.adresse
      },
      zones: garden.zones.map(zone => ({
        id: zone.id,
        name: zone.nom,
        area: zone.surface,
        activeCultures: zone.instancesCultures.length
      })),
      stats: {
        totalZones: garden._count.zones,
        activeCultures: garden.zones.reduce((sum, zone) => sum + zone.instancesCultures.length, 0)
      },
      createdAt: garden.createdAt,
      updatedAt: garden.updatedAt
    })),
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasNext: page < Math.ceil(total / limit),
      hasPrev: page > 1
    }
  });
}

/**
 * @swagger
 * /api/v1/gardens:
 *   post:
 *     tags: [Gardens]
 *     summary: Create a new garden
 *     security:
 *       - ApiKeyAuth: []
 *       - OAuth2: [write:gardens]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreateGardenRequest'
 *     responses:
 *       201:
 *         description: Garden created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/Garden'
 *       400:
 *         $ref: '#/components/responses/BadRequest'
 *       401:
 *         $ref: '#/components/responses/Unauthorized'
 */
export async function POST(request: Request) {
  const { user, permissions } = await apiAuthMiddleware()(request, {});
  
  if (!permissions.some(p => p.resource === 'gardens' && p.actions.includes('write'))) {
    return new Response(
      JSON.stringify({ error: 'Insufficient permissions' }),
      { status: 403 }
    );
  }

  try {
    const body = await request.json();
    
    // Validation
    const validation = createGardenSchema.safeParse(body);
    if (!validation.success) {
      return new Response(
        JSON.stringify({ 
          error: 'Validation failed',
          details: validation.error.issues
        }),
        { status: 400 }
      );
    }

    const garden = await prisma.jardin.create({
      data: {
        userId: user.id,
        nom: body.name,
        description: body.description,
        latitude: body.location.latitude,
        longitude: body.location.longitude,
        adresse: body.location.address,
        surface: body.area,
        typeJardin: body.type || 'potager'
      }
    });

    // Trigger webhook
    await webhookService.triggerWebhooks('garden.created', {
      gardenId: garden.id,
      name: garden.nom,
      userId: user.id
    }, user.id);

    return NextResponse.json({
      id: garden.id,
      name: garden.nom,
      description: garden.description,
      location: {
        latitude: garden.latitude,
        longitude: garden.longitude,
        address: garden.adresse
      },
      area: garden.surface,
      type: garden.typeJardin,
      createdAt: garden.createdAt
    }, { status: 201 });

  } catch (error) {
    console.error('Garden creation failed:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500 }
    );
  }
}
```

### SDK JavaScript

```typescript
// sdk/javascript/bas-malin-sdk.ts
export class BasMalinSDK {
  private baseUrl: string;
  private apiKey?: string;
  private accessToken?: string;

  constructor(config: SDKConfig) {
    this.baseUrl = config.baseUrl || 'https://api.basmalin.com';
    this.apiKey = config.apiKey;
    this.accessToken = config.accessToken;
  }

  // Gardens API
  gardens = {
    list: (params?: ListParams) => this.request('GET', '/v1/gardens', { params }),
    get: (id: string) => this.request('GET', `/v1/gardens/${id}`),
    create: (data: CreateGardenData) => this.request('POST', '/v1/gardens', { data }),
    update: (id: string, data: UpdateGardenData) => this.request('PUT', `/v1/gardens/${id}`, { data }),
    delete: (id: string) => this.request('DELETE', `/v1/gardens/${id}`)
  };

  // Cultures API
  cultures = {
    list: (gardenId: string, params?: ListParams) => 
      this.request('GET', `/v1/gardens/${gardenId}/cultures`, { params }),
    create: (gardenId: string, data: CreateCultureData) => 
      this.request('POST', `/v1/gardens/${gardenId}/cultures`, { data }),
    update: (gardenId: string, cultureId: string, data: UpdateCultureData) => 
      this.request('PUT', `/v1/gardens/${gardenId}/cultures/${cultureId}`, { data })
  };

  // Harvests API
  harvests = {
    list: (gardenId: string, params?: ListParams) => 
      this.request('GET', `/v1/gardens/${gardenId}/harvests`, { params }),
    create: (gardenId: string, data: CreateHarvestData) => 
      this.request('POST', `/v1/gardens/${gardenId}/harvests`, { data }),
    stats: (gardenId: string, period?: string) => 
      this.request('GET', `/v1/gardens/${gardenId}/harvests/stats`, { params: { period } })
  };

  // Webhooks API
  webhooks = {
    list: () => this.request('GET', '/v1/webhooks'),
    create: (data: CreateWebhookData) => this.request('POST', '/v1/webhooks', { data }),
    test: (id: string) => this.request('POST', `/v1/webhooks/${id}/test`),
    delete: (id: string) => this.request('DELETE', `/v1/webhooks/${id}`)
  };

  private async request(method: string, endpoint: string, options: RequestOptions = {}): Promise<any> {
    const url = new URL(this.baseUrl + endpoint);
    
    // Ajout des paramètres de query
    if (options.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== undefined) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'User-Agent': 'BasMalinSDK/1.0.0'
    };

    // Authentification
    if (this.accessToken) {
      headers.Authorization = `Bearer ${this.accessToken}`;
    } else if (this.apiKey) {
      headers.Authorization = `ApiKey ${this.apiKey}`;
    }

    const config: RequestInit = {
      method,
      headers,
      ...(options.data && { body: JSON.stringify(options.data) })
    };

    const response = await fetch(url.toString(), config);
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new SDKError(error.error || 'Request failed', response.status, error);
    }

    return response.json();
  }
}

// Usage example
const sdk = new BasMalinSDK({
  apiKey: 'bm_your_api_key_here'
});

// List gardens
const gardens = await sdk.gardens.list({ page: 1, limit: 10 });

// Create harvest
const harvest = await sdk.harvests.create('garden-id', {
  cultureId: 'culture-id',
  quantity: 2.5,
  unit: 'kg',
  date: '2024-08-20',
  notes: 'Excellent harvest!'
});

// Setup webhook
const webhook = await sdk.webhooks.create({
  url: 'https://myapp.com/webhooks/basmalin',
  events: ['harvest.created', 'alert.triggered']
});
```

## Critères d'Acceptation Techniques

### API REST
- [ ] OpenAPI 3.0 documentation complète
- [ ] Authentification OAuth2 + API Keys
- [ ] Rate limiting configurable par utilisateur
- [ ] Versioning avec rétrocompatibilité
- [ ] SDK officiels (JS, Python, PHP)

### Webhooks
- [ ] Support 10+ types d'événements
- [ ] Retry automatique avec backoff exponentiel
- [ ] Signature HMAC pour sécurité
- [ ] Logs détaillés des livraisons
- [ ] Test endpoints intégré

### Marketplace Extensions
- [ ] Store avec recherche et catégories
- [ ] Sandbox sécurisé pour extensions
- [ ] Système de permissions granulaires
- [ ] Reviews et ratings communautaires
- [ ] Installation/mise à jour automatique

## Couverture Exigences Architecture

- **EXG-010.1** : API REST complète et documentée
- **EXG-008.1** : Authentification OAuth2 sécurisée
- **EXG-009.1** : Monitoring API et rate limiting
- **EXG-007.1** : Webhooks temps réel

## Tests d'Acceptation

```typescript
// tests/integration/api.test.ts
describe('API Integration', () => {
  test('authentification API key fonctionne', async () => {
    const response = await fetch('/api/v1/gardens', {
      headers: { Authorization: 'ApiKey test_key' }
    });
    
    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.gardens).toBeDefined();
  });

  test('rate limiting appliqué correctement', async () => {
    // Dépasser la limite
    const promises = Array(101).fill(null).map(() => 
      fetch('/api/v1/gardens', {
        headers: { Authorization: 'ApiKey test_key' }
      })
    );

    const responses = await Promise.all(promises);
    const rateLimited = responses.filter(r => r.status === 429);
    expect(rateLimited.length).toBeGreaterThan(0);
  });

  test('webhook livraison avec retry', async () => {
    const webhook = await webhookService.createWebhook('user-1', {
      url: 'https://httpbin.org/status/500', // Simule erreur
      events: ['harvest.created']
    });

    await webhookService.triggerWebhooks('harvest.created', { test: true }, 'user-1');

    // Vérifier tentatives de retry
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    const delivery = await prisma.webhookDelivery.findFirst({
      where: { webhookId: webhook.id }
    });
    
    expect(delivery.attempts).toBeGreaterThan(1);
  });
});
```

Cette spécification couvre une API complète avec authentification, webhooks et marketplace d'extensions pour un écosystème ouvert et extensible.