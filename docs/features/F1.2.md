# **F1.2 - Synchronisation Multi-Device**

## **üìã Informations g√©n√©rales**
- **Score de priorit√©** : 95/100 ‚≠ê CRITIQUE
- **EPIC** : FONDATIONS
- **Complexit√©** : Tr√®s √©lev√©e (architecture distribu√©e)
- **Devices** : üì±üíªüì∫

## **üéØ Description**
Architecture de synchronisation temps r√©el entre mobile, desktop et TV permettant une exp√©rience unifi√©e cross-device avec mode offline mobile, queue de synchronisation diff√©r√©e et r√©solution automatique des conflits de donn√©es.

## **üë• User Stories**

### **Utilisateur Mobile ‚Üí Desktop**
- En tant qu'utilisateur mobile, je veux que mes saisies de r√©coltes apparaissent instantan√©ment sur desktop
- En tant qu'utilisateur mobile, je veux pouvoir travailler offline avec synchronisation automatique √† la reconnexion

### **Utilisateur Desktop ‚Üí TV**
- En tant qu'utilisateur desktop, je veux que mes planifications apparaissent imm√©diatement sur l'√©cran TV
- En tant qu'utilisateur, je veux une exp√©rience fluide en passant d'un device √† l'autre

### **Syst√®me**
- En tant que syst√®me, je dois synchroniser les donn√©es < 3 secondes entre devices
- En tant que syst√®me, je dois r√©soudre automatiquement les conflits de donn√©es
- En tant que syst√®me, je dois garantir la coh√©rence des donn√©es m√™me offline

## **üèóÔ∏è Architecture technique**

### **Architecture de synchronisation hybride**
```typescript
// Service de synchronisation principal
export class MultiDeviceSyncService {
  private websocket: WebSocket;
  private syncQueue: Queue;
  private conflictResolver: ConflictResolver;
  private offlineStore: OfflineStore;

  constructor() {
    this.websocket = new WebSocket(process.env.WS_ENDPOINT);
    this.syncQueue = new Queue('device-sync', { connection: redis });
    this.conflictResolver = new ConflictResolver();
    this.offlineStore = new OfflineStore();
  }

  // Synchronisation temps r√©el via WebSocket
  async broadcastChange(change: DataChange) {
    const message: SyncMessage = {
      id: generateId(),
      type: 'DATA_CHANGE',
      entity: change.entity,
      operation: change.operation, // CREATE, UPDATE, DELETE
      data: change.data,
      userId: change.userId,
      deviceId: change.deviceId,
      timestamp: new Date().toISOString(),
      version: change.version
    };

    // 1. Broadcast √† tous les devices connect√©s
    this.websocket.send(JSON.stringify(message));
    
    // 2. Fallback queue pour devices offline
    await this.syncQueue.add('sync-change', message, {
      delay: 0,
      attempts: 5,
      backoff: 'exponential'
    });

    return message.id;
  }

  // Gestion mode offline mobile
  async handleOfflineChange(change: DataChange) {
    // Stockage local avec timestamp
    await this.offlineStore.store(change);
    
    // Marquage pour sync future
    await this.offlineStore.markForSync(change.id);
  }

  // Synchronisation √† la reconnexion
  async syncOfflineChanges() {
    const pendingChanges = await this.offlineStore.getPendingSync();
    
    for (const change of pendingChanges) {
      try {
        // Conflict detection avant sync
        const conflict = await this.detectConflict(change);
        
        if (conflict) {
          const resolved = await this.conflictResolver.resolve(conflict);
          await this.applySyncedChange(resolved);
        } else {
          await this.applySyncedChange(change);
        }
        
        // Marquer comme synchronis√©
        await this.offlineStore.markSynced(change.id);
        
      } catch (error) {
        console.error('Sync error:', error);
        await this.offlineStore.markFailed(change.id, error);
      }
    }
  }
}

interface SyncMessage {
  id: string;
  type: 'DATA_CHANGE' | 'CONFLICT_RESOLUTION' | 'SYNC_REQUEST';
  entity: string; // 'recolte', 'intervention', etc.
  operation: 'CREATE' | 'UPDATE' | 'DELETE';
  data: any;
  userId: string;
  deviceId: string;
  timestamp: string;
  version: number;
}

interface DataChange {
  id: string;
  entity: string;
  operation: 'CREATE' | 'UPDATE' | 'DELETE';
  data: any;
  userId: string;
  deviceId: string;
  timestamp: Date;
  version: number;
}
```

### **WebSocket real-time communication**
```typescript
// WebSocket server (Next.js API Route)
// /src/app/api/ws/sync/route.ts
import { NextRequest } from 'next/server';
import { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 3001 });
const deviceConnections = new Map<string, WebSocket>();

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const deviceId = url.searchParams.get('deviceId');
  const userId = url.searchParams.get('userId');

  wss.on('connection', (ws, req) => {
    // Enregistrer la connexion device
    deviceConnections.set(deviceId, ws);
    
    console.log(`Device ${deviceId} connected for user ${userId}`);

    ws.on('message', async (data) => {
      const message: SyncMessage = JSON.parse(data.toString());
      
      // Broadcast √† tous les autres devices du m√™me user
      const userDevices = getUserDevices(userId);
      
      userDevices.forEach((deviceWs, otherDeviceId) => {
        if (otherDeviceId !== deviceId && deviceWs.readyState === WebSocket.OPEN) {
          deviceWs.send(JSON.stringify(message));
        }
      });

      // Persistence en base pour consistency
      await persistSyncMessage(message);
    });

    ws.on('close', () => {
      deviceConnections.delete(deviceId);
      console.log(`Device ${deviceId} disconnected`);
    });
  });
}

// Client WebSocket hook
export const useSyncConnection = (userId: string, deviceId: string) => {
  const [ws, setWs] = useState<WebSocket>();
  const [isConnected, setIsConnected] = useState(false);
  const [syncStatus, setSyncStatus] = useState<'connected' | 'offline' | 'syncing'>('offline');

  useEffect(() => {
    const websocket = new WebSocket(
      `ws://localhost:3001?userId=${userId}&deviceId=${deviceId}`
    );

    websocket.onopen = () => {
      setIsConnected(true);
      setSyncStatus('connected');
      
      // Sync offline changes √† la reconnexion
      syncService.syncOfflineChanges();
    };

    websocket.onmessage = (event) => {
      const message: SyncMessage = JSON.parse(event.data);
      handleIncomingSync(message);
    };

    websocket.onclose = () => {
      setIsConnected(false);
      setSyncStatus('offline');
      
      // Retry connection avec backoff
      setTimeout(() => {
        setWs(websocket);
      }, 5000);
    };

    setWs(websocket);

    return () => websocket.close();
  }, [userId, deviceId]);

  return { ws, isConnected, syncStatus };
};
```

### **R√©solution automatique des conflits**
```typescript
export class ConflictResolver {
  // Strat√©gies de r√©solution selon le type de donn√©es
  async resolve(conflict: DataConflict): Promise<DataChange> {
    const strategy = this.getResolutionStrategy(conflict.entity);
    
    switch (strategy) {
      case 'LAST_WRITE_WINS':
        return this.lastWriteWins(conflict);
      
      case 'MERGE_FIELDS':
        return this.mergeFields(conflict);
      
      case 'USER_PRIORITY':
        return this.resolveByCr√©dit(conflict);
      
      default:
        throw new Error(`No resolution strategy for ${conflict.entity}`);
    }
  }

  private getResolutionStrategy(entity: string): ConflictStrategy {
    const strategies: Record<string, ConflictStrategy> = {
      'recolte': 'LAST_WRITE_WINS',      // R√©coltes : derni√®re modification gagne
      'intervention': 'MERGE_FIELDS',    // Interventions : merge des champs
      'planning': 'USER_PRIORITY',       // Planning : priorit√© utilisateur expert
      'preference': 'DEVICE_SPECIFIC'    // Pr√©f√©rences : par device
    };
    
    return strategies[entity] || 'LAST_WRITE_WINS';
  }

  private async lastWriteWins(conflict: DataConflict): Promise<DataChange> {
    // La modification la plus r√©cente prend la priorit√©
    const latest = conflict.changes.reduce((latest, change) => 
      change.timestamp > latest.timestamp ? change : latest
    );
    
    return latest;
  }

  private async mergeFields(conflict: DataConflict): Promise<DataChange> {
    // Merge intelligent des champs modifi√©s
    const merged = { ...conflict.current };
    
    conflict.changes.forEach(change => {
      Object.keys(change.data).forEach(field => {
        // Field-level conflict resolution
        if (change.timestamp > conflict.current.timestamp) {
          merged[field] = change.data[field];
        }
      });
    });

    return {
      ...conflict.changes[0],
      data: merged,
      operation: 'UPDATE'
    };
  }

  private async resolveByCr√©dit(conflict: DataConflict): Promise<DataChange> {
    // Priorit√© selon le profil utilisateur (Expert > Occasionnel)
    const expertChange = conflict.changes.find(change => 
      change.userProfile === 'EXPERT'
    );
    
    return expertChange || conflict.changes[0];
  }
}

interface DataConflict {
  entity: string;
  recordId: string;
  current: any;
  changes: DataChange[];
  conflictType: 'CONCURRENT_UPDATE' | 'DELETE_UPDATE' | 'CREATE_DUPLICATE';
}

type ConflictStrategy = 'LAST_WRITE_WINS' | 'MERGE_FIELDS' | 'USER_PRIORITY' | 'DEVICE_SPECIFIC';
```

### **Offline storage avec sync queue**
```typescript
// Service de stockage offline (IndexedDB mobile, LocalStorage desktop)
export class OfflineStore {
  private db: IDBDatabase;
  
  async store(change: DataChange) {
    const transaction = this.db.transaction(['offline_changes'], 'readwrite');
    const store = transaction.objectStore('offline_changes');
    
    await store.add({
      ...change,
      storedAt: new Date().toISOString(),
      synced: false,
      failed: false
    });
  }

  async getPendingSync(): Promise<DataChange[]> {
    const transaction = this.db.transaction(['offline_changes'], 'readonly');
    const store = transaction.objectStore('offline_changes');
    
    const request = store.getAll();
    const all = await request;
    
    return all.filter(change => !change.synced && !change.failed);
  }

  async markSynced(changeId: string) {
    const transaction = this.db.transaction(['offline_changes'], 'readwrite');
    const store = transaction.objectStore('offline_changes');
    
    const change = await store.get(changeId);
    change.synced = true;
    change.syncedAt = new Date().toISOString();
    
    await store.put(change);
  }
}

// Hook pour mode offline
export const useOfflineSync = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [pendingChanges, setPendingChanges] = useState<DataChange[]>([]);
  
  useEffect(() => {
    const handleOnline = async () => {
      setIsOnline(true);
      
      // D√©marrer sync des changements offline
      const changes = await offlineStore.getPendingSync();
      setPendingChanges(changes);
      
      await syncService.syncOfflineChanges();
      setPendingChanges([]);
    };

    const handleOffline = () => {
      setIsOnline(false);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return { 
    isOnline, 
    pendingChanges: pendingChanges.length,
    hasPendingSync: pendingChanges.length > 0
  };
};
```

## **üì± Interface mobile (Mode offline prioritaire)**

### **Indicateurs de synchronisation**
```typescript
const MobileSyncIndicator = () => {
  const { isOnline, pendingChanges, hasPendingSync } = useOfflineSync();
  const { syncStatus } = useSyncConnection();

  return (
    <div className="fixed top-4 right-4 z-50">
      <div className={`px-3 py-2 rounded-lg text-white text-sm ${
        syncStatus === 'connected' ? 'bg-green-500' :
        syncStatus === 'syncing' ? 'bg-yellow-500' : 
        'bg-red-500'
      }`}>
        <div className="flex items-center space-x-2">
          {syncStatus === 'connected' && (
            <>
              <CheckCircle size={16} />
              <span>Synchronis√©</span>
            </>
          )}
          
          {syncStatus === 'syncing' && (
            <>
              <RefreshCw size={16} className="animate-spin" />
              <span>Synchronisation...</span>
            </>
          )}
          
          {syncStatus === 'offline' && (
            <>
              <WifiOff size={16} />
              <span>
                Hors ligne
                {hasPendingSync && ` (${pendingChanges} en attente)`}
              </span>
            </>
          )}
        </div>
      </div>
    </div>
  );
};

// Composant saisie avec offline-first
const OfflineRecolteForm = () => {
  const [formData, setFormData] = useState<RecolteInput>();
  const { isOnline } = useOfflineSync();
  const { mutate: createRecolte } = useCreateRecolteMutation();

  const handleSubmit = async (data: RecolteInput) => {
    if (isOnline) {
      // Online : synchronisation imm√©diate
      await createRecolte(data);
    } else {
      // Offline : stockage local
      const change: DataChange = {
        id: generateId(),
        entity: 'recolte',
        operation: 'CREATE',
        data: data,
        userId: session.user.id,
        deviceId: getDeviceId(),
        timestamp: new Date(),
        version: 1
      };
      
      await offlineStore.store(change);
      
      // UI feedback offline
      showToast("R√©colte enregistr√©e (sera synchronis√©e)");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Formulaire r√©colte avec indicateur offline */}
      {!isOnline && (
        <Alert variant="info" className="mb-4">
          <WifiOff className="h-4 w-4" />
          <AlertDescription>
            Mode hors ligne. Vos donn√©es seront synchronis√©es √† la reconnexion.
          </AlertDescription>
        </Alert>
      )}
      
      {/* Formulaire normal */}
      <RecolteFormFields data={formData} onChange={setFormData} />
      
      <Button type="submit" className="w-full">
        {isOnline ? 'Enregistrer' : 'Enregistrer (hors ligne)'}
      </Button>
    </form>
  );
};
```

## **üíª Desktop (Centre de contr√¥le sync)**

### **Dashboard de synchronisation**
```typescript
const SyncControlDashboard = () => {
  const { data: syncStats } = useSyncStats();
  const { data: deviceConnections } = useDeviceConnections();
  const [resolvingConflicts, setResolvingConflicts] = useState<DataConflict[]>([]);

  return (
    <div className="space-y-6">
      {/* √âtat des devices connect√©s */}
      <Card>
        <CardHeader>
          <CardTitle>Appareils connect√©s</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-3 gap-4">
            {deviceConnections.map(device => (
              <DeviceConnectionCard 
                key={device.id}
                device={device}
                isOnline={device.lastSeen < Date.now() - 30000}
              />
            ))}
          </div>
        </CardContent>
      </Card>

      {/* M√©triques de synchronisation */}
      <div className="grid grid-cols-4 gap-4">
        <MetricCard 
          title="Sync aujourd'hui"
          value={syncStats.dailySync}
          unit="op√©rations"
        />
        <MetricCard 
          title="Latence moyenne"
          value={syncStats.avgLatency}
          unit="ms"
          target="< 3000ms"
        />
        <MetricCard 
          title="Conflits r√©solus"
          value={syncStats.conflictsResolved}
          unit="conflits"
        />
        <MetricCard 
          title="Uptime sync"
          value={syncStats.uptime}
          unit="%"
          target="> 99%"
        />
      </div>

      {/* R√©solution manuelle des conflits */}
      {resolvingConflicts.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="text-yellow-600">
              Conflits n√©cessitant une r√©solution manuelle
            </CardTitle>
          </CardHeader>
          <CardContent>
            {resolvingConflicts.map(conflict => (
              <ConflictResolutionCard 
                key={conflict.recordId}
                conflict={conflict}
                onResolve={handleManualResolution}
              />
            ))}
          </CardContent>
        </Card>
      )}
    </div>
  );
};

const DeviceConnectionCard = ({ device, isOnline }) => (
  <div className={`p-4 rounded-lg border ${isOnline ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'}`}>
    <div className="flex items-center space-x-3">
      <div className="text-2xl">
        {device.type === 'mobile' ? 'üì±' : device.type === 'desktop' ? 'üíª' : 'üì∫'}
      </div>
      <div>
        <h3 className="font-medium">{device.name}</h3>
        <p className="text-sm text-gray-500">
          {isOnline ? 'Connect√©' : `Vu il y a ${formatDistance(device.lastSeen, Date.now())}`}
        </p>
        {device.pendingSync > 0 && (
          <p className="text-sm text-yellow-600">
            {device.pendingSync} modifications en attente
          </p>
        )}
      </div>
    </div>
  </div>
);
```

### **R√©solution manuelle des conflits**
```typescript
const ConflictResolutionCard = ({ conflict, onResolve }) => {
  const [selectedResolution, setSelectedResolution] = useState<'current' | 'incoming' | 'merged'>();

  return (
    <div className="border-l-4 border-yellow-400 bg-yellow-50 p-4 rounded">
      <div className="flex justify-between items-start mb-4">
        <div>
          <h3 className="text-lg font-medium text-yellow-800">
            Conflit sur {conflict.entity} #{conflict.recordId}
          </h3>
          <p className="text-yellow-700">
            Modifications concurrentes d√©tect√©es
          </p>
        </div>
        <Badge variant="warning">
          {conflict.changes.length} versions
        </Badge>
      </div>

      {/* Comparaison des versions */}
      <div className="grid grid-cols-2 gap-4 mb-4">
        <div className="bg-white p-3 rounded border">
          <h4 className="font-medium text-gray-800 mb-2">Version actuelle</h4>
          <pre className="text-sm text-gray-600">
            {JSON.stringify(conflict.current, null, 2)}
          </pre>
        </div>
        
        <div className="bg-white p-3 rounded border">
          <h4 className="font-medium text-gray-800 mb-2">Version entrante</h4>
          <pre className="text-sm text-gray-600">
            {JSON.stringify(conflict.changes[0].data, null, 2)}
          </pre>
        </div>
      </div>

      {/* Options de r√©solution */}
      <div className="flex space-x-4">
        <Button
          variant={selectedResolution === 'current' ? 'default' : 'outline'}
          onClick={() => setSelectedResolution('current')}
        >
          Garder actuelle
        </Button>
        
        <Button
          variant={selectedResolution === 'incoming' ? 'default' : 'outline'}
          onClick={() => setSelectedResolution('incoming')}
        >
          Accepter entrante
        </Button>
        
        <Button
          variant={selectedResolution === 'merged' ? 'default' : 'outline'}
          onClick={() => setSelectedResolution('merged')}
        >
          Fusionner
        </Button>
        
        <Button 
          onClick={() => onResolve(conflict.recordId, selectedResolution)}
          disabled={!selectedResolution}
          className="ml-auto"
        >
          R√©soudre
        </Button>
      </div>
    </div>
  );
};
```

## **üì∫ TV (Status monitoring)**

### **Monitoring temps r√©el**
```typescript
const TVSyncMonitoring = () => {
  const { data: realtimeStats } = useRealtimeSyncStats();
  
  return (
    <div className="h-screen bg-gradient-to-br from-blue-900 to-indigo-900 text-white">
      {/* Header with global sync status */}
      <div className="p-8 text-center">
        <h1 className="text-4xl font-bold mb-4">√âtat de synchronisation</h1>
        
        <div className="flex justify-center space-x-12">
          <TVSyncMetric
            icon="‚ö°"
            label="Latence moyenne"
            value={`${realtimeStats.avgLatency}ms`}
            status={realtimeStats.avgLatency < 3000 ? 'good' : 'warning'}
          />
          
          <TVSyncMetric
            icon="üîÑ"
            label="Sync aujourd'hui"
            value={realtimeStats.todaySync}
            status="good"
          />
          
          <TVSyncMetric
            icon="üì±"
            label="Devices actifs"
            value={realtimeStats.activeDevices}
            status="good"
          />
        </div>
      </div>

      {/* Live activity feed */}
      <div className="px-8 py-4">
        <h2 className="text-2xl mb-6">Activit√© en temps r√©el</h2>
        
        <div className="space-y-3 max-h-96 overflow-y-auto">
          {realtimeStats.recentActivity.map((activity, index) => (
            <motion.div
              key={activity.id}
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: index * 0.1 }}
              className="flex items-center space-x-4 bg-white bg-opacity-10 p-4 rounded-lg"
            >
              <div className="text-2xl">
                {activity.device === 'mobile' ? 'üì±' : 
                 activity.device === 'desktop' ? 'üíª' : 'üì∫'}
              </div>
              
              <div className="flex-1">
                <p className="font-medium">
                  {activity.operation} {activity.entity}
                </p>
                <p className="text-sm opacity-75">
                  {activity.user} ‚Ä¢ {formatDistance(activity.timestamp, Date.now())}
                </p>
              </div>
              
              <div className="text-right">
                <Badge 
                  variant={activity.status === 'synced' ? 'success' : 'warning'}
                  className="text-xs"
                >
                  {activity.latency}ms
                </Badge>
              </div>
            </motion.div>
          ))}
        </div>
      </div>
    </div>
  );
};

const TVSyncMetric = ({ icon, label, value, status }) => (
  <div className="text-center">
    <div className="text-6xl mb-2">{icon}</div>
    <div className="text-3xl font-bold mb-1">{value}</div>
    <div className="text-lg opacity-75">{label}</div>
    <div className={`text-sm mt-2 px-3 py-1 rounded-full ${
      status === 'good' ? 'bg-green-500' : 
      status === 'warning' ? 'bg-yellow-500' : 
      'bg-red-500'
    }`}>
      {status === 'good' ? 'Normal' : 'Attention'}
    </div>
  </div>
);
```

## **‚úÖ Crit√®res d'acceptation**

### **Performance**
- [ ] **Synchronisation < 3 secondes entre devices** (EXG-003.3)
- [ ] WebSocket connexion stable > 99% uptime
- [ ] Latence WebSocket < 100ms sur r√©seau local
- [ ] Queue offline max 1000 op√©rations stock√©es

### **Fonctionnalit√©s**
- [ ] **Mode offline mobile** avec saisie compl√®te
- [ ] **Queue de synchronisation** diff√©r√©e √† la reconnexion
- [ ] **R√©solution automatique** des conflits simples
- [ ] **Interface manuelle** pour conflits complexes

### **Robustesse**
- [ ] Reconnexion automatique WebSocket (backoff exponential)
- [ ] D√©tection de conflits field-level
- [ ] Gestion des timeouts et erreurs r√©seau
- [ ] Rollback en cas d'√©chec de synchronisation

### **Monitoring**
- [ ] Dashboard temps r√©el des connexions devices
- [ ] M√©triques de performance et latence
- [ ] Logs d√©taill√©s pour debugging
- [ ] Alertes en cas de probl√®me sync

### **UI/UX**
- [ ] Indicateurs visuels √©tat synchronisation
- [ ] Feedback utilisateur mode offline
- [ ] Interface r√©solution conflits desktop
- [ ] Monitoring TV pour d√©monstration

## **üèóÔ∏è Exigences architecturales couvertes**

- **EXG-001.2** : WebSocket API `/src/app/api/ws/sync/*` ‚úÖ
- **EXG-002.3** : Redis pour queue BullMQ ‚úÖ
- **EXG-003.1** : PWA mode offline fonctionnel ‚úÖ
- **EXG-003.3** : Synchronisation temps r√©el < 3 secondes ‚úÖ
- **EXG-007.1** : PM2 cluster pour charge WebSocket ‚úÖ
- **EXG-007.2** : Gestion m√©moire optimis√©e (queue size) ‚úÖ
- **EXG-007.3** : Performance sync < 2s hors conflits ‚úÖ
- **EXG-010.1** : Logs structur√©s Winston pour sync ‚úÖ

## **üöÄ Plan d'impl√©mentation**

### **Phase 1 : WebSocket Infrastructure (3j)**
1. Setup WebSocket server Next.js
2. Configuration Redis pour queue BullMQ
3. Service de synchronisation de base
4. Tests de connexion multi-device

### **Phase 2 : Mode Offline Mobile (4j)**
1. IndexedDB storage offline
2. Queue de synchronisation diff√©r√©e
3. D√©tection online/offline
4. Interface indicateurs sync mobile

### **Phase 3 : R√©solution de Conflits (3j)**
1. Algorithmes de d√©tection conflits
2. Strat√©gies r√©solution automatique
3. Interface manuelle desktop
4. Tests scenarios conflits

### **Phase 4 : Monitoring & Dashboard (2j)**
1. M√©triques temps r√©el
2. Interface desktop monitoring
3. TV dashboard spectaculaire
4. Alertes et notifications

### **Phase 5 : Optimisation & Tests (3j)**
1. Tests de charge WebSocket
2. Optimisation performance
3. Gestion erreurs robuste
4. Documentation compl√®te

**Dur√©e totale estim√©e : 15 jours**