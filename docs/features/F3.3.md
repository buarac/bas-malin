# F3.3 - Tableaux de Bord & Analytics

**Score Priorité :** 80/100  
**Statut :** PRIORITÉ MOYENNE  
**Epic :** EPIC 3 - PILIER COMPRENDRE  
**Effort estimé :** 16 jours  

## Description

Tableaux de bord interactifs et analytics avancés avec visualisations temps réel, métriques de performance du jardin, analyses de tendances et rapports personnalisables pour optimiser les décisions de jardinage basées sur les données.

## User Stories

### US3.3.1 - Dashboard Temps Réel
**En tant qu'** expert jardinier  
**Je veux** voir l'état de mon jardin en temps réel  
**Afin de** prendre des décisions éclairées rapidement  

**Critères d'acceptation :**
- Vue d'ensemble des métriques clés en temps réel
- Graphiques interactifs avec drill-down
- Alertes visuelles pour situations critiques
- Refresh automatique des données (< 30s)
- Personnalisation de la disposition des widgets

### US3.3.2 - Analytics Historiques
**En tant qu'** utilisateur occasionnel  
**Je veux** analyser l'évolution de mon jardin dans le temps  
**Afin de** comprendre les patterns et améliorer mes pratiques  

**Critères d'acceptation :**
- Graphiques de tendances sur différentes périodes
- Comparaisons année sur année
- Corrélations entre variables (météo, interventions, rendement)
- Export des données et graphiques
- Insights automatiques sur les tendances

### US3.3.3 - Rapports Personnalisés
**En tant qu'** utilisateur avancé  
**Je veux** créer des rapports sur mesure  
**Afin de** partager des analyses avec d'autres jardiniers  

**Critères d'acceptation :**
- Builder de rapports drag & drop
- Templates prédéfinis (mensuel, saisonnier, annuel)
- Export PDF/Excel avec branding personnalisé
- Programmation d'envoi automatique
- Partage via liens sécurisés

## Architecture Technique

### Service Analytics Central

```typescript
// src/services/analytics/analytics.service.ts
export interface AnalyticsQuery {
  metrics: MetricDefinition[];
  dimensions: DimensionDefinition[];
  filters: FilterDefinition[];
  timeRange: TimeRange;
  granularity: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';
  aggregation: AggregationType;
}

export interface MetricDefinition {
  name: string;
  type: 'count' | 'sum' | 'avg' | 'min' | 'max' | 'unique';
  field: string;
  alias?: string;
  calculation?: string; // SQL expression custom
}

export interface DashboardWidget {
  id: string;
  type: 'chart' | 'metric' | 'table' | 'map' | 'gauge';
  title: string;
  position: { x: number; y: number; w: number; h: number };
  config: WidgetConfig;
  query: AnalyticsQuery;
  refreshInterval: number; // en secondes
}

export interface AnalyticsResult {
  data: AnalyticsDataPoint[];
  metadata: {
    totalRows: number;
    executionTime: number;
    cacheHit: boolean;
    queryHash: string;
  };
  insights?: AutoInsight[];
}

export class AnalyticsService {
  private queryCache: Map<string, CachedResult> = new Map();
  private realTimeSubscriptions: Map<string, WebSocket[]> = new Map();

  constructor(
    private prisma: PrismaClient,
    private redis: Redis,
    private timeseries: InfluxDBService
  ) {}

  async executeQuery(query: AnalyticsQuery): Promise<AnalyticsResult> {
    // Génération du hash pour cache
    const queryHash = this.generateQueryHash(query);
    
    // Vérification cache
    const cached = await this.getCachedResult(queryHash);
    if (cached && !this.isStale(cached, query.timeRange)) {
      return {
        ...cached.result,
        metadata: { ...cached.result.metadata, cacheHit: true }
      };
    }

    const startTime = Date.now();
    
    // Construction et exécution de la requête
    const sqlQuery = this.buildSQLQuery(query);
    const rawData = await this.executeSQL(sqlQuery);
    
    // Post-traitement et agrégation
    const processedData = this.processRawData(rawData, query);
    
    // Génération d'insights automatiques
    const insights = await this.generateAutoInsights(processedData, query);
    
    const result: AnalyticsResult = {
      data: processedData,
      metadata: {
        totalRows: rawData.length,
        executionTime: Date.now() - startTime,
        cacheHit: false,
        queryHash
      },
      insights
    };

    // Mise en cache
    await this.cacheResult(queryHash, result, query);
    
    return result;
  }

  private buildSQLQuery(query: AnalyticsQuery): string {
    const { metrics, dimensions, filters, timeRange, granularity } = query;
    
    // SELECT clause avec métriques
    const selectClauses = [
      ...this.buildMetricClauses(metrics),
      ...this.buildDimensionClauses(dimensions),
      this.buildTimeBucket(granularity)
    ];

    // FROM clause avec joins optimisés
    const fromClause = this.buildFromClause(metrics, dimensions);
    
    // WHERE clause avec filtres
    const whereClauses = [
      this.buildTimeFilter(timeRange),
      ...this.buildFilterClauses(filters)
    ];

    // GROUP BY clause
    const groupByClauses = [
      'time_bucket',
      ...dimensions.map(d => d.field)
    ];

    // Assemblage final
    return `
      SELECT ${selectClauses.join(', ')}
      ${fromClause}
      WHERE ${whereClauses.filter(Boolean).join(' AND ')}
      GROUP BY ${groupByClauses.join(', ')}
      ORDER BY time_bucket ASC
    `;
  }

  private buildMetricClauses(metrics: MetricDefinition[]): string[] {
    return metrics.map(metric => {
      const alias = metric.alias || metric.name;
      
      switch (metric.type) {
        case 'count':
          return `COUNT(${metric.field}) as ${alias}`;
        case 'sum':
          return `SUM(${metric.field}) as ${alias}`;
        case 'avg':
          return `AVG(${metric.field}) as ${alias}`;
        case 'min':
          return `MIN(${metric.field}) as ${alias}`;
        case 'max':
          return `MAX(${metric.field}) as ${alias}`;
        case 'unique':
          return `COUNT(DISTINCT ${metric.field}) as ${alias}`;
        default:
          return metric.calculation || `${metric.field} as ${alias}`;
      }
    });
  }

  private buildTimeBucket(granularity: string): string {
    const intervalMap = {
      minute: '1 minute',
      hour: '1 hour',
      day: '1 day',
      week: '1 week',
      month: '1 month',
      year: '1 year'
    };

    return `DATE_TRUNC('${granularity}', created_at) as time_bucket`;
  }

  async generateAutoInsights(data: AnalyticsDataPoint[], query: AnalyticsQuery): Promise<AutoInsight[]> {
    const insights: AutoInsight[] = [];

    // Détection de tendances
    const trendInsight = this.detectTrends(data);
    if (trendInsight) insights.push(trendInsight);

    // Détection d'anomalies
    const anomalies = this.detectAnomalies(data);
    insights.push(...anomalies);

    // Comparaisons périodiques
    const comparisons = await this.generateComparisons(data, query);
    insights.push(...comparisons);

    // Corrélations
    const correlations = this.findCorrelations(data);
    insights.push(...correlations);

    return insights;
  }

  private detectTrends(data: AnalyticsDataPoint[]): AutoInsight | null {
    if (data.length < 3) return null;

    const values = data.map(d => d.value as number).filter(v => v !== null);
    if (values.length < 3) return null;

    // Calcul de la régression linéaire simple
    const n = values.length;
    const x = Array.from({length: n}, (_, i) => i);
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = values.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);
    const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    // R² pour mesurer la qualité de la tendance
    const yMean = sumY / n;
    const ssRes = values.reduce((sum, yi, i) => {
      const predicted = slope * i + intercept;
      return sum + Math.pow(yi - predicted, 2);
    }, 0);
    const ssTot = values.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
    const rSquared = 1 - (ssRes / ssTot);

    if (rSquared < 0.6) return null; // Tendance pas assez forte

    const trendType = slope > 0 ? 'increasing' : 'decreasing';
    const strength = Math.abs(slope) > 1 ? 'strong' : 'moderate';
    
    return {
      type: 'trend',
      title: `Tendance ${trendType === 'increasing' ? 'croissante' : 'décroissante'} détectée`,
      description: `Les données montrent une tendance ${trendType === 'increasing' ? 'à la hausse' : 'à la baisse'} ${strength} (R² = ${rSquared.toFixed(2)})`,
      confidence: rSquared,
      metadata: { slope, intercept, rSquared, trend: trendType }
    };
  }

  async createRealTimeSubscription(widgetId: string, query: AnalyticsQuery): Promise<void> {
    const queryHash = this.generateQueryHash(query);
    
    // Exécution initiale
    const initialResult = await this.executeQuery(query);
    
    // Setup WebSocket pour updates temps réel
    setInterval(async () => {
      try {
        const newResult = await this.executeQuery(query);
        
        // Comparaison avec résultat précédent
        if (this.hasDataChanged(initialResult, newResult)) {
          this.broadcastUpdate(widgetId, newResult);
        }
      } catch (error) {
        console.error(`Real-time update failed for widget ${widgetId}:`, error);
      }
    }, query.refreshInterval || 30000);
  }
}
```

### Builder de Dashboard

```typescript
// src/services/analytics/dashboard-builder.service.ts
export class DashboardBuilderService {
  constructor(private analyticsService: AnalyticsService) {}

  async createDashboard(config: DashboardConfig): Promise<Dashboard> {
    const dashboard: Dashboard = {
      id: generateId(),
      name: config.name,
      description: config.description,
      widgets: [],
      layout: config.layout || 'grid',
      filters: config.globalFilters || [],
      refreshInterval: config.refreshInterval || 300,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Création des widgets par défaut selon le template
    if (config.template) {
      dashboard.widgets = await this.createTemplateWidgets(config.template);
    }

    return dashboard;
  }

  private async createTemplateWidgets(template: DashboardTemplate): Promise<DashboardWidget[]> {
    const templates = {
      garden_overview: [
        {
          type: 'metric' as const,
          title: 'Cultures Actives',
          position: { x: 0, y: 0, w: 3, h: 2 },
          query: {
            metrics: [{ name: 'active_crops', type: 'count' as const, field: 'id' }],
            dimensions: [],
            filters: [{ field: 'statut', operator: 'eq', value: 'active' }],
            timeRange: { start: new Date(), end: new Date() },
            granularity: 'day' as const
          }
        },
        {
          type: 'chart' as const,
          title: 'Évolution Température',
          position: { x: 3, y: 0, w: 6, h: 4 },
          query: {
            metrics: [{ name: 'temperature', type: 'avg' as const, field: 'valeur' }],
            dimensions: [],
            filters: [{ field: 'type', operator: 'eq', value: 'temperature' }],
            timeRange: { start: new Date(Date.now() - 7*24*60*60*1000), end: new Date() },
            granularity: 'hour' as const
          },
          config: {
            chartType: 'line',
            showTrend: true,
            colors: ['#22c55e']
          }
        },
        {
          type: 'gauge' as const,
          title: 'Humidité Sol',
          position: { x: 9, y: 0, w: 3, h: 2 },
          query: {
            metrics: [{ name: 'soil_moisture', type: 'avg' as const, field: 'valeur' }],
            dimensions: [],
            filters: [{ field: 'type', operator: 'eq', value: 'soil_moisture' }],
            timeRange: { start: new Date(Date.now() - 60*60*1000), end: new Date() },
            granularity: 'minute' as const
          },
          config: {
            min: 0,
            max: 100,
            unit: '%',
            thresholds: [
              { value: 30, color: '#ef4444', label: 'Sec' },
              { value: 70, color: '#22c55e', label: 'Optimal' },
              { value: 90, color: '#3b82f6', label: 'Humide' }
            ]
          }
        }
      ],
      
      harvest_analytics: [
        {
          type: 'chart' as const,
          title: 'Rendement par Culture',
          position: { x: 0, y: 0, w: 6, h: 4 },
          query: {
            metrics: [{ name: 'harvest_weight', type: 'sum' as const, field: 'poids' }],
            dimensions: [{ field: 'variete_nom', alias: 'Variété' }],
            filters: [],
            timeRange: { start: new Date(Date.now() - 365*24*60*60*1000), end: new Date() },
            granularity: 'month' as const
          },
          config: {
            chartType: 'bar',
            stacked: false,
            showValues: true
          }
        },
        {
          type: 'table' as const,
          title: 'Top Performances',
          position: { x: 6, y: 0, w: 6, h: 4 },
          query: {
            metrics: [
              { name: 'total_harvest', type: 'sum' as const, field: 'poids' },
              { name: 'harvest_count', type: 'count' as const, field: 'id' },
              { name: 'avg_weight', type: 'avg' as const, field: 'poids' }
            ],
            dimensions: [{ field: 'variete_nom', alias: 'Variété' }],
            filters: [],
            timeRange: { start: new Date(Date.now() - 365*24*60*60*1000), end: new Date() },
            granularity: 'year' as const
          },
          config: {
            sortBy: 'total_harvest',
            sortOrder: 'desc',
            pageSize: 10
          }
        }
      ]
    };

    const widgets = templates[template] || [];
    
    return widgets.map(widget => ({
      id: generateId(),
      refreshInterval: 30,
      ...widget
    }));
  }
}
```

### Composants de Visualisation

```typescript
// src/components/analytics/Chart.tsx
import { 
  LineChart, 
  BarChart, 
  AreaChart,
  PieChart,
  ResponsiveContainer,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend
} from 'recharts';

export interface ChartProps {
  data: AnalyticsDataPoint[];
  type: 'line' | 'bar' | 'area' | 'pie';
  config: ChartConfig;
  loading?: boolean;
  error?: string;
}

export function Chart({ data, type, config, loading, error }: ChartProps) {
  if (loading) {
    return <ChartSkeleton />;
  }

  if (error) {
    return <ChartError message={error} />;
  }

  const chartProps = {
    data,
    margin: { top: 20, right: 30, left: 20, bottom: 5 }
  };

  const renderChart = () => {
    switch (type) {
      case 'line':
        return (
          <LineChart {...chartProps}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis 
              dataKey={config.xAxis.field}
              tickFormatter={config.xAxis.formatter}
            />
            <YAxis 
              tickFormatter={config.yAxis?.formatter}
              domain={config.yAxis?.domain}
            />
            <Tooltip 
              labelFormatter={config.tooltip?.labelFormatter}
              formatter={config.tooltip?.valueFormatter}
            />
            {config.showLegend && <Legend />}
            {config.metrics.map((metric, index) => (
              <Line
                key={metric.field}
                type="monotone"
                dataKey={metric.field}
                stroke={config.colors[index % config.colors.length]}
                strokeWidth={2}
                dot={config.showDots}
                connectNulls={false}
              />
            ))}
          </LineChart>
        );

      case 'bar':
        return (
          <BarChart {...chartProps}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey={config.xAxis.field} />
            <YAxis />
            <Tooltip />
            {config.showLegend && <Legend />}
            {config.metrics.map((metric, index) => (
              <Bar
                key={metric.field}
                dataKey={metric.field}
                fill={config.colors[index % config.colors.length]}
                radius={[4, 4, 0, 0]}
              />
            ))}
          </BarChart>
        );

      case 'area':
        return (
          <AreaChart {...chartProps}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey={config.xAxis.field} />
            <YAxis />
            <Tooltip />
            {config.showLegend && <Legend />}
            {config.metrics.map((metric, index) => (
              <Area
                key={metric.field}
                type="monotone"
                dataKey={metric.field}
                stackId={config.stacked ? "1" : metric.field}
                stroke={config.colors[index % config.colors.length]}
                fill={config.colors[index % config.colors.length]}
                fillOpacity={0.6}
              />
            ))}
          </AreaChart>
        );

      case 'pie':
        return (
          <PieChart {...chartProps}>
            <Pie
              data={data}
              cx="50%"
              cy="50%"
              outerRadius={80}
              fill="#8884d8"
              dataKey={config.metrics[0].field}
              label={config.showLabels}
            >
              {data.map((entry, index) => (
                <Cell 
                  key={`cell-${index}`} 
                  fill={config.colors[index % config.colors.length]} 
                />
              ))}
            </Pie>
            <Tooltip />
          </PieChart>
        );

      default:
        return null;
    }
  };

  return (
    <div className="w-full h-full">
      <ResponsiveContainer width="100%" height="100%">
        {renderChart()}
      </ResponsiveContainer>
      
      {config.showTrend && (
        <TrendIndicator data={data} metric={config.metrics[0]} />
      )}
    </div>
  );
}

// Composant métrique simple
export function MetricWidget({ value, title, unit, trend, target }: MetricWidgetProps) {
  const trendColor = trend > 0 ? 'text-green-600' : trend < 0 ? 'text-red-600' : 'text-gray-600';
  const progressPercentage = target ? (value / target) * 100 : null;

  return (
    <Card className="p-6">
      <div className="flex items-center justify-between">
        <div>
          <p className="text-sm font-medium text-gray-600">{title}</p>
          <div className="flex items-baseline">
            <p className="text-3xl font-bold text-gray-900">
              {typeof value === 'number' ? value.toLocaleString() : value}
            </p>
            {unit && <span className="ml-1 text-sm text-gray-500">{unit}</span>}
          </div>
        </div>
        
        {trend !== undefined && (
          <div className={`flex items-center ${trendColor}`}>
            {trend > 0 ? (
              <TrendingUpIcon className="w-4 h-4 mr-1" />
            ) : trend < 0 ? (
              <TrendingDownIcon className="w-4 h-4 mr-1" />
            ) : (
              <MinusIcon className="w-4 h-4 mr-1" />
            )}
            <span className="text-sm font-medium">
              {Math.abs(trend).toFixed(1)}%
            </span>
          </div>
        )}
      </div>

      {target && (
        <div className="mt-4">
          <div className="flex justify-between items-center text-sm text-gray-600 mb-1">
            <span>Objectif</span>
            <span>{progressPercentage?.toFixed(0)}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div
              className={`h-2 rounded-full ${
                progressPercentage >= 100 ? 'bg-green-500' : 
                progressPercentage >= 75 ? 'bg-yellow-500' : 'bg-blue-500'
              }`}
              style={{ width: `${Math.min(progressPercentage, 100)}%` }}
            />
          </div>
        </div>
      )}
    </Card>
  );
}
```

### Interface Dashboard

```typescript
// src/app/analytics/page.tsx
export default function AnalyticsPage() {
  const [selectedDashboard, setSelectedDashboard] = useState<string>('overview');
  const [timeRange, setTimeRange] = useState<TimeRange>({
    start: new Date(Date.now() - 7*24*60*60*1000),
    end: new Date()
  });
  const { deviceType } = useResponsive();

  if (deviceType === 'tv') {
    return <AnalyticsTVDashboard timeRange={timeRange} />;
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="border-b bg-white">
        <div className="container mx-auto px-6 py-4">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold">Analytics & Tableaux de Bord</h1>
              <p className="text-gray-600 mt-1">
                Analysez les performances de votre jardin
              </p>
            </div>
            
            <div className="flex items-center space-x-4">
              <TimeRangeSelector 
                value={timeRange}
                onChange={setTimeRange}
              />
              <Button variant="outline">
                <DownloadIcon className="w-4 h-4 mr-2" />
                Exporter
              </Button>
            </div>
          </div>
        </div>
      </div>

      <div className="container mx-auto px-6 py-6">
        <div className="grid grid-cols-12 gap-6">
          {/* Sidebar navigation */}
          <div className="col-span-3">
            <DashboardNavigation 
              selected={selectedDashboard}
              onSelect={setSelectedDashboard}
            />
          </div>

          {/* Main dashboard area */}
          <div className="col-span-9">
            <DashboardRenderer 
              dashboardId={selectedDashboard}
              timeRange={timeRange}
            />
          </div>
        </div>
      </div>
    </div>
  );
}

const DashboardRenderer = ({ dashboardId, timeRange }: {
  dashboardId: string;
  timeRange: TimeRange;
}) => {
  const { dashboard, widgets, loading } = useDashboard(dashboardId, timeRange);

  if (loading) {
    return <DashboardSkeleton />;
  }

  return (
    <div className="space-y-6">
      {/* KPIs principaux */}
      <div className="grid grid-cols-4 gap-4">
        <MetricWidget
          title="Cultures Actives"
          value={widgets.activeCrops?.value || 0}
          trend={widgets.activeCrops?.trend}
        />
        <MetricWidget
          title="Récoltes ce Mois"
          value={widgets.monthlyHarvest?.value || 0}
          unit="kg"
          trend={widgets.monthlyHarvest?.trend}
          target={50}
        />
        <MetricWidget
          title="Température Moyenne"
          value={widgets.avgTemperature?.value || 0}
          unit="°C"
          trend={widgets.avgTemperature?.trend}
        />
        <MetricWidget
          title="Santé du Jardin"
          value={widgets.gardenHealth?.value || 0}
          unit="%"
          trend={widgets.gardenHealth?.trend}
        />
      </div>

      {/* Graphiques principaux */}
      <div className="grid grid-cols-2 gap-6">
        <Card className="p-6">
          <CardHeader>
            <CardTitle>Évolution des Conditions</CardTitle>
          </CardHeader>
          <CardContent>
            <Chart
              data={widgets.environmentalConditions?.data || []}
              type="line"
              config={{
                xAxis: { field: 'timestamp' },
                metrics: [
                  { field: 'temperature', label: 'Température' },
                  { field: 'humidity', label: 'Humidité' }
                ],
                colors: ['#22c55e', '#3b82f6'],
                showLegend: true,
                showTrend: true
              }}
            />
          </CardContent>
        </Card>

        <Card className="p-6">
          <CardHeader>
            <CardTitle>Rendement par Variété</CardTitle>
          </CardHeader>
          <CardContent>
            <Chart
              data={widgets.harvestByVariety?.data || []}
              type="bar"
              config={{
                xAxis: { field: 'variety' },
                metrics: [{ field: 'harvest_weight', label: 'Poids (kg)' }],
                colors: ['#f59e0b'],
                showValues: true
              }}
            />
          </CardContent>
        </Card>
      </div>

      {/* Tableau détaillé */}
      <Card className="p-6">
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>Détail des Interventions</CardTitle>
            <Button variant="outline" size="sm">
              <FilterIcon className="w-4 h-4 mr-2" />
              Filtrer
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <InterventionsTable data={widgets.interventionsDetail?.data || []} />
        </CardContent>
      </Card>
    </div>
  );
};
```

## API Routes

```typescript
// src/app/api/analytics/query/route.ts
export async function POST(request: Request) {
  try {
    const query: AnalyticsQuery = await request.json();
    
    // Validation de la requête
    const validationResult = validateAnalyticsQuery(query);
    if (!validationResult.valid) {
      return NextResponse.json(
        { error: 'Invalid query', details: validationResult.errors },
        { status: 400 }
      );
    }

    // Exécution de la requête
    const result = await analyticsService.executeQuery(query);
    
    return NextResponse.json(result);

  } catch (error) {
    console.error('Analytics query failed:', error);
    return NextResponse.json(
      { error: 'Query execution failed' },
      { status: 500 }
    );
  }
}

// src/app/api/analytics/dashboards/[dashboardId]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { dashboardId: string } }
) {
  const { searchParams } = new URL(request.url);
  const timeRange = {
    start: new Date(searchParams.get('start') || Date.now() - 7*24*60*60*1000),
    end: new Date(searchParams.get('end') || Date.now())
  };

  const dashboard = await prisma.tableauDeBord.findUnique({
    where: { id: params.dashboardId },
    include: { widgets: true }
  });

  if (!dashboard) {
    return NextResponse.json({ error: 'Dashboard not found' }, { status: 404 });
  }

  // Exécution des requêtes pour tous les widgets
  const widgetResults = await Promise.all(
    dashboard.widgets.map(async (widget) => {
      try {
        const query = { ...widget.requete, timeRange };
        const result = await analyticsService.executeQuery(query);
        return { widgetId: widget.id, result };
      } catch (error) {
        return { widgetId: widget.id, error: error.message };
      }
    })
  );

  return NextResponse.json({
    dashboard: {
      id: dashboard.id,
      name: dashboard.nom,
      widgets: widgetResults
    }
  });
}
```

## Critères d'Acceptation Techniques

### Performance
- [ ] Requêtes analytics < 2s pour 1M+ points de données
- [ ] Cache intelligent avec invalidation sélective
- [ ] Pagination efficace pour gros datasets
- [ ] Agrégations pré-calculées pour métriques courantes

### Visualisations
- [ ] Support 8+ types de graphiques
- [ ] Interactivité (zoom, drill-down, filtres)
- [ ] Responsive design mobile/desktop/TV
- [ ] Export haute qualité PDF/PNG

### Insights
- [ ] Détection automatique de tendances (R² > 0.6)
- [ ] Identification d'anomalies en temps réel
- [ ] Suggestions d'optimisation basées données
- [ ] Corrélations multi-variables

## Couverture Exigences Architecture

- **EXG-002.1** : Requêtes PostgreSQL optimisées avec agrégations
- **EXG-002.2** : Cache Redis pour résultats fréquents
- **EXG-003.1** : Interface responsive adaptative
- **EXG-005.1** : IA pour insights automatiques
- **EXG-009.1** : Métriques business complètes

## Tests d'Acceptation

```typescript
// tests/integration/analytics.test.ts
describe('Analytics System', () => {
  test('requête analytics complexe s\'exécute correctement', async () => {
    const query: AnalyticsQuery = {
      metrics: [{ name: 'harvest_weight', type: 'sum', field: 'poids' }],
      dimensions: [{ field: 'variete_nom', alias: 'variety' }],
      filters: [],
      timeRange: { start: new Date('2024-01-01'), end: new Date('2024-12-31') },
      granularity: 'month'
    };
    
    const result = await analyticsService.executeQuery(query);
    
    expect(result.data).toBeDefined();
    expect(result.metadata.executionTime).toBeLessThan(2000);
  });

  test('détection de tendances fonctionne', async () => {
    const data = generateTrendingData(30, 0.5); // 30 points avec tendance positive
    
    const insights = await analyticsService.generateAutoInsights(data, mockQuery);
    
    expect(insights).toContainEqual(
      expect.objectContaining({
        type: 'trend',
        metadata: expect.objectContaining({ trend: 'increasing' })
      })
    );
  });

  test('cache analytics améliore performance', async () => {
    const query = createTestQuery();
    
    // Première exécution
    const start1 = Date.now();
    const result1 = await analyticsService.executeQuery(query);
    const time1 = Date.now() - start1;
    
    // Deuxième exécution (cached)
    const start2 = Date.now();
    const result2 = await analyticsService.executeQuery(query);
    const time2 = Date.now() - start2;
    
    expect(result2.metadata.cacheHit).toBe(true);
    expect(time2).toBeLessThan(time1 * 0.1); // 10x plus rapide
  });
});
```

Cette spécification couvre un système complet d'analytics et tableaux de bord permettant aux utilisateurs d'analyser en profondeur les performances de leur jardin avec des visualisations interactives et des insights intelligents.