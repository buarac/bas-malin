# **F2.2 - Planificateur de Semis & Calendrier Cultural**

## **üìã Informations g√©n√©rales**
- **Score de priorit√©** : 95/100 ‚≠ê PRIORIT√â √âLEV√âE
- **EPIC** : PILIER PRODUIRE - CORE FEATURES  
- **Complexit√©** : √âlev√©e (algorithmes de planning + contexte)
- **Devices** : üì±üíªüì∫

## **üéØ Description**
Calendrier intelligent de planification des semis et interventions bas√© sur les cycles de culture, conditions m√©t√©orologiques et contraintes g√©ographiques, avec calculs automatiques des dates optimales et notifications contextuelles pour maximiser les rendements.

## **üë• User Stories**

### **Planification Expert (Sacha)**
- En tant que jardinier exp√©riment√©, je veux planifier mes semis selon les cycles optimaux pour ma r√©gion
- En tant qu'expert, je veux des calendriers adapt√©s √† mes 4 bacs avec rotations intelligentes
- En tant qu'utilisateur avanc√©, je veux simuler diff√©rents sc√©narios de plantation

### **Suivi Quotidien**
- En tant qu'utilisateur mobile, je veux des rappels g√©olocalis√©s pour mes interventions du jour
- En tant qu'utilisateur, je veux des notifications m√©t√©o qui adaptent mon planning
- En tant qu'utilisateur, je veux drag & drop pour ajuster facilement mes plannings

### **Visualisation & D√©monstration**
- En tant qu'utilisateur TV, je veux voir une timeline saisonni√®re anim√©e spectaculaire
- En tant qu'utilisateur, je veux partager visuellement mon plan de potager

## **üß† Intelligence du planificateur**

### **Algorithme de calcul des dates optimales**
```typescript
export class SmartPlanningService {
  private weatherAPI: WeatherAPI;
  private varietyDatabase: VarietyDatabase;
  private geolocation: GeolocationService;

  constructor() {
    this.weatherAPI = new WeatherAPI();
    this.varietyDatabase = new VarietyDatabase();
    this.geolocation = new GeolocationService();
  }

  async calculateOptimalDates(
    variete: VarieteCulture,
    zone: Zone, 
    anneeCible: number
  ): Promise<OptimalDates> {
    
    // 1. R√©cup√©rer les donn√©es g√©oclimatiques
    const climateData = await this.getClimateData(zone.jardin.localisation);
    
    // 2. Analyser les contraintes vari√©t√©
    const varietyConstraints = this.parseVarietyConstraints(variete);
    
    // 3. Calculer fen√™tres optimales
    const semisWindow = this.calculateSemisWindow(
      varietyConstraints, 
      climateData,
      anneeCible
    );
    
    const recolteWindow = this.calculateRecolteWindow(
      semisWindow,
      varietyConstraints.joursRecolte
    );

    // 4. Optimiser selon l'historique local
    const historicalOptimization = await this.optimizeWithHistory(
      variete.id,
      zone.id,
      semisWindow
    );

    return {
      dateSemisOptimale: historicalOptimization.semisDate,
      fenetreSemis: {
        debut: semisWindow.earliest,
        fin: semisWindow.latest,
        scoreConfiance: historicalOptimization.confidence
      },
      dateRepiquagePrevue: addDays(
        historicalOptimization.semisDate, 
        varietyConstraints.joursRepiquage
      ),
      fenetreRecolte: {
        debut: recolteWindow.earliest,
        fin: recolteWindow.latest,
        durePrevueSemaines: varietyConstraints.dureeRecolte
      },
      interventionsProgrammees: this.generateInterventions(
        historicalOptimization.semisDate,
        varietyConstraints
      ),
      risquesIdentifies: this.identifyRisks(climateData, varietyConstraints),
      recommandations: this.generateRecommendations(climateData, varietyConstraints)
    };
  }

  private calculateSemisWindow(
    constraints: VarietyConstraints, 
    climate: ClimateData,
    year: number
  ): DateWindow {
    const baseCalendar = constraints.calendrierDefaut;
    
    // Ajustement selon derniers gels/premi√®res gel√©es
    const lastFrostDate = this.predictLastFrost(climate, year);
    const firstFrostDate = this.predictFirstFrost(climate, year);
    
    // Fen√™tre de semis en fonction de la r√©sistance au froid
    const earliestSemis = constraints.resistanceFroid 
      ? subDays(lastFrostDate, 14)  // Peut semer avant derniers gels
      : addDays(lastFrostDate, 7);  // Attend fin des gels

    const latestSemis = subDays(
      firstFrostDate, 
      constraints.joursRecolte + constraints.joursMaturation
    );

    return {
      earliest: earliestSemis,
      latest: latestSemis,
      optimal: this.findOptimalDateInWindow(earliestSemis, latestSemis, constraints)
    };
  }

  private async optimizeWithHistory(
    varietyId: string,
    zoneId: string, 
    window: DateWindow
  ): Promise<HistoricalOptimization> {
    
    // R√©cup√©rer historique des performances
    const historicalData = await prisma.instanceCulture.findMany({
      where: {
        varieteId: varietyId,
        zoneId: zoneId,
        anneSaison: { gte: new Date().getFullYear() - 3 }
      },
      include: {
        recoltes: true,
        interventions: true
      }
    });

    if (historicalData.length < 2) {
      // Pas assez d'historique : utiliser fen√™tre standard
      return {
        semisDate: window.optimal,
        confidence: 0.6,
        reasoning: "Bas√© sur donn√©es g√©n√©rales (historique insuffisant)"
      };
    }

    // Analyser corr√©lations date semis -> rendement
    const correlations = this.analyzePerformanceCorrelations(historicalData);
    const bestPerformingDate = this.findBestPerformingDate(correlations);

    return {
      semisDate: this.adjustDateToWindow(bestPerformingDate, window),
      confidence: correlations.confidence,
      reasoning: `Optimis√© selon ${historicalData.length} saisons pr√©c√©dentes`
    };
  }
}

interface OptimalDates {
  dateSemisOptimale: Date;
  fenetreSemis: {
    debut: Date;
    fin: Date;
    scoreConfiance: number;
  };
  dateRepiquagePrevue?: Date;
  fenetreRecolte: {
    debut: Date;
    fin: Date;
    durePrevueSemaines: number;
  };
  interventionsProgrammees: PlannedIntervention[];
  risquesIdentifies: Risk[];
  recommandations: Recommendation[];
}

interface PlannedIntervention {
  type: CategorieIntervention;
  datePrevue: Date;
  description: string;
  criticite: 'FAIBLE' | 'NORMALE' | 'ELEVEE';
  dependsOnWeather: boolean;
}
```

### **Int√©gration m√©t√©orologique (F4.1)**
```typescript
export class WeatherIntegratedPlanning {
  private weatherAPI: WeatherAPI;
  
  async adjustPlanningForWeather(
    planning: PlanPlantation,
    forecasts: WeatherForecast[]
  ): Promise<PlanningAdjustments> {
    
    const adjustments: PlanningAdjustments = {
      delayedSemis: [],
      advancedSemis: [],
      additionalInterventions: [],
      risks: []
    };

    for (const culture of planning.cultures) {
      const semisDate = culture.dateSemisPrevue;
      const forecastAtSemis = this.getForecastForDate(forecasts, semisDate);
      
      // R√®gles d'ajustement m√©t√©o
      if (forecastAtSemis.temperatureMin < culture.variete.temperatureMinSemis) {
        adjustments.delayedSemis.push({
          cultureId: culture.id,
          originalDate: semisDate,
          newDate: this.findNextSuitableDate(forecasts, culture),
          reason: "Temp√©ratures trop basses pr√©vues"
        });
      }

      if (forecastAtSemis.precipitationMm > 20 && culture.variete.sensibleEauStagnante) {
        adjustments.additionalInterventions.push({
          type: 'DRAINAGE',
          datePrevue: subDays(semisDate, 1),
          description: "Am√©liorer drainage avant fortes pluies pr√©vues"
        });
      }

      // D√©tection risques climatiques
      const risks = this.detectClimateRisks(forecasts, culture);
      adjustments.risks.push(...risks);
    }

    return adjustments;
  }

  private detectClimateRisks(
    forecasts: WeatherForecast[], 
    culture: InstanceCulture
  ): Risk[] {
    const risks: Risk[] = [];
    
    // Risque de gel tardif
    const lateFreezeForecast = forecasts.find(f => 
      f.date > culture.dateSemisPrevue && 
      f.date < addDays(culture.dateSemisPrevue, 30) &&
      f.temperatureMin < 0
    );
    
    if (lateFreezeForecast) {
      risks.push({
        type: 'GEL_TARDIF',
        date: lateFreezeForecast.date,
        severity: 'ELEVE',
        recommendation: "Pr√©voir protection (voile, tunnel, paillis)"
      });
    }

    // Risque de s√©cheresse
    const dryPeriod = this.detectDryPeriod(forecasts);
    if (dryPeriod && this.overlapsWithCriticalPeriod(dryPeriod, culture)) {
      risks.push({
        type: 'SECHERESSE',
        period: dryPeriod,
        severity: 'MOYEN',
        recommendation: "Pr√©voir arrosage suppl√©mentaire et paillis"
      });
    }

    return risks;
  }
}
```

## **üíæ Mod√®le de donn√©es (selon data_models_bas_malin.md)**

### **Extension du mod√®le PlanPlantation**
```prisma
model PlanPlantation {
  id                    String @id @default(cuid())
  utilisateurId         String
  jardinId              String
  
  nom                   String // "Plan Saison 2026"
  description           String?
  anneeCible            Int
  
  // Configuration du plan (F2.2)
  strategiePlanification StrategiePlanification @default(MANUEL)
  cycleRotationAnnees   Int @default(4)
  
  // Contraintes utilisateur
  contraintes           Json? // {maxVarietesParZone, famillesPreferes[], varietesExclues[], limiteBudget}
  
  // M√©triques calcul√©es par algorithme intelligent
  scoreOptimisation     Decimal? @db.Decimal(3,2) // 0-1 score qualit√© plan
  rendementTotalAttendu Decimal? @db.Decimal(8,2) // kg estim√©
  coutEstime            Decimal? @db.Decimal(10,2)
  heuresTravailEstimees Int?
  
  // Intelligence m√©t√©o
  ajustementsMeterologiques Json? // Ajustements selon pr√©visions
  risquesIdentifies     Json? // [{type, date, severite, recommandation}]
  
  // Relations
  cultures              PlannedCulture[]
}

// Table d√©riv√©e pour cultures planifi√©es
model PlannedCulture {
  id                String @id @default(cuid())
  planId            String
  varietyId         String
  zoneId            String
  
  // Dates calcul√©es intelligentes
  dateSemisPrevue   DateTime
  fenetreSemis      Json // {debut, fin, scoreConfiance, raisonning}
  dateRepiquagePrevue DateTime?
  fenetreRecolte    Json // {debut, fin, dureeEstimee, rendementAttendu}
  
  // Interventions program√©es automatiques
  interventionsProgrammees Json // [{type, date, description, criticite}]
  
  // Optimisation
  scoreOptimisationZone    Decimal? @db.Decimal(3,2)
  compatibiliteVoisinage   Json? // Associations/rotations
  
  // Relations
  plan     PlanPlantation @relation(fields: [planId], references: [id])
  variete  VarieteCulture @relation(fields: [varietyId], references: [id])
  zone     Zone @relation(fields: [zoneId], references: [id])
}

enum StrategiePlanification {
  MANUEL        // Planification manuelle utilisateur
  OPTIMISE_IA   // Algorithmes d'optimisation automatique  
  HYBRIDE       // Mix manuel + suggestions IA
}
```

## **üì± Interface Mobile (Agenda du jour)**

### **Vue agenda quotidienne g√©olocalis√©e**
```typescript
const MobileDailyAgenda = () => {
  const { data: todayTasks } = useDailyTasks();
  const { location } = useGeolocation();
  const { data: weatherToday } = useTodayWeather();

  return (
    <div className="h-screen bg-gradient-to-br from-green-50 to-emerald-50">
      {/* Header avec m√©t√©o du jour */}
      <div className="bg-white shadow-sm p-4">
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-bold text-green-800">
            üìÖ Aujourd'hui
          </h1>
          
          <WeatherTodayCard weather={weatherToday} />
        </div>
        
        <p className="text-gray-600 mt-1">
          {format(new Date(), 'EEEE d MMMM yyyy', { locale: fr })}
        </p>
      </div>

      {/* T√¢ches du jour par priorit√© */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {/* T√¢ches critiques m√©t√©o-d√©pendantes */}
        <TaskSection 
          title="üö® Urgent (m√©t√©o)" 
          tasks={todayTasks.filter(t => t.criticite === 'ELEVEE')}
          color="red"
        />
        
        {/* T√¢ches normales */}
        <TaskSection 
          title="üìã √Ä faire" 
          tasks={todayTasks.filter(t => t.criticite === 'NORMALE')}
          color="green"
        />
        
        {/* T√¢ches optionnelles */}
        <TaskSection 
          title="‚≠ê Si possible" 
          tasks={todayTasks.filter(t => t.criticite === 'FAIBLE')}
          color="blue"
        />
      </div>

      {/* Actions rapides */}
      <div className="bg-white border-t p-4">
        <div className="flex space-x-3">
          <Button size="sm" className="flex-1">
            ‚úÖ Marquer fait
          </Button>
          <Button size="sm" variant="outline" className="flex-1">
            ‚è∞ Reporter
          </Button>
          <Button size="sm" variant="ghost">
            ‚ûï Ajouter
          </Button>
        </div>
      </div>
    </div>
  );
};

const TaskSection = ({ title, tasks, color }) => {
  if (tasks.length === 0) return null;

  return (
    <div className="space-y-3">
      <h2 className="font-medium text-gray-800 border-b border-gray-200 pb-2">
        {title} ({tasks.length})
      </h2>
      
      {tasks.map(task => (
        <TaskCard 
          key={task.id}
          task={task}
          color={color}
        />
      ))}
    </div>
  );
};

const TaskCard = ({ task, color }) => {
  const { distance } = useDistanceToZone(task.zoneId);

  return (
    <motion.div
      whileTap={{ scale: 0.98 }}
      className={`bg-white border-l-4 border-${color}-400 rounded-lg shadow-sm p-4`}
    >
      <div className="flex items-start space-x-3">
        <div className="text-2xl">{getTaskIcon(task.type)}</div>
        
        <div className="flex-1">
          <h3 className="font-medium text-gray-800">
            {task.description}
          </h3>
          
          <div className="flex items-center space-x-4 mt-2 text-sm text-gray-500">
            <span>üìç {task.zone.nom}</span>
            {distance && (
              <span>üö∂ {distance}m</span>
            )}
            {task.dureeEstimee && (
              <span>‚è±Ô∏è {task.dureeEstimee}min</span>
            )}
          </div>
          
          {/* Conditions m√©t√©o si pertinent */}
          {task.dependsOnWeather && (
            <div className="mt-2 p-2 bg-blue-50 rounded text-sm">
              <WeatherConditionAlert task={task} />
            </div>
          )}
        </div>
        
        <Button size="sm" variant="ghost">
          ‚úì
        </Button>
      </div>
    </motion.div>
  );
};

// Notifications g√©olocalis√©es
const useGeofencingReminders = () => {
  const { location } = useGeolocation();
  const { data: todayTasks } = useDailyTasks();

  useEffect(() => {
    if (!location || !todayTasks) return;

    todayTasks.forEach(task => {
      const distanceToZone = calculateDistance(
        location, 
        task.zone.coordinates
      );
      
      // Notification quand on s'approche de la zone
      if (distanceToZone < 50 && !task.notificationSent) {
        sendNotification({
          title: `üìç Rappel √† proximit√©`,
          body: `${task.description} - Zone ${task.zone.nom}`,
          tag: `geofence-${task.id}`
        });
        
        // Marquer notification envoy√©e
        markNotificationSent(task.id);
      }
    });
  }, [location, todayTasks]);
};
```

## **üíª Desktop (Centre de planification)**

### **Interface drag & drop avanc√©e**
```typescript
const DesktopPlanningCenter = () => {
  const { data: currentPlan } = useCurrentPlan();
  const { data: availableVarieties } = useAvailableVarieties();
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  
  return (
    <div className="h-screen flex">
      {/* Sidebar vari√©t√©s disponibles */}
      <div className="w-80 bg-gray-50 border-r overflow-y-auto">
        <div className="p-4">
          <h2 className="text-lg font-bold mb-4">üå± Catalogue vari√©t√©s</h2>
          
          <VarietyCatalog 
            varieties={availableVarieties}
            onDragStart={handleVarietyDragStart}
            filters={{ favoris: true, saison: getSeason() }}
          />
        </div>
      </div>

      {/* Zone principale planification */}
      <div className="flex-1 flex flex-col">
        {/* Toolbar */}
        <div className="bg-white border-b p-4 flex justify-between items-center">
          <div className="flex items-center space-x-4">
            <h1 className="text-2xl font-bold">üìÖ Planificateur 2026</h1>
            
            <Select value={selectedMonth} onValueChange={setSelectedMonth}>
              <SelectTrigger className="w-40">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {MONTHS.map((month, index) => (
                  <SelectItem key={index} value={index}>
                    {month}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          
          <div className="flex space-x-2">
            <Button variant="outline" onClick={runOptimization}>
              ü§ñ Optimiser IA
            </Button>
            <Button onClick={savePlan}>
              üíæ Sauvegarder
            </Button>
          </div>
        </div>

        {/* Vue calendrier avec zones */}
        <div className="flex-1 p-6">
          <PlanningGrid 
            month={selectedMonth}
            zones={currentPlan.zones}
            onDrop={handleVarietyDrop}
            onEditCulture={handleEditCulture}
          />
        </div>
      </div>

      {/* Panel d√©tails culture s√©lectionn√©e */}
      <CultureDetailsPanel />
    </div>
  );
};

const PlanningGrid = ({ month, zones, onDrop, onEditCulture }) => {
  const daysInMonth = getDaysInMonth(new Date(2026, month));
  
  return (
    <div className="grid grid-cols-[200px_1fr] gap-4 h-full">
      {/* Colonne zones */}
      <div className="space-y-2">
        <div className="h-12"></div> {/* Spacer pour header dates */}
        {zones.map(zone => (
          <ZoneHeader key={zone.id} zone={zone} />
        ))}
      </div>

      {/* Grille calendaire */}
      <div className="overflow-x-auto">
        <div 
          className="grid gap-1 h-full min-w-max"
          style={{ 
            gridTemplateColumns: `repeat(${daysInMonth}, minmax(40px, 1fr))`,
            gridTemplateRows: `40px repeat(${zones.length}, 80px)`
          }}
        >
          {/* Header dates */}
          {Array.from({ length: daysInMonth }, (_, i) => (
            <div key={i} className="text-center text-sm font-medium p-2 border-b">
              {i + 1}
            </div>
          ))}
          
          {/* Cellules de planning par zone */}
          {zones.map((zone, zoneIndex) => (
            Array.from({ length: daysInMonth }, (_, dayIndex) => (
              <PlanningCell
                key={`${zone.id}-${dayIndex}`}
                date={new Date(2026, month, dayIndex + 1)}
                zone={zone}
                culture={getCultureForDate(zone, new Date(2026, month, dayIndex + 1))}
                onDrop={(variety) => onDrop(variety, zone, new Date(2026, month, dayIndex + 1))}
                onEdit={onEditCulture}
              />
            ))
          ))}
        </div>
      </div>
    </div>
  );
};

const PlanningCell = ({ date, zone, culture, onDrop, onEdit }) => {
  const [{ isOver }, drop] = useDrop({
    accept: 'VARIETY',
    drop: (item) => onDrop(item.variety, zone, date),
    collect: (monitor) => ({
      isOver: !!monitor.isOver(),
    }),
  });

  return (
    <div
      ref={drop}
      className={`
        border border-gray-200 rounded p-1 text-xs cursor-pointer
        transition-colors duration-150
        ${isOver ? 'bg-green-100 border-green-300' : 'bg-white'}
        ${culture ? 'bg-gradient-to-r from-green-100 to-emerald-100' : ''}
      `}
      onClick={() => culture && onEdit(culture)}
    >
      {culture && (
        <div className="h-full flex flex-col justify-between">
          <div className="font-medium truncate">
            {culture.variete.nomCommun}
          </div>
          
          <div className="flex justify-between items-end">
            <span className={`px-1 rounded text-xs ${
              culture.etapeCycleVie === 'SEMIS' ? 'bg-yellow-200' :
              culture.etapeCycleVie === 'CROISSANCE' ? 'bg-green-200' :
              culture.etapeCycleVie === 'RECOLTE' ? 'bg-orange-200' : 'bg-gray-200'
            }`}>
              {getEtapeIcon(culture.etapeCycleVie)}
            </span>
            
            {culture.scoreOptimisation && (
              <span className="text-xs font-medium">
                {(culture.scoreOptimisation * 100).toFixed(0)}%
              </span>
            )}
          </div>
        </div>
      )}
    </div>
  );
};
```

### **Optimisation IA du planning**
```typescript
const PlanOptimizationEngine = () => {
  const [isOptimizing, setIsOptimizing] = useState(false);
  const [optimizationResults, setOptimizationResults] = useState<OptimizationResults>();
  
  const runOptimization = async () => {
    setIsOptimizing(true);
    
    try {
      // 1. Analyser contraintes existantes
      const constraints = await analyzePlanConstraints();
      
      // 2. Calculer scores de toutes les combinaisons possibles
      const optimization = await planningService.optimizePlan({
        zones: currentPlan.zones,
        varieties: availableVarieties,
        constraints: constraints,
        objectives: {
          maximizeYield: 0.4,
          minimizeWork: 0.3,
          optimizeRotation: 0.3
        }
      });
      
      setOptimizationResults(optimization);
      
    } catch (error) {
      console.error('Optimization failed:', error);
    } finally {
      setIsOptimizing(false);
    }
  };

  return (
    <Card className="mt-6">
      <CardHeader>
        <CardTitle className="flex items-center space-x-2">
          <span>ü§ñ</span>
          <span>Optimisation IA</span>
          {isOptimizing && <Spinner />}
        </CardTitle>
      </CardHeader>
      
      <CardContent>
        {!optimizationResults ? (
          <div className="text-center py-8">
            <Button onClick={runOptimization} disabled={isOptimizing}>
              {isOptimizing ? 'Optimisation en cours...' : 'Lancer l\'optimisation'}
            </Button>
            <p className="text-sm text-gray-500 mt-2">
              Analyse des rotations, associations et rendements optimaux
            </p>
          </div>
        ) : (
          <OptimizationResults results={optimizationResults} />
        )}
      </CardContent>
    </Card>
  );
};

const OptimizationResults = ({ results }) => (
  <div className="space-y-6">
    {/* Score global */}
    <div className="text-center">
      <div className="text-4xl font-bold text-green-600">
        {results.globalScore.toFixed(1)}/10
      </div>
      <p className="text-gray-600">Score d'optimisation global</p>
    </div>

    {/* M√©triques d√©taill√©es */}
    <div className="grid grid-cols-3 gap-4">
      <MetricCard
        title="Rendement estim√©"
        value={`${results.estimatedYield}kg`}
        improvement={`+${results.yieldImprovement}%`}
        color="green"
      />
      <MetricCard
        title="Heures de travail"
        value={`${results.workHours}h`}
        improvement={`-${results.workReduction}%`}
        color="blue"
      />
      <MetricCard
        title="Rotation quality"
        value={`${results.rotationScore}/10`}
        improvement="Excellent"
        color="purple"
      />
    </div>

    {/* Recommandations sp√©cifiques */}
    <div className="space-y-3">
      <h3 className="font-medium">Recommandations principales :</h3>
      {results.recommendations.map((rec, index) => (
        <div key={index} className="flex items-start space-x-3 p-3 bg-blue-50 rounded">
          <div className="text-blue-600 mt-0.5">{rec.icon}</div>
          <div>
            <p className="font-medium text-blue-800">{rec.title}</p>
            <p className="text-sm text-blue-600">{rec.description}</p>
          </div>
        </div>
      ))}
    </div>

    {/* Actions */}
    <div className="flex space-x-3">
      <Button onClick={() => applyOptimization(results)}>
        ‚úÖ Appliquer les suggestions
      </Button>
      <Button variant="outline">
        üìä Voir d√©tails complets
      </Button>
    </div>
  </div>
);
```

## **üì∫ TV (Timeline saisonni√®re spectaculaire)**

### **Visualisation immersive annuelle**
```typescript
const TVSeasonalTimeline = () => {
  const { data: yearPlan } = useYearPlan(2026);
  const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
  
  useEffect(() => {
    // Animation automatique timeline
    const interval = setInterval(() => {
      setCurrentMonth(prev => (prev + 1) % 12);
    }, 5000); // Change mois toutes les 5s
    
    return () => clearInterval(interval);
  }, []);

  return (
    <div className="h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-teal-900 text-white overflow-hidden">
      {/* Header avec ann√©e et navigation */}
      <div className="p-8 text-center">
        <h1 className="text-6xl font-bold mb-4">
          Planning Potager 2026
        </h1>
        <p className="text-2xl opacity-80">
          {MONTHS_FR[currentMonth].toUpperCase()}
        </p>
      </div>

      {/* Timeline circulaire des saisons */}
      <div className="flex justify-center mb-8">
        <SeasonalWheel 
          currentMonth={currentMonth}
          onMonthSelect={setCurrentMonth}
          planData={yearPlan}
        />
      </div>

      {/* Activit√©s du mois en cours */}
      <div className="px-12 py-8">
        <MonthlyActivities 
          month={currentMonth}
          activities={getMonthActivities(yearPlan, currentMonth)}
        />
      </div>

      {/* Footer avec m√©triques annuelles */}
      <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-30 p-6">
        <div className="flex justify-center space-x-16">
          <TVMetric
            icon="üå±"
            value={yearPlan.totalVarieties}
            label="vari√©t√©s planifi√©es"
          />
          <TVMetric
            icon="üìä"
            value={`${yearPlan.expectedYield}kg`}
            label="rendement attendu"
          />
          <TVMetric
            icon="‚è±Ô∏è"
            value={`${yearPlan.totalWorkHours}h`}
            label="travail pr√©vu"
          />
          <TVMetric
            icon="ü§ñ"
            value={`${yearPlan.aiOptimization}/10`}
            label="score IA"
          />
        </div>
      </div>
    </div>
  );
};

const SeasonalWheel = ({ currentMonth, onMonthSelect, planData }) => {
  const wheelRadius = 250;
  const centerX = wheelRadius + 50;
  const centerY = wheelRadius + 50;

  return (
    <svg 
      width={wheelRadius * 2 + 100} 
      height={wheelRadius * 2 + 100}
      className="cursor-pointer"
    >
      {/* Cercle de base */}
      <circle
        cx={centerX}
        cy={centerY}
        r={wheelRadius}
        fill="rgba(255,255,255,0.1)"
        stroke="rgba(255,255,255,0.3)"
        strokeWidth="2"
      />
      
      {/* Segments mensuels */}
      {MONTHS_FR.map((month, index) => {
        const angle = (index * 360 / 12) - 90; // Start from top
        const isActive = index === currentMonth;
        const hasActivities = getMonthActivities(planData, index).length > 0;
        
        return (
          <g key={index}>
            {/* Segment arc */}
            <path
              d={createArc(centerX, centerY, wheelRadius - 20, angle, angle + 30)}
              fill={
                isActive ? 'rgba(34, 197, 94, 0.8)' :
                hasActivities ? 'rgba(34, 197, 94, 0.3)' :
                'rgba(255, 255, 255, 0.1)'
              }
              stroke="white"
              strokeWidth="1"
              onClick={() => onMonthSelect(index)}
              className="transition-all duration-300"
            />
            
            {/* Label mois */}
            <text
              x={centerX + Math.cos(degToRad(angle + 15)) * (wheelRadius - 40)}
              y={centerY + Math.sin(degToRad(angle + 15)) * (wheelRadius - 40)}
              textAnchor="middle"
              dominantBaseline="central"
              fill={isActive ? "white" : "rgba(255,255,255,0.8)"}
              fontSize={isActive ? "14" : "12"}
              fontWeight={isActive ? "bold" : "normal"}
              className="pointer-events-none"
            >
              {month.slice(0, 3).toUpperCase()}
            </text>
            
            {/* Indicateur activit√©s */}
            {hasActivities && (
              <circle
                cx={centerX + Math.cos(degToRad(angle + 15)) * (wheelRadius - 60)}
                cy={centerY + Math.sin(degToRad(angle + 15)) * (wheelRadius - 60)}
                r="3"
                fill="white"
                className={isActive ? "animate-pulse" : ""}
              />
            )}
          </g>
        );
      })}
      
      {/* Centre avec mois actuel */}
      <circle
        cx={centerX}
        cy={centerY}
        r="60"
        fill="rgba(34, 197, 94, 0.9)"
        stroke="white"
        strokeWidth="2"
      />
      
      <text
        x={centerX}
        y={centerY}
        textAnchor="middle"
        dominantBaseline="central"
        fill="white"
        fontSize="18"
        fontWeight="bold"
      >
        {MONTHS_FR[currentMonth].slice(0, 3)}
      </text>
    </svg>
  );
};

const MonthlyActivities = ({ month, activities }) => (
  <div className="grid grid-cols-4 gap-6">
    {activities.map((activity, index) => (
      <motion.div
        key={activity.id}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: index * 0.1 }}
        className="bg-white bg-opacity-10 backdrop-blur-sm rounded-lg p-6 text-center"
      >
        <div className="text-4xl mb-3">{activity.icon}</div>
        <h3 className="text-xl font-bold mb-2">{activity.title}</h3>
        <p className="text-sm opacity-80 mb-3">{activity.description}</p>
        
        {activity.varieties && (
          <div className="flex flex-wrap justify-center gap-1">
            {activity.varieties.slice(0, 3).map(variety => (
              <span
                key={variety}
                className="text-xs bg-white bg-opacity-20 px-2 py-1 rounded"
              >
                {variety}
              </span>
            ))}
            {activity.varieties.length > 3 && (
              <span className="text-xs bg-white bg-opacity-20 px-2 py-1 rounded">
                +{activity.varieties.length - 3}
              </span>
            )}
          </div>
        )}
      </motion.div>
    ))}
  </div>
);
```

## **‚úÖ Crit√®res d'acceptation**

### **Calculs intelligents**
- [ ] **Dates optimales calcul√©es** selon vari√©t√© + g√©olocalisation + m√©t√©o
- [ ] **Fen√™tres de plantation** avec scores de confiance
- [ ] **Pr√©dictions de r√©colte** bas√©es sur cycles + historique
- [ ] **Ajustements m√©t√©orologiques** automatiques

### **Interface mobile**
- [ ] **Agenda quotidien g√©olocalis√©** avec t√¢ches par zone
- [ ] **Notifications proximit√©** (g√©ofencing < 50m)
- [ ] **Rappels m√©t√©o** pour interventions sensibles
- [ ] Interface simplifi√©e < 3 clics pour actions courantes

### **Interface desktop**
- [ ] **Planificateur drag & drop** intuitif
- [ ] **Optimisation IA** avec scores et recommandations
- [ ] **Vue calendaire** avec codes couleur par √©tape
- [ ] **Export/import** formats standards (CSV, iCal)

### **Interface TV**
- [ ] **Timeline saisonni√®re** avec animations spectaculaires
- [ ] **Roue des saisons** interactive
- [ ] **M√©triques annuelles** visuellement impactantes
- [ ] **Mode pr√©sentation** pour d√©monstrations

### **Performance**
- [ ] Calcul optimisation < 10 secondes pour 1 ann√©e compl√®te
- [ ] Synchronisation temps r√©el planning cross-device
- [ ] Cache intelligent des calculs m√©t√©orologiques
- [ ] Interface fluide m√™me avec 50+ cultures planifi√©es

## **üèóÔ∏è Exigences architecturales couvertes**

- **EXG-001.2** : API Routes `/src/app/api/planning/*` ‚úÖ
- **EXG-002.2** : Mod√®les Prisma PlanPlantation + PlannedCulture ‚úÖ
- **EXG-003.2** : Interface responsive üì±üíªüì∫ ‚úÖ
- **EXG-004.1** : S√©paration responsabilit√©s (planning app, IoT HA) ‚úÖ
- **EXG-005.2** : BullMQ pour optimisation IA asynchrone ‚úÖ
- **EXG-007.3** : Performance < 2s hors calculs lourds ‚úÖ
- **EXG-009.1** : WeatherAPI pr√©visions 10 jours ‚úÖ

## **üöÄ Plan d'impl√©mentation**

### **Phase 1 : Algorithmes Core (5j)**
1. Service calcul dates optimales
2. Int√©gration WeatherAPI pour ajustements
3. Algorithmes d'optimisation basiques
4. Tests sur jeux de donn√©es vari√©t√©s

### **Phase 2 : Interface Mobile (3j)**
1. Agenda quotidien avec g√©olocalisation  
2. Notifications push + g√©ofencing
3. Saisie rapide nouvelles t√¢ches
4. Interface m√©t√©o int√©gr√©e

### **Phase 3 : Interface Desktop (4j)**
1. Planificateur drag & drop avec zones
2. Calendrier graphique interactif
3. Optimisation IA avec r√©sultats visuels
4. Import/export et sauvegarde

### **Phase 4 : Interface TV (3j)**
1. Timeline circulaire des saisons
2. Animations et transitions spectaculaires
3. Dashboard m√©triques annuelles
4. Mode pr√©sentation automatique

### **Phase 5 : Intelligence & Tests (3j)**
1. Am√©lioration algorithmes optimisation
2. Tests performance et pr√©cision
3. Validation sur plans r√©els
4. Documentation utilisateur

**Dur√©e totale estim√©e : 18 jours**