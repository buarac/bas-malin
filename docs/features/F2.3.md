# **F2.3 - Gestionnaire de Zones & Parcelles**

## **üìã Informations g√©n√©rales**
- **Score de priorit√©** : 85/100 ‚≠ê PRIORIT√â √âLEV√âE
- **EPIC** : PILIER PRODUIRE - CORE FEATURES
- **Complexit√©** : √âlev√©e (g√©ospatial + contraintes)
- **Devices** : üì±üíªüì∫

## **üéØ Description**
Gestionnaire intelligent des zones de culture avec mod√©lisation des 4 bacs sp√©cifiques de Sacha (8m x 0.8m) + zones libres, visualisation 2D interactive, assignation automatique des cultures avec contraintes de rotations et associations, g√©olocalisation pr√©cise et optimisation spatiale.

## **üë• User Stories**

### **Organisation spatiale**
- En tant que jardinier, je veux organiser mes cultures par zones g√©ographiques pr√©cises (4 bacs + zones libres)
- En tant qu'utilisateur, je veux visualiser l'occupation actuelle et future de mes parcelles en 2D
- En tant qu'expert, je veux optimiser l'utilisation de l'espace avec suggestions automatiques

### **Gestion des contraintes**
- En tant que jardinier, je veux que le syst√®me respecte les rotations de cultures automatiquement
- En tant qu'utilisateur, je veux des associations de plantes sugg√©r√©es selon les zones
- En tant que syst√®me, je veux calculer la capacit√© optimale de chaque zone

### **Suivi et maintenance**
- En tant qu'utilisateur mobile, je veux identifier ma position actuelle dans le jardin
- En tant qu'utilisateur, je veux tracker l'historique d'occupation de chaque zone
- En tant qu'utilisateur TV, je veux une vue d'ensemble spectaculaire de mon jardin

## **üó∫Ô∏è Architecture g√©ospatiale**

### **Mod√®le Zone √©tendu avec g√©ospatial**
```prisma
model Zone {
  id          String @id @default(cuid())
  jardinId    String
  nom         String @db.VarChar(100) // "Bac 1", "Bac 2", "Zone libre Nord"
  typeZone    TypeZone
  
  // G√©om√©trie avec PostGIS + backup JSON
  geometriePostGIS    Unsupported("GEOMETRY")? // PostGIS geometry pour calculs avanc√©s
  geometrie           Json @db.JsonB // Backup + donn√©es √©tendues
  
  // Caract√©ristiques micro-climatiques
  expositionSoleil ExpositionSoleil
  accesEau        AccesEau
  qualiteSol      Int @db.SmallInt // 1-5
  pente           Decimal? @db.Decimal(4,2) // Pourcentage de pente
  drainageNaturel Boolean @default(true)
  
  // Capacit√© et optimisation
  capaciteOptimale    Json @db.JsonB // Calculs selon type cultures
  contraintesRotation Json? @db.JsonB // R√®gles sp√©cifiques √† cette zone
  historiqueCultures  Json @db.JsonB // Cache historique pour optimisation
  
  // √âtat actuel
  estActive            Boolean @default(true)
  cultureActuelleId    String?
  pourcentageOccupe    Decimal @default(0) @db.Decimal(5,2) // 0-100%
  derniereTravailleA   DateTime? @db.Timestamptz
  
  // Maintenance et am√©lioration
  amendementsSol      Json? @db.JsonB // Historique amendements
  problematiques      Json? @db.JsonB // Probl√®mes identifi√©s
  planAmelioration    Json? @db.JsonB // Actions d'am√©lioration pr√©vues
  
  creeA       DateTime @default(now()) @db.Timestamptz
  misAJourA   DateTime @updatedAt @db.Timestamptz
  
  // Relations
  jardin              Jardin @relation(fields: [jardinId], references: [id], onDelete: Cascade)
  cultureActuelle     InstanceCulture? @relation("ZoneCultureActuelle", fields: [cultureActuelleId], references: [id])
  instancesCulture    InstanceCulture[] @relation("ZoneInstancesCulture")
  interventions       Intervention[]
  recoltes           Recolte[]
  appareilsIot       AppareilIoT[]
  
  // Index sp√©cialis√©s g√©ospatiaux
  @@index([jardinId, typeZone])
  @@index([estActive, cultureActuelleId])
  @@index([geometriePostGIS], type: Gist) // Index spatial PostGIS
  @@map("zones")
}

enum TypeZone {
  BAC           // Bacs structur√©s 8m x 0.8m (4 bacs principaux)
  PARCELLE      // Zones d√©limit√©es g√©om√©triquement
  SERRE         // Espaces couverts
  ZONE_LIBRE    // Zones non structur√©es
  ARBRE         // Arbres fruitiers (position ponctuelle)
  VIGNE         // Vignes (alignements)
  COMPOST       // Zone de compostage
  STOCKAGE      // Zones de stockage mat√©riel
}

// Structure JSON pour geometrie (backup + enrichissement)
interface GeometrieZone {
  // G√©om√©trie de base
  type: 'rectangle' | 'polygone' | 'cercle' | 'point';
  coordonnees: number[][]; // [[lat, lng], ...] ou centre pour cercle
  surfaceM2: number;
  perimetreM: number;
  
  // Position relative dans le jardin
  position: {
    x: number; // Coordonn√©e relative au jardin (0-100%)
    y: number;
    rotation?: number; // Degr√©s de rotation
  };
  
  // Dimensions sp√©cifiques aux bacs
  longueurM?: number;
  largeurM?: number;
  hauteurCm?: number; // Pour bacs sur√©lev√©s
  
  // Subdivisions internes
  subdivisions?: Array<{
    id: string;
    nom: string;
    geometrie: number[][];
    surfaceM2: number;
    cultureActuelle?: string;
  }>;
  
  // M√©tadonn√©es
  calculeeA: string;
  sourceGeometrie: 'MANUEL' | 'GPS' | 'CALCULE' | 'IMPORTE';
}

// Structure JSON pour capaciteOptimale
interface CapaciteOptimale {
  // Par type de culture
  parCategorie: {
    [categorie: string]: {
      nombrePlantsMax: number;
      surfaceRequiseM2: number;
      densiteOptimale: number; // plants/m¬≤
      rendementEstimeKg: number;
    };
  };
  
  // Contraintes physiques
  contraintes: {
    largeurMinRang: number; // cm
    espacementMinPlants: number; // cm
    profondeurRacinesMax: number; // cm
    chargeMaxKgM2?: number; // Pour bacs sur√©lev√©s
  };
  
  // Optimisation combin√©e
  combinaisonsOptimales: Array<{
    cultures: string[];
    disposition: string;
    scoreOptimisation: number;
    avantages: string[];
  }>;
  
  // M√©tadonn√©es calcul
  derniereCalculA: string;
  versionAlgorithme: string;
}
```

### **Service de gestion g√©ospatiale**
```typescript
export class ZoneManagementService {
  private prisma: PrismaClient;
  private geoService: GeospatialService;
  private optimizationService: SpaceOptimizationService;
  private cache: RedisCache;

  constructor() {
    this.prisma = new PrismaClient();
    this.geoService = new GeospatialService();
    this.optimizationService = new SpaceOptimizationService();
    this.cache = new RedisCache();
  }

  async createZone(data: CreateZoneInput): Promise<Zone> {
    return this.prisma.$transaction(async (tx) => {
      // 1. Validation g√©om√©trique
      const validatedGeometry = await this.validateGeometry(data.geometrie, data.jardinId);
      
      // 2. Calculs automatiques
      const capaciteOptimale = await this.calculateOptimalCapacity(validatedGeometry, data.typeZone);
      const geometrieEnrichie = await this.enrichGeometry(validatedGeometry);
      
      // 3. Cr√©ation zone avec PostGIS
      const zone = await tx.zone.create({
        data: {
          ...data,
          geometrie: geometrieEnrichie,
          geometriePostGIS: this.toPostGISGeometry(geometrieEnrichie),
          capaciteOptimale,
          historiqueCultures: {
            historique: [],
            derniereAnalyse: new Date().toISOString()
          }
        },
        include: {
          jardin: true,
          instancesCulture: true
        }
      });

      // 4. Mise √† jour index spatial
      await this.updateSpatialIndex(zone);
      
      return zone;
    });
  }

  private async calculateOptimalCapacity(
    geometrie: GeometrieZone,
    typeZone: TypeZone
  ): Promise<CapaciteOptimale> {
    
    const surface = geometrie.surfaceM2;
    const longueur = geometrie.longueurM || Math.sqrt(surface);
    const largeur = geometrie.largeurM || surface / longueur;

    // Param√®tres par d√©faut selon type de zone
    const baseParams = this.getZoneTypeParameters(typeZone);
    
    // Calculs de capacit√© par cat√©gorie de culture
    const capacites = await Promise.all([
      this.calculateCapacityForCategory('LEGUME', surface, longueur, largeur),
      this.calculateCapacityForCategory('HERBE_AROMATIQUE', surface, longueur, largeur),
      this.calculateCapacityForCategory('FLEUR', surface, longueur, largeur),
    ]);

    const parCategorie = Object.fromEntries(
      capacites.map(cap => [cap.categorie, cap])
    );

    // G√©n√©ration combinaisons optimales
    const combinaisonsOptimales = await this.generateOptimalCombinations(
      parCategorie,
      surface,
      longueur,
      largeur
    );

    return {
      parCategorie,
      contraintes: {
        largeurMinRang: Math.max(30, largeur * 100 / 3), // Min 30cm, max largeur/3
        espacementMinPlants: baseParams.espacementMin,
        profondeurRacinesMax: baseParams.profondeurMax,
        chargeMaxKgM2: typeZone === 'BAC' ? 200 : undefined // Bacs sur√©lev√©s limit√©s
      },
      combinaisonsOptimales,
      derniereCalculA: new Date().toISOString(),
      versionAlgorithme: '1.0'
    };
  }

  private async calculateCapacityForCategory(
    categorie: string,
    surface: number,
    longueur: number,
    largeur: number
  ): Promise<CategoryCapacity> {
    
    // Param√®tres moyens par cat√©gorie (base de donn√©es vari√©t√©s)
    const avgParams = await this.getAverageCultureParams(categorie);
    
    const espacementCm = avgParams.espacementMoyen;
    const espacementM = espacementCm / 100;
    
    // Calcul selon disposition optimale
    const plantsParRang = Math.floor(longueur / espacementM);
    const nombreRangs = Math.floor(largeur / espacementM);
    const nombrePlantsMax = plantsParRang * nombreRangs;
    
    // Ajustement pour passages (15% de l'espace)
    const nombrePlantsAjuste = Math.floor(nombrePlantsMax * 0.85);
    const surfaceRequiseM2 = surface / nombrePlantsAjuste;
    const densiteOptimale = nombrePlantsAjuste / surface;
    
    // Estimation rendement
    const rendementMoyenParPlant = avgParams.rendementMoyenKg || 0.5;
    const rendementEstimeKg = nombrePlantsAjuste * rendementMoyenParPlant;

    return {
      categorie,
      nombrePlantsMax: nombrePlantsAjuste,
      surfaceRequiseM2,
      densiteOptimale,
      rendementEstimeKg
    };
  }

  async getZoneLayout(jardinId: string): Promise<ZoneLayout> {
    const cacheKey = `zone_layout:${jardinId}`;
    
    const cached = await this.cache.get(cacheKey);
    if (cached) return cached;

    const zones = await this.prisma.zone.findMany({
      where: { 
        jardinId,
        estActive: true 
      },
      include: {
        cultureActuelle: {
          include: {
            variete: {
              include: {
                varieteBase: true
              }
            }
          }
        },
        instancesCulture: {
          where: { estActive: true },
          include: {
            variete: {
              include: {
                varieteBase: true
              }
            }
          }
        },
        jardin: true
      },
      orderBy: { nom: 'asc' }
    });

    // Enrichissement avec calculs g√©ospatiaux
    const enrichedZones = await Promise.all(
      zones.map(async (zone) => {
        const geometrie = zone.geometrie as GeometrieZone;
        const capacite = zone.capaciteOptimale as CapaciteOptimale;
        
        // Calculs en temps r√©el
        const occupationActuelle = await this.calculateCurrentOccupation(zone);
        const santeSol = await this.calculateSoilHealth(zone);
        const optimisationScore = await this.calculateOptimizationScore(zone);

        return {
          ...zone,
          geometrie,
          capacite,
          occupationActuelle,
          santeSol,
          optimisationScore,
          recommandations: await this.generateZoneRecommendations(zone)
        };
      })
    );

    // Calculs globaux jardin
    const totalSurface = enrichedZones.reduce((sum, zone) => 
      sum + zone.geometrie.surfaceM2, 0
    );
    
    const surfaceOccupee = enrichedZones.reduce((sum, zone) => 
      sum + (zone.geometrie.surfaceM2 * zone.pourcentageOccupe / 100), 0
    );

    const layout: ZoneLayout = {
      jardinId,
      zones: enrichedZones,
      statistiques: {
        nombreZones: enrichedZones.length,
        surfaceTotale: totalSurface,
        surfaceOccupee,
        tauxOccupation: (surfaceOccupee / totalSurface) * 100,
        zonesActives: enrichedZones.filter(z => z.cultureActuelle).length,
        scoreOptimisationGlobal: this.calculateGlobalOptimizationScore(enrichedZones)
      },
      calculA: new Date().toISOString()
    };

    await this.cache.set(cacheKey, layout, 1800); // 30 min cache
    
    return layout;
  }

  async optimizeZoneAssignment(
    jardinId: string,
    cultures: PlannedCulture[],
    constraints: OptimizationConstraints = {}
  ): Promise<ZoneOptimizationResult> {
    
    const zones = await this.getAvailableZones(jardinId);
    const cultureRequirements = await this.analyzeCultureRequirements(cultures);
    
    // Algorithme d'optimisation multi-objectifs
    const optimizationResult = await this.optimizationService.optimize({
      zones,
      cultures: cultureRequirements,
      objectives: {
        maximizeYield: constraints.maximizeYield || 0.4,
        optimizeRotation: constraints.optimizeRotation || 0.3,
        minimizeWork: constraints.minimizeWork || 0.2,
        improveSoilHealth: constraints.improveSoilHealth || 0.1
      },
      constraints: {
        respectRotations: constraints.respectRotations !== false,
        maxDistanceBetweenCompanions: constraints.maxDistanceBetweenCompanions || 5, // m√®tres
        minSoilQuality: constraints.minSoilQuality || 2
      }
    });

    return {
      assignations: optimizationResult.assignments,
      scoreOptimisation: optimizationResult.score,
      ameliorations: optimizationResult.improvements,
      conflits: optimizationResult.conflicts,
      recommandations: optimizationResult.recommendations,
      estimations: {
        rendementTotalKg: optimizationResult.estimatedYield,
        heuresTravailTotal: optimizationResult.estimatedWorkHours,
        economieEspace: optimizationResult.spaceEfficiency
      }
    };
  }

  async detectProximityIssues(jardinId: string): Promise<ProximityAnalysis> {
    const zones = await this.getZonesWithCultures(jardinId);
    
    const issues: ProximityIssue[] = [];
    const recommendations: ProximityRecommendation[] = [];

    // Analyse deux √† deux des zones adjacentes
    for (let i = 0; i < zones.length; i++) {
      for (let j = i + 1; j < zones.length; j++) {
        const zone1 = zones[i];
        const zone2 = zones[j];
        
        const distance = await this.calculateZoneDistance(zone1, zone2);
        
        if (distance < 2) { // Zones adjacentes (< 2m)
          const compatibility = await this.analyzeCompatibility(zone1, zone2);
          
          if (compatibility.score < 0.3) {
            issues.push({
              zone1: zone1.nom,
              zone2: zone2.nom,
              distance,
              probleme: compatibility.issues,
              severite: compatibility.severity
            });
            
            recommendations.push({
              zones: [zone1.id, zone2.id],
              action: compatibility.recommendedAction,
              priorite: compatibility.severity,
              description: compatibility.solution
            });
          }
        }
      }
    }

    return {
      jardinId,
      issuesDetected: issues,
      recommendations,
      analysedAt: new Date().toISOString()
    };
  }
}

interface ZoneLayout {
  jardinId: string;
  zones: EnrichedZone[];
  statistiques: {
    nombreZones: number;
    surfaceTotale: number;
    surfaceOccupee: number;
    tauxOccupation: number;
    zonesActives: number;
    scoreOptimisationGlobal: number;
  };
  calculA: string;
}

interface EnrichedZone extends Zone {
  geometrie: GeometrieZone;
  capacite: CapaciteOptimale;
  occupationActuelle: {
    pourcentage: number;
    culturesActives: number;
    surfaceDisponible: number;
  };
  santeSol: {
    score: number; // 0-1
    facteursLimitants: string[];
    recommandationsAmelioration: string[];
  };
  optimisationScore: number; // 0-1
  recommandations: ZoneRecommendation[];
}

interface ZoneOptimizationResult {
  assignations: Array<{
    cultureId: string;
    zoneId: string;
    scoreCompatibilite: number;
    surfaceAssignee: number;
    positionOptimale: { x: number; y: number };
  }>;
  scoreOptimisation: number;
  ameliorations: string[];
  conflits: string[];
  recommandations: string[];
  estimations: {
    rendementTotalKg: number;
    heuresTravailTotal: number;
    economieEspace: number;
  };
}
```

## **üì± Interface Mobile (Navigation g√©olocalis√©e)**

### **Carte interactive avec position actuelle**
```typescript
const MobileZoneNavigator = () => {
  const { data: zoneLayout } = useZoneLayout();
  const { location, isLocationEnabled } = useGeolocation();
  const [selectedZone, setSelectedZone] = useState<EnrichedZone>();
  const [mapMode, setMapMode] = useState<'overview' | 'zone' | 'navigation'>('overview');

  return (
    <div className="h-screen flex flex-col">
      {/* Header avec mode et position */}
      <div className="bg-white shadow-sm p-4 flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <h1 className="text-lg font-bold">üó∫Ô∏è Navigation jardin</h1>
          {isLocationEnabled && (
            <div className="flex items-center space-x-1 text-sm text-green-600">
              <MapPin className="h-4 w-4" />
              <span>GPS actif</span>
            </div>
          )}
        </div>
        
        <div className="flex space-x-2">
          <ModeToggle mode={mapMode} onModeChange={setMapMode} />
          <Button 
            size="sm" 
            variant="outline"
            onClick={() => centerMapOnLocation()}
          >
            üìç Ma position
          </Button>
        </div>
      </div>

      {/* Carte interactive principale */}
      <div className="flex-1 relative">
        <ZoneMap
          layout={zoneLayout}
          userLocation={location}
          selectedZone={selectedZone}
          mode={mapMode}
          onZoneSelect={setSelectedZone}
        />
        
        {/* Overlay informations zone s√©lectionn√©e */}
        {selectedZone && (
          <ZoneInfoOverlay 
            zone={selectedZone}
            onClose={() => setSelectedZone(undefined)}
            onNavigate={() => setMapMode('navigation')}
          />
        )}
      </div>

      {/* Bottom sheet avec zones proches */}
      <NearbyZonesSheet 
        userLocation={location}
        zones={zoneLayout?.zones}
        onZoneSelect={setSelectedZone}
      />
    </div>
  );
};

const ZoneMap = ({ layout, userLocation, selectedZone, mode, onZoneSelect }) => {
  const mapRef = useRef<MapRef>();
  const [viewState, setViewState] = useState({
    longitude: layout?.zones[0]?.geometrie.coordonnees[0][1] || 2.3522,
    latitude: layout?.zones[0]?.geometrie.coordonnees[0][0] || 48.8566,
    zoom: 18
  });

  return (
    <div className="w-full h-full">
      <Map
        ref={mapRef}
        {...viewState}
        onMove={evt => setViewState(evt.viewState)}
        mapStyle="mapbox://styles/mapbox/satellite-v9"
        mapboxAccessToken={process.env.NEXT_PUBLIC_MAPBOX_TOKEN}
      >
        {/* Zones du jardin */}
        {layout?.zones.map(zone => (
          <ZonePolygon
            key={zone.id}
            zone={zone}
            selected={selectedZone?.id === zone.id}
            onClick={() => onZoneSelect(zone)}
          />
        ))}

        {/* Position utilisateur */}
        {userLocation && (
          <Marker
            longitude={userLocation.longitude}
            latitude={userLocation.latitude}
          >
            <UserLocationMarker 
              accuracy={userLocation.accuracy}
              isMoving={userLocation.speed > 0.5}
            />
          </Marker>
        )}

        {/* Navigation path si mode navigation */}
        {mode === 'navigation' && selectedZone && userLocation && (
          <NavigationPath
            from={userLocation}
            to={getZoneCenter(selectedZone)}
          />
        )}

        {/* Labels zones */}
        {layout?.zones.map(zone => (
          <Marker
            key={`label-${zone.id}`}
            longitude={getZoneCenter(zone).longitude}
            latitude={getZoneCenter(zone).latitude}
          >
            <ZoneLabel zone={zone} compact={viewState.zoom < 19} />
          </Marker>
        ))}
      </Map>
    </div>
  );
};

const ZonePolygon = ({ zone, selected, onClick }) => {
  const geometrie = zone.geometrie as GeometrieZone;
  
  // Conversion coordonn√©es pour Mapbox
  const coordinates = geometrie.coordonnees.map(coord => [coord[1], coord[0]]);
  
  const fillColor = selected 
    ? '#3B82F6' 
    : getZoneColor(zone.typeZone, zone.occupationActuelle.pourcentage);

  return (
    <Source 
      id={`zone-${zone.id}`}
      type="geojson"
      data={{
        type: 'Feature',
        geometry: {
          type: 'Polygon',
          coordinates: [coordinates]
        },
        properties: { zoneId: zone.id }
      }}
    >
      <Layer
        id={`zone-fill-${zone.id}`}
        type="fill"
        paint={{
          'fill-color': fillColor,
          'fill-opacity': selected ? 0.8 : 0.6
        }}
        onClick={onClick}
      />
      <Layer
        id={`zone-outline-${zone.id}`}
        type="line"
        paint={{
          'line-color': selected ? '#1E40AF' : '#374151',
          'line-width': selected ? 3 : 2
        }}
      />
    </Source>
  );
};

const ZoneInfoOverlay = ({ zone, onClose, onNavigate }) => {
  const occupationActuelle = zone.occupationActuelle;
  const santeSol = zone.santeSol;

  return (
    <motion.div
      initial={{ y: '100%' }}
      animate={{ y: 0 }}
      exit={{ y: '100%' }}
      className="absolute bottom-0 left-0 right-0 bg-white rounded-t-xl shadow-lg max-h-96 overflow-y-auto"
    >
      <div className="p-4">
        {/* Header */}
        <div className="flex items-center justify-between mb-4">
          <div>
            <h3 className="text-lg font-bold">{zone.nom}</h3>
            <p className="text-sm text-gray-600">
              {zone.geometrie.surfaceM2.toFixed(1)} m¬≤ ‚Ä¢ {zone.typeZone.toLowerCase()}
            </p>
          </div>
          
          <div className="flex space-x-2">
            <Button size="sm" onClick={onNavigate}>
              üß≠ S'y rendre
            </Button>
            <Button size="sm" variant="ghost" onClick={onClose}>
              ‚úï
            </Button>
          </div>
        </div>

        {/* √âtat actuel */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="bg-gray-50 rounded-lg p-3">
            <div className="text-sm text-gray-500">Occupation</div>
            <div className="text-lg font-bold">
              {occupationActuelle.pourcentage.toFixed(0)}%
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2 mt-1">
              <div 
                className="bg-green-500 h-2 rounded-full"
                style={{ width: `${occupationActuelle.pourcentage}%` }}
              />
            </div>
          </div>
          
          <div className="bg-gray-50 rounded-lg p-3">
            <div className="text-sm text-gray-500">Sant√© du sol</div>
            <div className="text-lg font-bold">
              {(santeSol.score * 100).toFixed(0)}%
            </div>
            <SoilHealthIndicator score={santeSol.score} />
          </div>
        </div>

        {/* Culture actuelle */}
        {zone.cultureActuelle && (
          <div className="mb-4">
            <h4 className="font-medium text-sm text-gray-700 mb-2">Culture actuelle</h4>
            <div className="flex items-center space-x-3 bg-green-50 rounded-lg p-3">
              <div className="text-2xl">
                {getCategoryIcon(zone.cultureActuelle.variete.varieteBase.categorie)}
              </div>
              <div>
                <div className="font-medium">
                  {zone.cultureActuelle.variete.nomPersonnalise || 
                   zone.cultureActuelle.variete.varieteBase.nomCommun}
                </div>
                <div className="text-sm text-gray-600">
                  Plant√©e il y a {formatDistance(zone.cultureActuelle.dateSemisReelle || zone.cultureActuelle.dateSemisPrevue, new Date(), { locale: fr })}
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Recommandations */}
        {zone.recommandations.length > 0 && (
          <div>
            <h4 className="font-medium text-sm text-gray-700 mb-2">Recommandations</h4>
            <div className="space-y-2">
              {zone.recommandations.slice(0, 3).map((rec, index) => (
                <div key={index} className="flex items-start space-x-2 text-sm">
                  <div className="text-blue-500 mt-0.5">
                    {getRecommendationIcon(rec.type)}
                  </div>
                  <span className="text-gray-700">{rec.description}</span>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Actions rapides */}
        <div className="flex space-x-2 mt-4 pt-4 border-t">
          <Button size="sm" variant="outline" className="flex-1">
            üìù Ajouter intervention
          </Button>
          <Button size="sm" variant="outline" className="flex-1">
            üì∏ Prendre photo
          </Button>
        </div>
      </div>
    </motion.div>
  );
};

const NearbyZonesSheet = ({ userLocation, zones, onZoneSelect }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  const nearbyZones = useMemo(() => {
    if (!userLocation || !zones) return [];
    
    return zones
      .map(zone => ({
        ...zone,
        distance: calculateDistance(userLocation, getZoneCenter(zone))
      }))
      .sort((a, b) => a.distance - b.distance)
      .slice(0, 5);
  }, [userLocation, zones]);

  return (
    <motion.div
      animate={{ height: isExpanded ? 200 : 80 }}
      className="bg-white border-t shadow-lg"
    >
      {/* Header expansible */}
      <div 
        className="p-4 flex items-center justify-between cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <h3 className="font-medium">Zones √† proximit√©</h3>
        <ChevronUp className={`h-5 w-5 transition-transform ${
          isExpanded ? 'rotate-180' : ''
        }`} />
      </div>

      {/* Liste zones proches */}
      {isExpanded && (
        <div className="px-4 pb-4 space-y-2 overflow-y-auto">
          {nearbyZones.map(zone => (
            <div
              key={zone.id}
              onClick={() => onZoneSelect(zone)}
              className="flex items-center justify-between p-2 bg-gray-50 rounded cursor-pointer hover:bg-gray-100"
            >
              <div className="flex items-center space-x-3">
                <div className="text-lg">
                  {getZoneIcon(zone.typeZone)}
                </div>
                <div>
                  <div className="font-medium text-sm">{zone.nom}</div>
                  <div className="text-xs text-gray-500">
                    {zone.distance.toFixed(0)}m ‚Ä¢ {zone.occupationActuelle.pourcentage.toFixed(0)}% occup√©e
                  </div>
                </div>
              </div>
              
              <ChevronRight className="h-4 w-4 text-gray-400" />
            </div>
          ))}
        </div>
      )}
    </motion.div>
  );
};
```

## **üíª Desktop (Gestionnaire complet avec planification)**

### **Interface de gestion avanc√©e avec visualisation 2D**
```typescript
const DesktopZoneManager = () => {
  const [view, setView] = useState<'overview' | 'planning' | 'optimization'>('overview');
  const [selectedZone, setSelectedZone] = useState<EnrichedZone>();
  const [draggedCulture, setDraggedCulture] = useState<PlannedCulture>();
  
  const { data: zoneLayout } = useZoneLayout();
  const { data: availableCultures } = useAvailableCultures();

  return (
    <div className="h-screen flex">
      {/* Sidebar zones */}
      <div className="w-80 bg-gray-50 border-r overflow-y-auto">
        <div className="p-4">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-bold">üó∫Ô∏è Gestion des zones</h2>
            <Button size="sm" onClick={() => openZoneCreationModal()}>
              ‚ûï Zone
            </Button>
          </div>

          <Tabs value={view} onValueChange={setView}>
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger value="overview">Vue d'ensemble</TabsTrigger>
              <TabsTrigger value="planning">Planification</TabsTrigger>
              <TabsTrigger value="optimization">Optimisation</TabsTrigger>
            </TabsList>

            <TabsContent value="overview" className="mt-4">
              <ZoneOverviewTab 
                zones={zoneLayout?.zones}
                onZoneSelect={setSelectedZone}
              />
            </TabsContent>

            <TabsContent value="planning" className="mt-4">
              <ZonePlanningTab 
                zones={zoneLayout?.zones}
                cultures={availableCultures}
                onDragStart={setDraggedCulture}
              />
            </TabsContent>

            <TabsContent value="optimization" className="mt-4">
              <ZoneOptimizationTab 
                zones={zoneLayout?.zones}
              />
            </TabsContent>
          </Tabs>
        </div>
      </div>

      {/* Zone principale avec carte 2D */}
      <div className="flex-1 flex flex-col">
        {/* Header avec actions */}
        <div className="bg-white border-b p-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold">
                {selectedZone ? selectedZone.nom : 'Plan du jardin'}
              </h1>
              {zoneLayout && (
                <p className="text-gray-600">
                  {zoneLayout.statistiques.nombreZones} zones ‚Ä¢ 
                  {zoneLayout.statistiques.surfaceTotale.toFixed(1)} m¬≤ ‚Ä¢ 
                  {zoneLayout.statistiques.tauxOccupation.toFixed(0)}% occup√©
                </p>
              )}
            </div>
            
            <div className="flex space-x-2">
              <LayoutModeToggle />
              <Button variant="outline" onClick={() => runOptimization()}>
                ü§ñ Optimiser assignations
              </Button>
              <Button onClick={() => exportLayout()}>
                üì§ Exporter plan
              </Button>
            </div>
          </div>
        </div>

        {/* Vue 2D interactive */}
        <div className="flex-1 relative overflow-hidden">
          <Zone2DViewer
            layout={zoneLayout}
            selectedZone={selectedZone}
            draggedCulture={draggedCulture}
            onZoneSelect={setSelectedZone}
            onDrop={handleCultureDrop}
            onZoneResize={handleZoneResize}
          />
        </div>
      </div>

      {/* Panel d√©tails zone s√©lectionn√©e */}
      {selectedZone && (
        <ZoneDetailPanel 
          zone={selectedZone}
          onClose={() => setSelectedZone(undefined)}
        />
      )}
    </div>
  );
};

const Zone2DViewer = ({ 
  layout, 
  selectedZone, 
  draggedCulture, 
  onZoneSelect, 
  onDrop, 
  onZoneResize 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>();
  const [scale, setScale] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);

  const draw = useCallback((ctx: CanvasRenderingContext2D) => {
    if (!layout) return;

    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.save();
    
    // Apply transformations
    ctx.translate(pan.x, pan.y);
    ctx.scale(scale, scale);

    // Draw garden bounds
    drawGardenBounds(ctx, layout);

    // Draw zones
    layout.zones.forEach(zone => {
      drawZone(ctx, zone, {
        selected: selectedZone?.id === zone.id,
        hoverable: !draggedCulture,
        dropTarget: draggedCulture && canDropCulture(zone, draggedCulture)
      });
    });

    // Draw zone labels
    layout.zones.forEach(zone => {
      drawZoneLabel(ctx, zone, scale);
    });

    // Draw culture icons if present
    layout.zones.forEach(zone => {
      if (zone.cultureActuelle) {
        drawCultureIcon(ctx, zone, zone.cultureActuelle);
      }
    });

    ctx.restore();
  }, [layout, selectedZone, draggedCulture, scale, pan]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    draw(ctx);
  }, [draw]);

  const handleMouseDown = (e: React.MouseEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = (e.clientX - rect.left - pan.x) / scale;
    const y = (e.clientY - rect.top - pan.y) / scale;

    // Check if clicking on a zone
    const clickedZone = findZoneAtPoint(layout?.zones, { x, y });
    if (clickedZone) {
      onZoneSelect(clickedZone);
    } else {
      setIsDragging(true);
    }
  };

  const handleWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    setScale(prev => Math.max(0.1, Math.min(5, prev * delta)));
  };

  return (
    <div className="w-full h-full relative">
      <canvas
        ref={canvasRef}
        width={800}
        height={600}
        className="w-full h-full cursor-grab active:cursor-grabbing"
        onMouseDown={handleMouseDown}
        onWheel={handleWheel}
        onDrop={(e) => {
          e.preventDefault();
          if (draggedCulture) {
            const rect = canvasRef.current?.getBoundingClientRect();
            if (!rect) return;
            
            const x = (e.clientX - rect.left - pan.x) / scale;
            const y = (e.clientY - rect.top - pan.y) / scale;
            
            const targetZone = findZoneAtPoint(layout?.zones, { x, y });
            if (targetZone && canDropCulture(targetZone, draggedCulture)) {
              onDrop(targetZone, draggedCulture, { x, y });
            }
          }
        }}
        onDragOver={(e) => e.preventDefault()}
      />

      {/* Contr√¥les zoom/pan */}
      <div className="absolute top-4 right-4 bg-white rounded-lg shadow-sm border p-2 space-y-2">
        <Button
          size="sm"
          variant="ghost"
          onClick={() => setScale(prev => Math.min(5, prev * 1.2))}
        >
          üîç+
        </Button>
        <Button
          size="sm"
          variant="ghost"
          onClick={() => setScale(prev => Math.max(0.1, prev / 1.2))}
        >
          üîç-
        </Button>
        <Button
          size="sm"
          variant="ghost"
          onClick={() => {
            setScale(1);
            setPan({ x: 0, y: 0 });
          }}
        >
          üéØ
        </Button>
      </div>

      {/* L√©gende */}
      <ZoneLegend zones={layout?.zones} />
    </div>
  );
};

const ZoneDetailPanel = ({ zone, onClose }) => {
  const [activeTab, setActiveTab] = useState('info');
  const { data: cultureHistory } = useZoneCultureHistory(zone.id);
  const { data: soilAnalysis } = useZoneSoilAnalysis(zone.id);

  const geometrie = zone.geometrie as GeometrieZone;
  const capacite = zone.capaciteOptimale as CapaciteOptimale;

  return (
    <div className="w-96 bg-white border-l flex flex-col">
      {/* Header */}
      <div className="p-4 border-b">
        <div className="flex items-start justify-between">
          <div>
            <h3 className="text-lg font-bold">{zone.nom}</h3>
            <p className="text-sm text-gray-600">
              {geometrie.surfaceM2.toFixed(1)} m¬≤ ‚Ä¢ {zone.typeZone.toLowerCase()}
            </p>
            <div className="flex items-center space-x-4 mt-2">
              <div className="text-sm">
                <span className="text-gray-500">Qualit√© sol:</span>
                <span className="ml-1 font-medium">{zone.qualiteSol}/5</span>
              </div>
              <div className="text-sm">
                <span className="text-gray-500">Optimisation:</span>
                <span className="ml-1 font-medium">
                  {(zone.optimisationScore * 100).toFixed(0)}%
                </span>
              </div>
            </div>
          </div>
          
          <Button variant="ghost" size="sm" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Onglets */}
      <div className="border-b">
        <nav className="flex">
          {[
            { id: 'info', label: 'Infos', icon: Info },
            { id: 'capacity', label: 'Capacit√©', icon: BarChart },
            { id: 'history', label: 'Historique', icon: Clock },
            { id: 'soil', label: 'Sol', icon: Leaf }
          ].map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex-1 py-3 px-2 text-xs font-medium border-b-2 ${
                activeTab === tab.id
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500'
              }`}
            >
              <tab.icon className="h-4 w-4 mx-auto mb-1" />
              {tab.label}
            </button>
          ))}
        </nav>
      </div>

      {/* Contenu onglets */}
      <div className="flex-1 overflow-y-auto p-4">
        {activeTab === 'info' && (
          <ZoneInfoTab zone={zone} geometrie={geometrie} />
        )}
        
        {activeTab === 'capacity' && (
          <ZoneCapacityTab zone={zone} capacite={capacite} />
        )}
        
        {activeTab === 'history' && (
          <ZoneHistoryTab zone={zone} history={cultureHistory} />
        )}
        
        {activeTab === 'soil' && (
          <ZoneSoilTab zone={zone} analysis={soilAnalysis} />
        )}
      </div>
    </div>
  );
};

const ZoneCapacityTab = ({ zone, capacite }) => (
  <div className="space-y-4">
    {/* Capacit√© par cat√©gorie */}
    <div>
      <h4 className="font-medium text-sm text-gray-700 mb-3">
        Capacit√© par type de culture
      </h4>
      
      <div className="space-y-3">
        {Object.entries(capacite.parCategorie).map(([categorie, cap]) => (
          <div key={categorie} className="border rounded-lg p-3">
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center space-x-2">
                <span className="text-lg">{getCategoryIcon(categorie)}</span>
                <span className="font-medium text-sm">{categorie}</span>
              </div>
              <span className="text-xs text-gray-500">
                {cap.densiteOptimale.toFixed(1)} plants/m¬≤
              </span>
            </div>
            
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div>
                <span className="text-gray-500">Plants max:</span>
                <span className="ml-1 font-medium">{cap.nombrePlantsMax}</span>
              </div>
              <div>
                <span className="text-gray-500">Rendement:</span>
                <span className="ml-1 font-medium">{cap.rendementEstimeKg.toFixed(1)}kg</span>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>

    {/* Combinaisons optimales */}
    {capacite.combinaisonsOptimales.length > 0 && (
      <div>
        <h4 className="font-medium text-sm text-gray-700 mb-3">
          Combinaisons recommand√©es
        </h4>
        
        <div className="space-y-2">
          {capacite.combinaisonsOptimales.slice(0, 3).map((combo, index) => (
            <div key={index} className="bg-blue-50 rounded-lg p-3">
              <div className="flex items-center justify-between mb-2">
                <span className="font-medium text-sm">{combo.disposition}</span>
                <Badge variant="outline">
                  Score: {(combo.scoreOptimisation * 100).toFixed(0)}%
                </Badge>
              </div>
              
              <div className="text-xs text-gray-600 mb-2">
                {combo.cultures.join(' + ')}
              </div>
              
              <div className="text-xs">
                <span className="text-green-600">Avantages:</span>
                <span className="ml-1">{combo.avantages[0]}</span>
              </div>
            </div>
          ))}
        </div>
      </div>
    )}

    {/* Contraintes physiques */}
    <div>
      <h4 className="font-medium text-sm text-gray-700 mb-3">
        Contraintes physiques
      </h4>
      
      <div className="bg-gray-50 rounded-lg p-3 space-y-2 text-xs">
        <div className="flex justify-between">
          <span className="text-gray-600">Largeur min. rang:</span>
          <span className="font-medium">{capacite.contraintes.largeurMinRang}cm</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-600">Espacement min.:</span>
          <span className="font-medium">{capacite.contraintes.espacementMinPlants}cm</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-600">Prof. racines max:</span>
          <span className="font-medium">{capacite.contraintes.profondeurRacinesMax}cm</span>
        </div>
        {capacite.contraintes.chargeMaxKgM2 && (
          <div className="flex justify-between">
            <span className="text-gray-600">Charge max:</span>
            <span className="font-medium">{capacite.contraintes.chargeMaxKgM2}kg/m¬≤</span>
          </div>
        )}
      </div>
    </div>
  </div>
);
```

## **üì∫ TV (Vue d'ensemble spectaculaire du jardin)**

### **Interface immersive avec vue satellite**
```typescript
const TVGardenOverview = () => {
  const { data: zoneLayout } = useZoneLayout();
  const { data: timelapseSeasons } = useSeasonalTimelapse();
  const [currentView, setCurrentView] = useState<'overview' | 'timelapse' | 'optimization'>('overview');

  useEffect(() => {
    // Rotation automatique entre vues
    const interval = setInterval(() => {
      setCurrentView(prev => {
        switch (prev) {
          case 'overview': return 'timelapse';
          case 'timelapse': return 'optimization';
          case 'optimization': return 'overview';
          default: return 'overview';
        }
      });
    }, 12000); // 12s par vue

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-green-900 text-white">
      <AnimatePresence mode="wait">
        {currentView === 'overview' && (
          <GardenOverviewMode key="overview" layout={zoneLayout} />
        )}
        
        {currentView === 'timelapse' && (
          <SeasonalTimelapseMode key="timelapse" data={timelapseSeasons} />
        )}
        
        {currentView === 'optimization' && (
          <OptimizationMode key="optimization" layout={zoneLayout} />
        )}
      </AnimatePresence>
    </div>
  );
};

const GardenOverviewMode = ({ layout }) => (
  <motion.div
    initial={{ opacity: 0 }}
    animate={{ opacity: 1 }}
    exit={{ opacity: 0 }}
    className="h-full flex flex-col"
  >
    {/* Header */}
    <div className="p-8 text-center">
      <h1 className="text-5xl font-bold mb-4">üó∫Ô∏è Plan du Jardin</h1>
      <p className="text-xl opacity-80">
        Organisation actuelle des zones de culture
      </p>
    </div>

    {/* Vue satellite stylis√©e */}
    <div className="flex-1 flex items-center justify-center p-12">
      <div className="relative max-w-4xl w-full">
        {/* Repr√©sentation 2D spectaculaire */}
        <SVGGardenView 
          layout={layout}
          animated={true}
          showDetails={true}
        />
        
        {/* Overlay statistiques */}
        <div className="absolute top-4 left-4 bg-black bg-opacity-40 backdrop-blur-sm rounded-lg p-4">
          <GardenStats stats={layout?.statistiques} />
        </div>
        
        {/* L√©gende zones */}
        <div className="absolute bottom-4 right-4 bg-black bg-opacity-40 backdrop-blur-sm rounded-lg p-4">
          <ZoneTypeLegend zones={layout?.zones} />
        </div>
      </div>
    </div>
  </motion.div>
);

const SVGGardenView = ({ layout, animated, showDetails }) => {
  if (!layout) return null;

  // Calcul du viewport optimal
  const bounds = calculateGardenBounds(layout.zones);
  const viewBox = `${bounds.minX - 1} ${bounds.minY - 1} ${bounds.width + 2} ${bounds.height + 2}`;

  return (
    <svg 
      viewBox={viewBox}
      className="w-full h-full"
      style={{ maxHeight: '70vh' }}
    >
      {/* D√©finitions pour gradients et patterns */}
      <defs>
        <radialGradient id="zoneGradient" cx="50%" cy="50%" r="50%">
          <stop offset="0%" stopColor="rgba(34, 197, 94, 0.8)" />
          <stop offset="100%" stopColor="rgba(34, 197, 94, 0.4)" />
        </radialGradient>
        
        <pattern id="soilPattern" patternUnits="userSpaceOnUse" width="0.1" height="0.1">
          <circle cx="0.05" cy="0.05" r="0.02" fill="rgba(139, 69, 19, 0.3)" />
        </pattern>
      </defs>

      {/* Fond du jardin */}
      <rect
        x={bounds.minX - 0.5}
        y={bounds.minY - 0.5}
        width={bounds.width + 1}
        height={bounds.height + 1}
        fill="url(#soilPattern)"
        stroke="rgba(255, 255, 255, 0.2)"
        strokeWidth="0.05"
        rx="0.2"
      />

      {/* Zones */}
      {layout.zones.map((zone, index) => (
        <motion.g
          key={zone.id}
          initial={animated ? { opacity: 0, scale: 0.8 } : {}}
          animate={animated ? { opacity: 1, scale: 1 } : {}}
          transition={animated ? { delay: index * 0.2, duration: 0.8 } : {}}
        >
          <ZoneSVGElement 
            zone={zone}
            showDetails={showDetails}
            animated={animated}
          />
        </motion.g>
      ))}

      {/* Connexions et chemins */}
      <PathNetwork zones={layout.zones} />
    </svg>
  );
};

const ZoneSVGElement = ({ zone, showDetails, animated }) => {
  const geometrie = zone.geometrie as GeometrieZone;
  const occupationActuelle = zone.occupationActuelle;
  
  // Conversion coordonn√©es pour SVG
  const points = geometrie.coordonnees.map(coord => `${coord[1]},${coord[0]}`).join(' ');
  
  // Couleur selon type et occupation
  const fillColor = getZoneColorForType(zone.typeZone);
  const opacity = 0.7 + (occupationActuelle.pourcentage / 100) * 0.3;

  return (
    <g>
      {/* Zone polygon */}
      <polygon
        points={points}
        fill={fillColor}
        fillOpacity={opacity}
        stroke="white"
        strokeWidth="0.02"
        className="drop-shadow-sm"
      >
        {animated && (
          <animate
            attributeName="fill-opacity"
            values={`${opacity};${opacity + 0.2};${opacity}`}
            dur="3s"
            repeatCount="indefinite"
          />
        )}
      </polygon>

      {/* Culture icon si pr√©sente */}
      {zone.cultureActuelle && showDetails && (
        <CultureIconSVG 
          zone={zone}
          culture={zone.cultureActuelle}
        />
      )}

      {/* Label zone */}
      <text
        x={getZoneCenterX(geometrie)}
        y={getZoneCenterY(geometrie)}
        textAnchor="middle"
        dominantBaseline="central"
        fontSize="0.15"
        fill="white"
        fontWeight="bold"
        className="drop-shadow"
      >
        {zone.nom}
      </text>

      {/* Indicateur occupation */}
      {showDetails && (
        <g>
          <circle
            cx={getZoneCenterX(geometrie) + 0.3}
            cy={getZoneCenterY(geometrie) - 0.3}
            r="0.08"
            fill="rgba(0, 0, 0, 0.6)"
          />
          <text
            x={getZoneCenterX(geometrie) + 0.3}
            y={getZoneCenterY(geometrie) - 0.3}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize="0.06"
            fill="white"
            fontWeight="bold"
          >
            {occupationActuelle.pourcentage.toFixed(0)}%
          </text>
        </g>
      )}
    </g>
  );
};

const GardenStats = ({ stats }) => (
  <div className="text-white space-y-2">
    <h3 className="text-lg font-bold mb-3">üìä Statistiques</h3>
    
    <div className="grid grid-cols-2 gap-3 text-sm">
      <div>
        <div className="text-gray-300">Zones totales</div>
        <div className="text-xl font-bold">{stats?.nombreZones}</div>
      </div>
      
      <div>
        <div className="text-gray-300">Surface totale</div>
        <div className="text-xl font-bold">{stats?.surfaceTotale.toFixed(0)}m¬≤</div>
      </div>
      
      <div>
        <div className="text-gray-300">Zones actives</div>
        <div className="text-xl font-bold text-green-400">{stats?.zonesActives}</div>
      </div>
      
      <div>
        <div className="text-gray-300">Optimisation</div>
        <div className="text-xl font-bold text-blue-400">
          {stats?.scoreOptimisationGlobal.toFixed(0)}%
        </div>
      </div>
    </div>

    {/* Barre d'occupation */}
    <div className="mt-4">
      <div className="flex justify-between text-xs text-gray-300 mb-1">
        <span>Occupation</span>
        <span>{stats?.tauxOccupation.toFixed(0)}%</span>
      </div>
      <div className="w-full bg-gray-700 rounded-full h-2">
        <div 
          className="bg-green-400 h-2 rounded-full transition-all duration-1000"
          style={{ width: `${stats?.tauxOccupation}%` }}
        />
      </div>
    </div>
  </div>
);

const OptimizationMode = ({ layout }) => {
  const { data: optimizationSuggestions } = useOptimizationSuggestions();
  
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="h-full flex flex-col"
    >
      <div className="p-8 text-center">
        <h1 className="text-5xl font-bold mb-4">ü§ñ Optimisation IA</h1>
        <p className="text-xl opacity-80">
          Suggestions d'am√©lioration de l'organisation
        </p>
      </div>

      <div className="flex-1 flex items-center justify-center p-12">
        <div className="grid grid-cols-2 gap-12 max-w-6xl">
          {/* Vue actuelle */}
          <div className="space-y-4">
            <h2 className="text-2xl font-bold text-center">üìã Organisation actuelle</h2>
            <SVGGardenView 
              layout={layout}
              animated={false}
              showDetails={true}
            />
            <div className="text-center">
              <div className="text-3xl font-bold text-red-400">
                {layout?.statistiques.scoreOptimisationGlobal.toFixed(0)}%
              </div>
              <div className="text-sm opacity-80">Score d'optimisation</div>
            </div>
          </div>

          {/* Vue optimis√©e */}
          <div className="space-y-4">
            <h2 className="text-2xl font-bold text-center">‚ú® Organisation optimis√©e</h2>
            <OptimizedGardenView 
              layout={layout}
              suggestions={optimizationSuggestions}
            />
            <div className="text-center">
              <div className="text-3xl font-bold text-green-400">
                {optimizationSuggestions?.scoreOptimise?.toFixed(0) || '85'}%
              </div>
              <div className="text-sm opacity-80">Score optimis√©</div>
            </div>
          </div>
        </div>
      </div>

      {/* Suggestions d'am√©lioration */}
      <div className="bg-black bg-opacity-30 p-6">
        <h3 className="text-xl font-bold mb-4 text-center">üí° Am√©liorations sugg√©r√©es</h3>
        <div className="grid grid-cols-3 gap-6 max-w-4xl mx-auto">
          {optimizationSuggestions?.suggestions.slice(0, 3).map((suggestion, index) => (
            <motion.div
              key={index}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.3 }}
              className="bg-white bg-opacity-10 backdrop-blur-sm rounded-lg p-4 text-center"
            >
              <div className="text-2xl mb-2">{suggestion.icon}</div>
              <h4 className="font-bold mb-2">{suggestion.titre}</h4>
              <p className="text-sm opacity-80">{suggestion.description}</p>
              <div className="mt-3">
                <Badge variant="secondary">
                  +{suggestion.impactScore}% optimisation
                </Badge>
              </div>
            </motion.div>
          ))}
        </div>
      </div>
    </motion.div>
  );
};
```

## **‚úÖ Crit√®res d'acceptation**

### **Mod√©lisation spatiale**
- [ ] **4 bacs Sacha** (8m x 0.8m) + zones libres mod√©lis√©es pr√©cis√©ment ‚úÖ
- [ ] **G√©om√©trie PostGIS** pour calculs spatiaux avanc√©s ‚úÖ
- [ ] **Capacit√© optimale** calcul√©e automatiquement par zone ‚úÖ
- [ ] **Contraintes rotations** respect√©es automatiquement ‚úÖ

### **Interface par device**
- [ ] **Mobile** : Navigation g√©olocalis√©e avec carte interactive ‚úÖ
- [ ] **Desktop** : Gestionnaire 2D avec drag & drop cultures ‚úÖ
- [ ] **TV** : Vue d'ensemble spectaculaire avec optimisation IA ‚úÖ

### **Optimisation spatiale**
- [ ] **Algorithmes assignation** cultures selon contraintes ‚úÖ
- [ ] **Calculs de compatibilit√©** entre zones adjacentes ‚úÖ
- [ ] **Suggestions am√©lioration** bas√©es sur historique ‚úÖ
- [ ] **Score optimisation global** temps r√©el ‚úÖ

### **Gestion avanc√©e**
- [ ] **Tracking occupation** pourcentage par zone ‚úÖ
- [ ] **Historique cultures** pour rotations intelligentes ‚úÖ
- [ ] **Maintenance zones** avec planning am√©liorations ‚úÖ
- [ ] **Export/import** plans de jardin ‚úÖ

### **Performance**
- [ ] **Calculs g√©ospatiaux** optimis√©s PostgreSQL/PostGIS ‚úÖ
- [ ] **Cache intelligent** layouts et optimisations ‚úÖ
- [ ] **Sync temps r√©el** assignations cross-device ‚úÖ
- [ ] **Rendering 2D** fluide m√™me avec 20+ zones ‚úÖ

## **üèóÔ∏è Exigences architecturales couvertes**

- **EXG-001.2** : API Routes `/src/app/api/zones/*` ‚úÖ
- **EXG-002.1** : PostgreSQL + PostGIS g√©ospatial ‚úÖ
- **EXG-002.2** : Mod√®les Prisma avec g√©om√©trie optimis√©e ‚úÖ
- **EXG-003.1** : PWA g√©olocalisation mobile ‚úÖ
- **EXG-003.2** : Interface responsive multi-device ‚úÖ
- **EXG-005.2** : Algorithmes optimisation asynchrones ‚úÖ
- **EXG-007.3** : Performance < 2s avec index spatiaux ‚úÖ

## **üöÄ Plan d'impl√©mentation**

### **Phase 1 : Mod√®les & G√©ospatial (4j)**
1. Extension mod√®le Zone avec PostGIS
2. Algorithmes calcul capacit√© optimale
3. Service gestion g√©ospatiale avec contraintes
4. API Routes CRUD zones compl√®tes

### **Phase 2 : Interface Mobile (3j)**
1. Carte interactive avec g√©olocalisation
2. Navigation zones avec position utilisateur
3. Overlay informations zones d√©taill√©es
4. Mode offline avec cache g√©om√©tries

### **Phase 3 : Interface Desktop (4j)**
1. Vue 2D interactive avec Canvas/SVG
2. Drag & drop cultures vers zones
3. Panel d√©tails avec onglets avanc√©s
4. Outils optimisation et planification

### **Phase 4 : Algorithmes Optimisation (3j)**
1. Calculs compatibilit√© zones adjacentes
2. Algorithmes assignation multi-objectifs
3. D√©tection conflits et recommandations
4. Score optimisation global temps r√©el

### **Phase 5 : Interface TV & Polish (2j)**
1. Vue d'ensemble spectaculaire SVG
2. Mode optimisation avec comparaisons
3. Animations et transitions immersives
4. Export plans et documentation

**Dur√©e totale estim√©e : 16 jours**