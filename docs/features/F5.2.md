# F5.2 - Intégration Avancée IA

**Score Priorité :** 70/100  
**Statut :** PRIORITÉ MODÉRÉE  
**Epic :** EPIC 5 - EXTENSION IoT  
**Effort estimé :** 26 jours  

## Description

Intégration avancée de l'intelligence artificielle avec serveur MCP (Model Context Protocol), agents IA autonomes, workflows multi-modèles et capacités d'apprentissage continu pour fournir une assistance intelligente personnalisée et évolutive.

## User Stories

### US5.2.1 - Assistant IA Conversationnel
**En tant qu'** utilisateur occasionnel  
**Je veux** converser naturellement avec une IA spécialisée en jardinage  
**Afin d'** obtenir des conseils personnalisés en temps réel  

**Critères d'acceptation :**
- Chat interface avec IA spécialisée jardinage
- Compréhension du contexte du jardin utilisateur
- Réponses personnalisées basées sur l'historique
- Support vocal (speech-to-text et text-to-speech)
- Intégration photos pour diagnostic visuel

### US5.2.2 - Agents IA Autonomes
**En tant qu'** expert jardinier  
**Je veux** que des agents IA surveillent et optimisent mon jardin automatiquement  
**Afin de** bénéficier d'une gestion proactive sans intervention constante  

**Critères d'acceptation :**
- Agent surveillance continue des conditions
- Agent optimisation automatique des paramètres
- Agent prédiction et prévention des problèmes
- Coordination entre agents avec résolution de conflits
- Tableau de bord des activités des agents

### US5.2.3 - Apprentissage Adaptatif
**En tant qu'** utilisateur avancé  
**Je veux** que l'IA apprenne de mes préférences et résultats  
**Afin d'** améliorer continuellement la pertinence des recommandations  

**Critères d'acceptation :**
- Feedback loop sur les recommandations appliquées
- Modèles personnalisés basés sur l'historique utilisateur
- Adaptation selon les spécificités climatiques locales
- Amélioration continue des prédictions
- Explicabilité des décisions IA

## Architecture Technique

### Serveur MCP (Model Context Protocol)

```typescript
// src/services/ai/mcp-server.service.ts
import { MCPServer, Tool, Resource } from '@modelcontextprotocol/sdk';

export class BasMalinMCPServer extends MCPServer {
  private tools: Map<string, MCPTool> = new Map();
  private resources: Map<string, MCPResource> = new Map();
  private contexts: Map<string, AIContext> = new Map();

  constructor(
    private prisma: PrismaClient,
    private iotService: IoTService,
    private weatherService: WeatherService,
    private aiAgentService: AIAgentService
  ) {
    super({
      name: 'bas-malin-garden-assistant',
      version: '1.0.0',
      description: 'Assistant IA spécialisé en jardinage intelligent'
    });
    
    this.initializeTools();
    this.initializeResources();
  }

  private initializeTools(): void {
    // Outil d'analyse des conditions du jardin
    this.registerTool({
      name: 'analyze_garden_conditions',
      description: 'Analyse les conditions actuelles du jardin',
      inputSchema: {
        type: 'object',
        properties: {
          gardenId: { type: 'string' },
          includeHistory: { type: 'boolean', default: false },
          timeframe: { type: 'string', default: '24h' }
        },
        required: ['gardenId']
      },
      handler: this.analyzeGardenConditions.bind(this)
    });

    // Outil de diagnostic des problèmes
    this.registerTool({
      name: 'diagnose_plant_issue',
      description: 'Diagnostique les problèmes de santé des plantes',
      inputSchema: {
        type: 'object',
        properties: {
          imageUrl: { type: 'string' },
          symptoms: { type: 'string' },
          plantType: { type: 'string' },
          location: { type: 'string' }
        },
        required: ['symptoms']
      },
      handler: this.diagnosePlantIssue.bind(this)
    });

    // Outil de planification des interventions
    this.registerTool({
      name: 'plan_garden_intervention',
      description: 'Planifie les interventions de jardinage',
      inputSchema: {
        type: 'object',
        properties: {
          interventionType: { 
            type: 'string',
            enum: ['watering', 'fertilizing', 'pruning', 'harvesting', 'planting']
          },
          gardenId: { type: 'string' },
          constraints: { type: 'object' },
          priority: { type: 'string', enum: ['low', 'medium', 'high', 'urgent'] }
        },
        required: ['interventionType', 'gardenId']
      },
      handler: this.planGardenIntervention.bind(this)
    });

    // Outil de prédiction météo impact
    this.registerTool({
      name: 'predict_weather_impact',
      description: 'Prédit l\'impact des conditions météo sur le jardin',
      inputSchema: {
        type: 'object',
        properties: {
          gardenId: { type: 'string' },
          forecastDays: { type: 'number', default: 7 },
          includeRecommendations: { type: 'boolean', default: true }
        },
        required: ['gardenId']
      },
      handler: this.predictWeatherImpact.bind(this)
    });

    // Outil de calcul d'optimisation
    this.registerTool({
      name: 'optimize_garden_layout',
      description: 'Optimise la disposition du jardin',
      inputSchema: {
        type: 'object',
        properties: {
          gardenId: { type: 'string' },
          objectives: { 
            type: 'array',
            items: { type: 'string' }
          },
          constraints: { type: 'object' }
        },
        required: ['gardenId']
      },
      handler: this.optimizeGardenLayout.bind(this)
    });
  }

  private initializeResources(): void {
    // Ressource des données de jardin
    this.registerResource({
      uri: 'garden://data/current',
      name: 'Current Garden Data',
      description: 'Données actuelles du jardin (capteurs, météo, état des cultures)',
      mimeType: 'application/json'
    });

    // Ressource de la base de connaissances
    this.registerResource({
      uri: 'knowledge://gardening/best-practices',
      name: 'Gardening Knowledge Base',
      description: 'Base de connaissances des meilleures pratiques de jardinage',
      mimeType: 'application/json'
    });

    // Ressource des modèles IA
    this.registerResource({
      uri: 'models://prediction/yield',
      name: 'Yield Prediction Models',
      description: 'Modèles de prédiction de rendement',
      mimeType: 'application/json'
    });
  }

  async analyzeGardenConditions(args: any): Promise<ToolResult> {
    const { gardenId, includeHistory, timeframe } = args;

    try {
      // Collecte des données actuelles
      const currentData = await this.collectCurrentGardenData(gardenId);
      
      // Données historiques si demandées
      let historicalData = null;
      if (includeHistory) {
        historicalData = await this.collectHistoricalData(gardenId, timeframe);
      }

      // Analyse avec IA
      const analysis = await this.aiAgentService.analyzeGardenConditions({
        current: currentData,
        historical: historicalData,
        context: this.contexts.get(gardenId)
      });

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'success',
            analysis: {
              overallHealth: analysis.overallHealth,
              criticalIssues: analysis.criticalIssues,
              opportunities: analysis.opportunities,
              recommendations: analysis.recommendations,
              trends: analysis.trends
            },
            timestamp: new Date().toISOString()
          }, null, 2)
        }]
      };

    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'error',
            message: error.message
          })
        }],
        isError: true
      };
    }
  }

  async diagnosePlantIssue(args: any): Promise<ToolResult> {
    const { imageUrl, symptoms, plantType, location } = args;

    try {
      // Analyse d'image si fournie
      let imageAnalysis = null;
      if (imageUrl) {
        imageAnalysis = await this.aiAgentService.analyzePhotoForDiagnosis(imageUrl);
      }

      // Diagnostic basé sur les symptômes
      const diagnosis = await this.aiAgentService.diagnosePlantIssue({
        symptoms,
        plantType,
        location,
        imageAnalysis,
        context: this.contexts.get('global')
      });

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'success',
            diagnosis: {
              probableIssues: diagnosis.probableIssues,
              confidence: diagnosis.confidence,
              treatments: diagnosis.treatments,
              preventionTips: diagnosis.preventionTips,
              urgency: diagnosis.urgency
            }
          }, null, 2)
        }]
      };

    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'error',
            message: error.message
          })
        }],
        isError: true
      };
    }
  }

  private async collectCurrentGardenData(gardenId: string): Promise<GardenDataSnapshot> {
    const [iotData, weatherData, culturesData] = await Promise.all([
      this.iotService.getCurrentReadings(gardenId),
      this.weatherService.getCurrentConditions(gardenId),
      this.getCulturesStatus(gardenId)
    ]);

    return {
      timestamp: new Date(),
      iot: iotData,
      weather: weatherData,
      cultures: culturesData,
      gardenId
    };
  }
}
```

### Agents IA Autonomes

```typescript
// src/services/ai/ai-agent.service.ts
export interface AIAgent {
  id: string;
  name: string;
  type: AgentType;
  status: 'active' | 'inactive' | 'error';
  config: AgentConfig;
  lastAction: Date;
  metrics: AgentMetrics;
}

export type AgentType = 
  | 'garden_monitor'     // Surveillance continue
  | 'optimization'       // Optimisation automatique
  | 'prediction'         // Prédictions et alertes
  | 'intervention'       // Planification interventions
  | 'learning';          // Apprentissage et adaptation

export class AIAgentService {
  private agents: Map<string, AIAgent> = new Map();
  private eventBus: EventEmitter;
  private schedulerService: AgentSchedulerService;

  constructor(
    private openaiClient: OpenAI,
    private anthropicClient: Anthropic,
    private ollamaService: OllamaService,
    private mcpServer: BasMalinMCPServer
  ) {
    this.eventBus = new EventEmitter();
    this.schedulerService = new AgentSchedulerService();
    this.initializeAgents();
  }

  private initializeAgents(): void {
    // Agent de surveillance
    this.createAgent({
      id: 'garden-monitor-001',
      name: 'Garden Health Monitor',
      type: 'garden_monitor',
      config: {
        checkInterval: 30 * 60 * 1000, // 30 minutes
        thresholds: {
          temperature: { min: 5, max: 35 },
          humidity: { min: 30, max: 90 },
          soilMoisture: { min: 20, max: 80 }
        },
        alertChannels: ['push', 'email'],
        scope: 'all_gardens'
      }
    });

    // Agent d'optimisation
    this.createAgent({
      id: 'optimization-001',
      name: 'Garden Optimizer',
      type: 'optimization',
      config: {
        optimizationInterval: 6 * 60 * 60 * 1000, // 6 heures
        objectives: ['yield_maximization', 'water_efficiency', 'pest_prevention'],
        constraints: ['budget', 'time', 'resources'],
        autoApply: false, // Demande confirmation avant application
        scope: 'active_gardens'
      }
    });

    // Agent de prédiction
    this.createAgent({
      id: 'prediction-001',
      name: 'Predictive Analytics Agent',
      type: 'prediction',
      config: {
        predictionHorizon: 14, // 14 jours
        models: ['weather_impact', 'yield_forecast', 'pest_probability'],
        confidenceThreshold: 0.7,
        updateFrequency: 24 * 60 * 60 * 1000, // 24 heures
        scope: 'all_gardens'
      }
    });
  }

  async createAgent(config: AgentCreationConfig): Promise<AIAgent> {
    const agent: AIAgent = {
      id: config.id,
      name: config.name,
      type: config.type,
      status: 'active',
      config: config.config,
      lastAction: new Date(),
      metrics: {
        actionsPerformed: 0,
        successRate: 100,
        averageResponseTime: 0,
        resourceUsage: {
          apiCalls: 0,
          computeTime: 0,
          memoryUsage: 0
        }
      }
    };

    this.agents.set(agent.id, agent);
    
    // Démarrage de l'agent
    await this.startAgent(agent.id);
    
    this.eventBus.emit('agentCreated', agent);
    
    return agent;
  }

  private async startAgent(agentId: string): Promise<void> {
    const agent = this.agents.get(agentId);
    if (!agent) throw new Error(`Agent ${agentId} not found`);

    switch (agent.type) {
      case 'garden_monitor':
        this.startMonitoringAgent(agent);
        break;
      case 'optimization':
        this.startOptimizationAgent(agent);
        break;
      case 'prediction':
        this.startPredictionAgent(agent);
        break;
    }
  }

  private async startMonitoringAgent(agent: AIAgent): Promise<void> {
    const interval = setInterval(async () => {
      try {
        const startTime = Date.now();
        
        // Collecte des données de tous les jardins
        const gardens = await this.getActiveGardens();
        
        for (const garden of gardens) {
          const conditions = await this.mcpServer.collectCurrentGardenData(garden.id);
          const analysis = await this.analyzeConditionsForThresholds(conditions, agent.config.thresholds);
          
          // Génération d'alertes si nécessaire
          if (analysis.alertsTriggered.length > 0) {
            await this.processAlerts(analysis.alertsTriggered, agent.config.alertChannels);
          }

          // Recommandations proactives
          if (analysis.recommendations.length > 0) {
            await this.generateProactiveRecommendations(garden.id, analysis.recommendations);
          }
        }

        // Mise à jour métriques
        this.updateAgentMetrics(agent.id, {
          actionsPerformed: agent.metrics.actionsPerformed + 1,
          averageResponseTime: (Date.now() - startTime)
        });

      } catch (error) {
        console.error(`Monitoring agent ${agent.id} error:`, error);
        this.updateAgentStatus(agent.id, 'error');
      }
    }, agent.config.checkInterval);

    // Stockage de l'interval pour pouvoir l'arrêter
    agent.config._interval = interval;
  }

  private async startOptimizationAgent(agent: AIAgent): Promise<void> {
    const interval = setInterval(async () => {
      try {
        const gardens = await this.getActiveGardens();
        
        for (const garden of gardens) {
          // Collecte des données pour optimisation
          const data = await this.collectOptimizationData(garden.id);
          
          // Analyse d'opportunités d'optimisation
          const opportunities = await this.identifyOptimizationOpportunities(data, agent.config.objectives);
          
          // Génération de plans d'optimisation
          if (opportunities.length > 0) {
            const optimizationPlan = await this.generateOptimizationPlan(opportunities, agent.config.constraints);
            
            if (agent.config.autoApply) {
              await this.applyOptimizationPlan(garden.id, optimizationPlan);
            } else {
              await this.requestOptimizationApproval(garden.id, optimizationPlan);
            }
          }
        }

      } catch (error) {
        console.error(`Optimization agent ${agent.id} error:`, error);
        this.updateAgentStatus(agent.id, 'error');
      }
    }, agent.config.optimizationInterval);

    agent.config._interval = interval;
  }

  async analyzePhotoForDiagnosis(imageUrl: string): Promise<PhotoDiagnosisResult> {
    try {
      // Analyse avec OpenAI GPT-4 Vision
      const openaiAnalysis = await this.openaiClient.chat.completions.create({
        model: 'gpt-4-vision-preview',
        messages: [
          {
            role: 'system',
            content: `Tu es un expert en diagnostic des maladies des plantes. Analyse cette photo et fournis:
            1. Identification de la plante si possible
            2. Problèmes visibles (maladies, parasites, carences)
            3. Niveau de sévérité (1-5)
            4. Traitements recommandés
            5. Mesures préventives
            
            Réponds en JSON avec les clés: plant_identification, issues, severity, treatments, prevention.`
          },
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'Diagnostique les problèmes de cette plante:'
              },
              {
                type: 'image_url',
                image_url: { url: imageUrl }
              }
            ]
          }
        ],
        max_tokens: 1000
      });

      const analysis = JSON.parse(openaiAnalysis.choices[0].message.content || '{}');

      // Validation croisée avec Claude si confiance faible
      let claudeValidation = null;
      if (analysis.confidence < 0.8) {
        claudeValidation = await this.validateDiagnosisWithClaude(imageUrl, analysis);
      }

      return {
        plantIdentification: analysis.plant_identification,
        issues: analysis.issues,
        severity: analysis.severity,
        treatments: analysis.treatments,
        prevention: analysis.prevention,
        confidence: this.calculateDiagnosisConfidence(analysis, claudeValidation),
        validatedBy: claudeValidation ? ['openai', 'claude'] : ['openai']
      };

    } catch (error) {
      console.error('Photo diagnosis failed:', error);
      throw new Error('Unable to analyze photo for diagnosis');
    }
  }

  async generateConversationalResponse(
    message: string,
    context: ConversationContext
  ): Promise<ConversationalResponse> {
    try {
      // Enrichissement du contexte avec données jardin
      const enrichedContext = await this.enrichConversationContext(context);
      
      // Analyse de l'intention utilisateur
      const intent = await this.analyzeUserIntent(message);
      
      // Sélection du modèle optimal selon l'intention
      const model = this.selectOptimalModel(intent);
      
      // Génération de la réponse
      let response;
      switch (model) {
        case 'openai':
          response = await this.generateOpenAIResponse(message, enrichedContext, intent);
          break;
        case 'claude':
          response = await this.generateClaudeResponse(message, enrichedContext, intent);
          break;
        case 'local':
          response = await this.generateLocalResponse(message, enrichedContext, intent);
          break;
      }

      // Post-traitement et enrichissement
      const enrichedResponse = await this.enrichResponse(response, enrichedContext);
      
      return {
        text: enrichedResponse.text,
        suggestions: enrichedResponse.suggestions,
        actions: enrichedResponse.actions,
        resources: enrichedResponse.resources,
        followUp: enrichedResponse.followUp,
        confidence: enrichedResponse.confidence,
        modelUsed: model
      };

    } catch (error) {
      console.error('Conversational response generation failed:', error);
      return {
        text: "Désolé, je rencontre un problème technique. Pouvez-vous reformuler votre question ?",
        confidence: 0,
        modelUsed: 'fallback'
      };
    }
  }
}
```

### Interface Assistant IA

```typescript
// src/app/ai-assistant/page.tsx
export default function AIAssistantPage() {
  const [messages, setMessages] = useState<ConversationMessage[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [agents, setAgents] = useState<AIAgent[]>([]);
  const [selectedMode, setSelectedMode] = useState<'chat' | 'agents' | 'insights'>('chat');

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: ConversationMessage = {
      id: generateId(),
      role: 'user',
      content: input,
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await aiAgentService.generateConversationalResponse(input, {
        gardenId: 'current-garden',
        previousMessages: messages.slice(-5), // 5 derniers messages pour contexte
        userProfile: await getUserProfile()
      });

      const assistantMessage: ConversationMessage = {
        id: generateId(),
        role: 'assistant',
        content: response.text,
        timestamp: new Date(),
        suggestions: response.suggestions,
        actions: response.actions,
        confidence: response.confidence
      };

      setMessages(prev => [...prev, assistantMessage]);

    } catch (error) {
      console.error('Failed to get AI response:', error);
      // Message d'erreur gracieux
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      {/* Header */}
      <div className="border-b bg-white px-6 py-4">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-xl font-semibold">Assistant IA Jardin</h1>
            <p className="text-sm text-gray-600">
              Votre expert IA personnel en jardinage
            </p>
          </div>
          
          <div className="flex items-center space-x-2">
            <ModeSelector value={selectedMode} onChange={setSelectedMode} />
            <Button variant="outline" size="sm">
              <SettingsIcon className="w-4 h-4" />
            </Button>
          </div>
        </div>
      </div>

      <div className="flex-1 flex">
        {selectedMode === 'chat' && (
          <div className="flex-1 flex flex-col">
            {/* Zone de conversation */}
            <div className="flex-1 overflow-auto p-6">
              <ConversationView 
                messages={messages}
                isLoading={isLoading}
              />
            </div>

            {/* Zone de saisie */}
            <div className="border-t bg-white p-4">
              <ChatInput
                value={input}
                onChange={setInput}
                onSend={sendMessage}
                disabled={isLoading}
                placeholder="Posez votre question sur le jardinage..."
              />
            </div>
          </div>
        )}

        {selectedMode === 'agents' && (
          <div className="flex-1 p-6">
            <AgentsManagementPanel agents={agents} />
          </div>
        )}

        {selectedMode === 'insights' && (
          <div className="flex-1 p-6">
            <AIInsightsPanel />
          </div>
        )}
      </div>
    </div>
  );
}

const ConversationView = ({ messages, isLoading }: {
  messages: ConversationMessage[];
  isLoading: boolean;
}) => {
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="space-y-4">
      {messages.length === 0 && (
        <WelcomeMessage />
      )}
      
      {messages.map(message => (
        <MessageBubble key={message.id} message={message} />
      ))}
      
      {isLoading && (
        <div className="flex justify-start">
          <div className="bg-white rounded-lg px-4 py-2 shadow-sm border">
            <div className="flex items-center space-x-2">
              <div className="animate-spin w-4 h-4 border-2 border-green-500 border-t-transparent rounded-full" />
              <span className="text-sm text-gray-600">L'IA réfléchit...</span>
            </div>
          </div>
        </div>
      )}
      
      <div ref={messagesEndRef} />
    </div>
  );
};

const MessageBubble = ({ message }: { message: ConversationMessage }) => {
  const isUser = message.role === 'user';

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      <div className={`max-w-2xl rounded-lg px-4 py-2 ${
        isUser 
          ? 'bg-green-500 text-white' 
          : 'bg-white border shadow-sm'
      }`}>
        <div className="text-sm">
          {message.content}
        </div>
        
        {message.confidence && !isUser && (
          <div className="text-xs text-gray-500 mt-1">
            Confiance: {Math.round(message.confidence * 100)}%
          </div>
        )}
        
        {message.suggestions && message.suggestions.length > 0 && (
          <div className="mt-3 space-y-1">
            <div className="text-xs font-medium text-gray-600">Suggestions:</div>
            {message.suggestions.map((suggestion, index) => (
              <button
                key={index}
                className="block text-left text-xs bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 w-full"
                onClick={() => console.log('Suggestion clicked:', suggestion)}
              >
                {suggestion}
              </button>
            ))}
          </div>
        )}
        
        {message.actions && message.actions.length > 0 && (
          <div className="mt-3 space-y-1">
            <div className="text-xs font-medium text-gray-600">Actions disponibles:</div>
            <div className="flex gap-1 flex-wrap">
              {message.actions.map((action, index) => (
                <Button
                  key={index}
                  size="sm"
                  variant="outline"
                  className="text-xs"
                  onClick={() => console.log('Action clicked:', action)}
                >
                  {action.label}
                </Button>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

const AgentsManagementPanel = ({ agents }: { agents: AIAgent[] }) => {
  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-lg font-semibold mb-4">Agents IA Actifs</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {agents.map(agent => (
            <AgentCard key={agent.id} agent={agent} />
          ))}
        </div>
      </div>
      
      <div>
        <h3 className="font-medium mb-3">Créer un Nouvel Agent</h3>
        <AgentCreationForm />
      </div>
    </div>
  );
};

const AgentCard = ({ agent }: { agent: AIAgent }) => {
  const statusColor = {
    active: 'text-green-600',
    inactive: 'text-gray-600',
    error: 'text-red-600'
  }[agent.status];

  return (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-3">
        <div>
          <h4 className="font-semibold">{agent.name}</h4>
          <p className="text-sm text-gray-600">{agent.type}</p>
        </div>
        <Badge className={statusColor}>
          {agent.status}
        </Badge>
      </div>
      
      <div className="space-y-2 text-sm">
        <div className="flex justify-between">
          <span>Actions réalisées:</span>
          <span>{agent.metrics.actionsPerformed}</span>
        </div>
        <div className="flex justify-between">
          <span>Taux de succès:</span>
          <span>{agent.metrics.successRate}%</span>
        </div>
        <div className="flex justify-between">
          <span>Dernière action:</span>
          <span>{formatDistanceToNow(agent.lastAction)}</span>
        </div>
      </div>
      
      <div className="flex gap-2 mt-4">
        <Button size="sm" variant="outline">Configurer</Button>
        <Button size="sm" variant="outline">Logs</Button>
      </div>
    </Card>
  );
};
```

## API Routes

```typescript
// src/app/api/ai/chat/route.ts
export async function POST(request: Request) {
  try {
    const { message, context } = await request.json();
    
    const response = await aiAgentService.generateConversationalResponse(message, context);
    
    return NextResponse.json(response);

  } catch (error) {
    console.error('AI chat failed:', error);
    return NextResponse.json(
      { error: 'Chat response failed' },
      { status: 500 }
    );
  }
}

// src/app/api/ai/agents/route.ts
export async function GET() {
  const agents = await aiAgentService.getAllAgents();
  
  return NextResponse.json({
    agents: agents.map(agent => ({
      id: agent.id,
      name: agent.name,
      type: agent.type,
      status: agent.status,
      metrics: agent.metrics,
      lastAction: agent.lastAction
    }))
  });
}

export async function POST(request: Request) {
  try {
    const agentConfig = await request.json();
    
    const agent = await aiAgentService.createAgent(agentConfig);
    
    return NextResponse.json({ agentId: agent.id });

  } catch (error) {
    console.error('Agent creation failed:', error);
    return NextResponse.json(
      { error: 'Agent creation failed' },
      { status: 500 }
    );
  }
}

// src/app/api/ai/mcp/tools/route.ts
export async function GET() {
  const tools = await mcpServer.getAvailableTools();
  
  return NextResponse.json({ tools });
}

export async function POST(request: Request) {
  try {
    const { toolName, arguments: args } = await request.json();
    
    const result = await mcpServer.executeTool(toolName, args);
    
    return NextResponse.json(result);

  } catch (error) {
    console.error('MCP tool execution failed:', error);
    return NextResponse.json(
      { error: 'Tool execution failed' },
      { status: 500 }
    );
  }
}
```

## Critères d'Acceptation Techniques

### Assistant Conversationnel
- [ ] Compréhension contextuelle > 90%
- [ ] Temps de réponse < 3s
- [ ] Support multimodal (texte, image, voix)
- [ ] Personnalisation selon historique utilisateur

### Agents Autonomes
- [ ] 5+ agents spécialisés fonctionnels
- [ ] Coordination sans conflits
- [ ] Apprentissage continu des patterns
- [ ] Monitoring temps réel des performances

### Intégration MCP
- [ ] 10+ outils MCP disponibles
- [ ] Protocole standard respecté
- [ ] Documentation auto-générée
- [ ] Compatibilité avec clients MCP tiers

## Couverture Exigences Architecture

- **EXG-005.1** : Architecture IA hybride avancée
- **EXG-005.2** : Agents autonomes et apprentissage
- **EXG-001.3** : Interface conversationnelle adaptative
- **EXG-007.1** : Temps réel pour agents
- **EXG-009.1** : Monitoring agents et performances IA

## Tests d'Acceptation

```typescript
// tests/integration/ai-advanced.test.ts
describe('Advanced AI Integration', () => {
  test('MCP server répond aux requêtes correctement', async () => {
    const result = await mcpServer.executeTool('analyze_garden_conditions', {
      gardenId: 'test-garden'
    });
    
    expect(result.content).toBeDefined();
    expect(result.isError).toBeFalsy();
  });

  test('agent autonome fonctionne correctement', async () => {
    const agent = await aiAgentService.createAgent({
      type: 'garden_monitor',
      config: { checkInterval: 1000 }
    });
    
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const metrics = await aiAgentService.getAgentMetrics(agent.id);
    expect(metrics.actionsPerformed).toBeGreaterThan(0);
  });

  test('conversation contextuelle maintient cohérence', async () => {
    const context = { gardenId: 'test', previousMessages: [] };
    
    const response1 = await aiAgentService.generateConversationalResponse(
      "Comment va mon jardin ?", context
    );
    
    const response2 = await aiAgentService.generateConversationalResponse(
      "Et mes tomates ?", { ...context, previousMessages: [response1] }
    );
    
    expect(response2.text).toContain('tomates');
    expect(response2.confidence).toBeGreaterThan(0.7);
  });
});
```

Cette spécification couvre un système d'IA avancé avec agents autonomes, serveur MCP et capacités conversationnelles pour une assistance intelligente et personnalisée en jardinage.