# F6.1 - Communauté & Partage

**Score Priorité :** 65/100  
**Statut :** PRIORITÉ FAIBLE  
**Epic :** EPIC 6 - COMMUNAUTÉ  
**Effort estimé :** 12 jours  

## Description

Plateforme communautaire intégrée pour le partage d'expériences, échange de conseils, collaboration entre jardiniers et création d'un réseau social spécialisé en jardinage avec système de réputation et marketplace local.

## User Stories

### US6.1.1 - Partage d'Expériences
**En tant qu'** expert jardinier  
**Je veux** partager mes réussites et difficultés avec d'autres jardiniers  
**Afin de** contribuer à la communauté et recevoir des retours  

**Critères d'acceptation :**
- Publication de posts avec photos et descriptions
- Tags par type de culture, région climatique, techniques
- Système de likes, commentaires et partages
- Historique des publications avec métriques d'engagement
- Export des données personnelles (RGPD)

### US6.1.2 - Réseau Local
**En tant qu'** utilisateur occasionnel  
**Je veux** me connecter avec des jardiniers près de chez moi  
**Afin d'** échanger localement et partager des ressources  

**Critères d'acceptation :**
- Découverte de jardiniers par géolocalisation
- Groupes locaux par ville/région
- Marketplace locale (échange graines, outils, surplus)
- Événements et rencontres communautaires
- Messagerie privée sécurisée

### US6.1.3 - Système de Réputation
**En tant qu'** membre de la communauté  
**Je veux** identifier les contributeurs experts et fiables  
**Afin de** valoriser les conseils de qualité  

**Critères d'acceptation :**
- Score de réputation basé sur contributions
- Badges d'expertise par domaine (bio, permaculture, etc.)
- Système de votes/évaluations des conseils
- Modération communautaire
- Reconnaissance des top contributeurs

## Architecture Technique

### Service Communauté

```typescript
// src/services/community/community.service.ts
export interface CommunityPost {
  id: string;
  authorId: string;
  type: PostType;
  title: string;
  content: string;
  images: string[];
  tags: string[];
  location?: GeoLocation;
  privacy: 'public' | 'community' | 'friends' | 'private';
  createdAt: Date;
  updatedAt: Date;
  metrics: PostMetrics;
  status: 'draft' | 'published' | 'archived' | 'reported';
}

export interface PostMetrics {
  views: number;
  likes: number;
  comments: number;
  shares: number;
  saves: number;
  reputationGained: number;
}

export type PostType = 
  | 'experience'      // Partage d'expérience
  | 'question'        // Question/demande d'aide
  | 'tip'            // Conseil/astuce
  | 'showcase'       // Présentation récolte/jardin
  | 'marketplace'    // Vente/échange
  | 'event'          // Événement communautaire
  | 'collaboration'; // Projet collaboratif

export interface CommunityMember {
  id: string;
  userId: string;
  displayName: string;
  bio: string;
  location: GeoLocation;
  reputation: ReputationProfile;
  expertise: ExpertiseArea[];
  joinedAt: Date;
  lastActive: Date;
  preferences: CommunityPreferences;
  verification: VerificationStatus;
}

export interface ReputationProfile {
  totalScore: number;
  level: ReputationLevel;
  breakdown: {
    helpfulness: number;
    expertise: number;
    engagement: number;
    reliability: number;
  };
  badges: Badge[];
  topContributions: CommunityPost[];
}

export type ReputationLevel = 
  | 'seedling'     // 0-100 points
  | 'sprout'       // 101-500 points
  | 'plant'        // 501-1500 points
  | 'gardener'     // 1501-5000 points
  | 'expert'       // 5001-15000 points
  | 'master';      // 15000+ points

export class CommunityService {
  private moderationService: ModerationService;
  private reputationService: ReputationService;
  private notificationService: NotificationService;

  constructor(
    private prisma: PrismaClient,
    private redis: Redis,
    private aiService: AIService
  ) {
    this.moderationService = new ModerationService();
    this.reputationService = new ReputationService();
    this.notificationService = new NotificationService();
  }

  async createPost(authorId: string, postData: CreatePostData): Promise<CommunityPost> {
    // Validation et nettoyage du contenu
    const sanitizedContent = await this.sanitizeContent(postData.content);
    
    // Modération automatique
    const moderationResult = await this.moderationService.moderateContent({
      content: sanitizedContent,
      images: postData.images,
      tags: postData.tags
    });

    if (moderationResult.requiresReview) {
      // Mise en queue pour modération humaine
      await this.queueForModeration(authorId, postData, moderationResult);
      throw new Error('Content requires moderation review');
    }

    // Auto-tagging avec IA
    const suggestedTags = await this.aiService.generateTags({
      content: sanitizedContent,
      images: postData.images,
      context: 'gardening'
    });

    const finalTags = [...new Set([...postData.tags, ...suggestedTags])];

    // Création du post
    const post = await this.prisma.communityPost.create({
      data: {
        authorId,
        type: postData.type,
        title: postData.title,
        content: sanitizedContent,
        images: postData.images,
        tags: finalTags,
        location: postData.location,
        privacy: postData.privacy || 'public',
        status: 'published',
        metrics: {
          views: 0,
          likes: 0,
          comments: 0,
          shares: 0,
          saves: 0,
          reputationGained: 0
        }
      }
    });

    // Indexation pour recherche
    await this.indexPostForSearch(post);

    // Notifications aux followers
    await this.notifyFollowers(authorId, post);

    // Gain initial de réputation
    await this.reputationService.awardPoints(authorId, 'post_created', 5);

    return this.mapToPost(post);
  }

  async discoverNearbyMembers(
    userId: string, 
    radius: number = 50 // km
  ): Promise<CommunityMember[]> {
    const userLocation = await this.getUserLocation(userId);
    if (!userLocation) return [];

    // Recherche géospatiale avec PostGIS
    const nearbyMembers = await this.prisma.$queryRaw`
      SELECT u.*, 
             ST_Distance(
               ST_Point(${userLocation.longitude}, ${userLocation.latitude})::geography,
               ST_Point(cm.longitude, cm.latitude)::geography
             ) / 1000 as distance_km
      FROM "CommunityMember" cm
      JOIN "User" u ON cm."userId" = u.id
      WHERE cm."userId" != ${userId}
        AND ST_DWithin(
          ST_Point(${userLocation.longitude}, ${userLocation.latitude})::geography,
          ST_Point(cm.longitude, cm.latitude)::geography,
          ${radius * 1000}
        )
      ORDER BY distance_km ASC
      LIMIT 50
    `;

    return nearbyMembers.map(member => this.mapToCommunityMember(member));
  }

  async searchPosts(query: SearchQuery): Promise<SearchResult<CommunityPost>> {
    const {
      text,
      tags,
      type,
      location,
      radius,
      authorId,
      dateRange,
      sortBy = 'relevance',
      page = 1,
      limit = 20
    } = query;

    // Construction de la requête Elasticsearch/PostreSQL
    let whereClause = {
      status: 'published',
      privacy: 'public'
    };

    // Filtres
    if (text) {
      whereClause = {
        ...whereClause,
        OR: [
          { title: { contains: text, mode: 'insensitive' } },
          { content: { contains: text, mode: 'insensitive' } },
          { tags: { hasSome: text.split(' ') } }
        ]
      };
    }

    if (tags?.length > 0) {
      whereClause = {
        ...whereClause,
        tags: { hassome: tags }
      };
    }

    if (type) {
      whereClause = { ...whereClause, type };
    }

    if (authorId) {
      whereClause = { ...whereClause, authorId };
    }

    if (dateRange) {
      whereClause = {
        ...whereClause,
        createdAt: {
          gte: dateRange.start,
          lte: dateRange.end
        }
      };
    }

    // Tri
    let orderBy;
    switch (sortBy) {
      case 'recent':
        orderBy = { createdAt: 'desc' };
        break;
      case 'popular':
        orderBy = { metrics: { likes: 'desc' } };
        break;
      case 'trending':
        orderBy = { metrics: { reputationGained: 'desc' } };
        break;
      default:
        orderBy = { createdAt: 'desc' };
    }

    // Exécution de la requête
    const [posts, total] = await Promise.all([
      this.prisma.communityPost.findMany({
        where: whereClause,
        orderBy,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          author: {
            select: {
              id: true,
              name: true,
              image: true,
              reputation: true
            }
          },
          _count: {
            select: {
              comments: true,
              likes: true
            }
          }
        }
      }),
      this.prisma.communityPost.count({ where: whereClause })
    ]);

    return {
      items: posts.map(post => this.mapToPost(post)),
      total,
      page,
      limit,
      hasNext: page * limit < total
    };
  }

  async likePost(userId: string, postId: string): Promise<void> {
    // Vérification si déjà liké
    const existingLike = await this.prisma.postLike.findUnique({
      where: {
        userId_postId: { userId, postId }
      }
    });

    if (existingLike) {
      // Retirer le like
      await this.prisma.postLike.delete({
        where: { id: existingLike.id }
      });

      await this.updatePostMetrics(postId, { likes: -1 });
      await this.reputationService.awardPoints(userId, 'like_removed', -1);
    } else {
      // Ajouter le like
      await this.prisma.postLike.create({
        data: { userId, postId }
      });

      await this.updatePostMetrics(postId, { likes: 1 });
      
      // Points pour l'auteur du post
      const post = await this.prisma.communityPost.findUnique({
        where: { id: postId }
      });
      
      if (post && post.authorId !== userId) {
        await this.reputationService.awardPoints(post.authorId, 'post_liked', 2);
        
        // Notification à l'auteur
        await this.notificationService.create({
          userId: post.authorId,
          type: 'post_liked',
          message: `Votre publication a été aimée`,
          data: { postId, likerId: userId }
        });
      }
    }
  }

  async commentOnPost(
    userId: string, 
    postId: string, 
    content: string,
    parentCommentId?: string
  ): Promise<Comment> {
    // Modération du commentaire
    const moderationResult = await this.moderationService.moderateContent({
      content,
      context: 'comment'
    });

    if (moderationResult.requiresReview) {
      throw new Error('Comment requires moderation review');
    }

    // Création du commentaire
    const comment = await this.prisma.comment.create({
      data: {
        authorId: userId,
        postId,
        parentId: parentCommentId,
        content,
        status: 'published'
      },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            image: true,
            reputation: true
          }
        }
      }
    });

    // Mise à jour métriques
    await this.updatePostMetrics(postId, { comments: 1 });

    // Points de réputation
    await this.reputationService.awardPoints(userId, 'comment_created', 3);

    // Notification à l'auteur du post
    const post = await this.prisma.communityPost.findUnique({
      where: { id: postId }
    });

    if (post && post.authorId !== userId) {
      await this.notificationService.create({
        userId: post.authorId,
        type: 'post_commented',
        message: `Nouveau commentaire sur votre publication`,
        data: { postId, commentId: comment.id, commenterId: userId }
      });
    }

    return this.mapToComment(comment);
  }

  async createLocalGroup(
    creatorId: string,
    groupData: CreateGroupData
  ): Promise<LocalGroup> {
    const group = await this.prisma.localGroup.create({
      data: {
        name: groupData.name,
        description: groupData.description,
        location: groupData.location,
        radius: groupData.radius,
        creatorId,
        privacy: groupData.privacy || 'public',
        rules: groupData.rules || [],
        maxMembers: groupData.maxMembers || 100
      }
    });

    // Auto-adhésion du créateur comme admin
    await this.prisma.groupMembership.create({
      data: {
        userId: creatorId,
        groupId: group.id,
        role: 'admin',
        status: 'active'
      }
    });

    // Points de réputation pour création de groupe
    await this.reputationService.awardPoints(creatorId, 'group_created', 20);

    return this.mapToLocalGroup(group);
  }

  async createMarketplaceListing(
    sellerId: string,
    listingData: CreateListingData
  ): Promise<MarketplaceListing> {
    const listing = await this.prisma.marketplaceListing.create({
      data: {
        sellerId,
        type: listingData.type,
        title: listingData.title,
        description: listingData.description,
        category: listingData.category,
        images: listingData.images,
        price: listingData.price,
        currency: listingData.currency || 'EUR',
        location: listingData.location,
        availableQuantity: listingData.quantity,
        condition: listingData.condition,
        tags: listingData.tags,
        expiresAt: listingData.expiresAt,
        status: 'active'
      }
    });

    // Indexation pour recherche
    await this.indexListingForSearch(listing);

    // Notification aux membres intéressés de la région
    await this.notifyInterestedMembers(listing);

    return this.mapToMarketplaceListing(listing);
  }
}
```

### Service de Réputation

```typescript
// src/services/community/reputation.service.ts
export class ReputationService {
  private readonly POINT_VALUES = {
    // Actions de base
    post_created: 5,
    comment_created: 3,
    post_liked: 2,
    comment_liked: 1,
    post_shared: 3,
    
    // Actions expertes
    solution_accepted: 15,
    expertise_verified: 25,
    helpful_vote: 10,
    
    // Contributions communautaires
    group_created: 20,
    event_organized: 30,
    tutorial_created: 40,
    
    // Modération communautaire
    content_moderated: 8,
    spam_reported: 5,
    
    // Pénalités
    content_removed: -10,
    warning_received: -20,
    spam_posted: -50
  };

  private readonly LEVEL_THRESHOLDS = {
    seedling: 0,
    sprout: 100,
    plant: 500,
    gardener: 1500,
    expert: 5000,
    master: 15000
  };

  constructor(
    private prisma: PrismaClient,
    private badgeService: BadgeService
  ) {}

  async awardPoints(
    userId: string, 
    action: keyof typeof this.POINT_VALUES, 
    multiplier: number = 1
  ): Promise<ReputationUpdate> {
    const points = this.POINT_VALUES[action] * multiplier;
    
    // Récupération profil actuel
    const currentProfile = await this.getReputationProfile(userId);
    const newTotalScore = currentProfile.totalScore + points;
    
    // Calcul nouveau niveau
    const newLevel = this.calculateLevel(newTotalScore);
    const levelChanged = newLevel !== currentProfile.level;
    
    // Mise à jour en base
    const updatedProfile = await this.prisma.reputationProfile.upsert({
      where: { userId },
      update: {
        totalScore: newTotalScore,
        level: newLevel,
        lastActivity: new Date()
      },
      create: {
        userId,
        totalScore: Math.max(0, newTotalScore),
        level: newLevel,
        breakdown: {
          helpfulness: 0,
          expertise: 0,
          engagement: 0,
          reliability: 0
        }
      }
    });

    // Ajout historique
    await this.prisma.reputationHistory.create({
      data: {
        userId,
        action,
        points,
        totalAfter: newTotalScore,
        reason: `Points for ${action}`
      }
    });

    // Gestion changement de niveau
    let newBadges: Badge[] = [];
    if (levelChanged) {
      newBadges = await this.handleLevelUp(userId, newLevel);
    }

    // Vérification badges d'expertise
    const expertiseBadges = await this.checkExpertiseBadges(userId, action);
    newBadges.push(...expertiseBadges);

    return {
      pointsAwarded: points,
      newTotalScore,
      previousLevel: currentProfile.level,
      newLevel,
      levelChanged,
      newBadges
    };
  }

  private calculateLevel(totalScore: number): ReputationLevel {
    for (const [level, threshold] of Object.entries(this.LEVEL_THRESHOLDS).reverse()) {
      if (totalScore >= threshold) {
        return level as ReputationLevel;
      }
    }
    return 'seedling';
  }

  private async handleLevelUp(userId: string, newLevel: ReputationLevel): Promise<Badge[]> {
    const levelBadge = await this.badgeService.awardBadge(userId, {
      type: 'level',
      level: newLevel,
      name: `${newLevel.charAt(0).toUpperCase() + newLevel.slice(1)} Gardener`,
      description: `Atteint le niveau ${newLevel}`,
      icon: this.getLevelIcon(newLevel)
    });

    // Notification de level up
    await this.notificationService.create({
      userId,
      type: 'level_up',
      message: `Félicitations ! Vous êtes maintenant niveau ${newLevel}`,
      data: { newLevel, badge: levelBadge }
    });

    return [levelBadge];
  }

  private async checkExpertiseBadges(userId: string, action: string): Promise<Badge[]> {
    const badges: Badge[] = [];
    
    // Badge "Helper" - 50 réponses utiles
    if (action === 'solution_accepted') {
      const solutionCount = await this.prisma.reputationHistory.count({
        where: {
          userId,
          action: 'solution_accepted'
        }
      });

      if (solutionCount === 50) {
        const badge = await this.badgeService.awardBadge(userId, {
          type: 'expertise',
          name: 'Helper',
          description: '50 solutions acceptées',
          icon: '🤝'
        });
        badges.push(badge);
      }
    }

    // Badge "Educator" - 10 tutoriels
    if (action === 'tutorial_created') {
      const tutorialCount = await this.prisma.reputationHistory.count({
        where: {
          userId,
          action: 'tutorial_created'
        }
      });

      if (tutorialCount === 10) {
        const badge = await this.badgeService.awardBadge(userId, {
          type: 'expertise',
          name: 'Educator',
          description: '10 tutoriels créés',
          icon: '📚'
        });
        badges.push(badge);
      }
    }

    return badges;
  }

  async getLeaderboard(
    type: 'global' | 'local' | 'category' = 'global',
    limit: number = 10,
    period?: 'week' | 'month' | 'year'
  ): Promise<LeaderboardEntry[]> {
    let whereClause = {};
    
    if (period) {
      const periodStart = this.getPeriodStart(period);
      whereClause = {
        lastActivity: {
          gte: periodStart
        }
      };
    }

    const profiles = await this.prisma.reputationProfile.findMany({
      where: whereClause,
      orderBy: {
        totalScore: 'desc'
      },
      take: limit,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            image: true
          }
        },
        badges: {
          take: 3,
          orderBy: {
            awardedAt: 'desc'
          }
        }
      }
    });

    return profiles.map((profile, index) => ({
      rank: index + 1,
      user: profile.user,
      reputation: profile.totalScore,
      level: profile.level,
      badges: profile.badges,
      trend: this.calculateTrend(profile.userId, period)
    }));
  }
}
```

### Interface Communauté

```typescript
// src/app/community/page.tsx
export default function CommunityPage() {
  const [activeTab, setActiveTab] = useState<'feed' | 'groups' | 'marketplace' | 'leaderboard'>('feed');
  const [posts, setPosts] = useState<CommunityPost[]>([]);
  const [loading, setLoading] = useState(false);

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-6">
        <div className="max-w-6xl mx-auto">
          {/* Header */}
          <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
            <div className="flex justify-between items-center mb-4">
              <div>
                <h1 className="text-2xl font-bold">Communauté Jardiniers</h1>
                <p className="text-gray-600">
                  Partagez, apprenez et grandissez ensemble
                </p>
              </div>
              
              <Button>
                <PlusIcon className="w-4 h-4 mr-2" />
                Créer un Post
              </Button>
            </div>

            {/* Navigation tabs */}
            <div className="flex space-x-1 bg-gray-100 rounded-lg p-1">
              {[
                { id: 'feed', label: 'Fil d\'actualité', icon: '📰' },
                { id: 'groups', label: 'Groupes Locaux', icon: '👥' },
                { id: 'marketplace', label: 'Marketplace', icon: '🛒' },
                { id: 'leaderboard', label: 'Classement', icon: '🏆' }
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id as any)}
                  className={`flex-1 flex items-center justify-center px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                    activeTab === tab.id
                      ? 'bg-white text-green-700 shadow-sm'
                      : 'text-gray-600 hover:text-gray-900'
                  }`}
                >
                  <span className="mr-2">{tab.icon}</span>
                  {tab.label}
                </button>
              ))}
            </div>
          </div>

          <div className="grid grid-cols-12 gap-6">
            {/* Sidebar */}
            <div className="col-span-3">
              <CommunitySidebar />
            </div>

            {/* Main content */}
            <div className="col-span-6">
              {activeTab === 'feed' && <CommunityFeed />}
              {activeTab === 'groups' && <LocalGroupsSection />}
              {activeTab === 'marketplace' && <MarketplaceSection />}
              {activeTab === 'leaderboard' && <LeaderboardSection />}
            </div>

            {/* Right sidebar */}
            <div className="col-span-3">
              <CommunityRightSidebar />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

const CommunityFeed = () => {
  const { posts, loading, hasMore, loadMore } = useCommunityFeed();

  return (
    <div className="space-y-4">
      {/* Créer un post */}
      <Card className="p-4">
        <CreatePostQuickForm />
      </Card>

      {/* Posts */}
      {posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}

      {hasMore && (
        <div className="text-center">
          <Button 
            variant="outline" 
            onClick={loadMore}
            disabled={loading}
          >
            {loading ? 'Chargement...' : 'Voir plus'}
          </Button>
        </div>
      )}
    </div>
  );
};

const PostCard = ({ post }: { post: CommunityPost }) => {
  const [liked, setLiked] = useState(false);
  const [showComments, setShowComments] = useState(false);

  return (
    <Card className="overflow-hidden">
      {/* Header */}
      <div className="p-4 border-b">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <Avatar className="h-10 w-10">
              <AvatarImage src={post.author.image} />
              <AvatarFallback>{post.author.name[0]}</AvatarFallback>
            </Avatar>
            <div>
              <div className="flex items-center space-x-2">
                <span className="font-semibold">{post.author.name}</span>
                <ReputationBadge level={post.author.reputation.level} />
              </div>
              <div className="flex items-center space-x-2 text-sm text-gray-500">
                <span>{formatDistanceToNow(post.createdAt)}</span>
                {post.location && (
                  <>
                    <span>•</span>
                    <span>📍 {post.location.city}</span>
                  </>
                )}
              </div>
            </div>
          </div>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm">
                <MoreHorizontalIcon className="w-4 h-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              <DropdownMenuItem>Sauvegarder</DropdownMenuItem>
              <DropdownMenuItem>Signaler</DropdownMenuItem>
              <DropdownMenuItem>Partager</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      {/* Content */}
      <div className="p-4">
        <h3 className="font-semibold mb-2">{post.title}</h3>
        <p className="text-gray-700 mb-3">{post.content}</p>
        
        {/* Tags */}
        {post.tags.length > 0 && (
          <div className="flex flex-wrap gap-1 mb-3">
            {post.tags.map(tag => (
              <Badge key={tag} variant="secondary" className="text-xs">
                #{tag}
              </Badge>
            ))}
          </div>
        )}

        {/* Images */}
        {post.images.length > 0 && (
          <div className="grid grid-cols-2 gap-2 mb-3">
            {post.images.slice(0, 4).map((image, index) => (
              <div key={index} className="aspect-square rounded overflow-hidden">
                <img 
                  src={image} 
                  alt={`Post image ${index + 1}`}
                  className="w-full h-full object-cover hover:scale-105 transition-transform cursor-pointer"
                />
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Actions */}
      <div className="px-4 py-3 border-t bg-gray-50">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <button
              onClick={() => setLiked(!liked)}
              className={`flex items-center space-x-1 ${
                liked ? 'text-red-500' : 'text-gray-600'
              }`}
            >
              <HeartIcon className={`w-5 h-5 ${liked ? 'fill-current' : ''}`} />
              <span className="text-sm">{post.metrics.likes}</span>
            </button>
            
            <button
              onClick={() => setShowComments(!showComments)}
              className="flex items-center space-x-1 text-gray-600"
            >
              <MessageCircleIcon className="w-5 h-5" />
              <span className="text-sm">{post.metrics.comments}</span>
            </button>
            
            <button className="flex items-center space-x-1 text-gray-600">
              <ShareIcon className="w-5 h-5" />
              <span className="text-sm">{post.metrics.shares}</span>
            </button>
          </div>
          
          <div className="text-xs text-gray-500">
            {post.metrics.views} vues
          </div>
        </div>
      </div>

      {/* Comments */}
      {showComments && (
        <div className="border-t">
          <CommentsSection postId={post.id} />
        </div>
      )}
    </Card>
  );
};

const CommunitySidebar = () => {
  const { reputation } = useUserReputation();
  const { nearbyMembers } = useNearbyMembers();

  return (
    <div className="space-y-4">
      {/* Profil utilisateur */}
      <Card className="p-4">
        <div className="text-center">
          <Avatar className="h-16 w-16 mx-auto mb-3">
            <AvatarImage src="/api/user/avatar" />
            <AvatarFallback>U</AvatarFallback>
          </Avatar>
          <h3 className="font-semibold">Mon Profil</h3>
          <div className="mt-2">
            <ReputationBadge level={reputation.level} />
            <div className="text-sm text-gray-600 mt-1">
              {reputation.totalScore} points
            </div>
          </div>
        </div>
      </Card>

      {/* Membres à proximité */}
      <Card className="p-4">
        <h3 className="font-semibold mb-3">Jardiniers Près de Chez Vous</h3>
        <div className="space-y-2">
          {nearbyMembers.slice(0, 5).map(member => (
            <div key={member.id} className="flex items-center space-x-2">
              <Avatar className="h-8 w-8">
                <AvatarImage src={member.avatar} />
                <AvatarFallback>{member.name[0]}</AvatarFallback>
              </Avatar>
              <div className="flex-1 min-w-0">
                <div className="text-sm font-medium truncate">{member.name}</div>
                <div className="text-xs text-gray-500">{member.distance}km</div>
              </div>
            </div>
          ))}
        </div>
        <Button variant="outline" size="sm" className="w-full mt-3">
          Voir tous
        </Button>
      </Card>

      {/* Groupes suggérés */}
      <Card className="p-4">
        <h3 className="font-semibold mb-3">Groupes Suggérés</h3>
        <SuggestedGroups />
      </Card>
    </div>
  );
};
```

## API Routes

```typescript
// src/app/api/community/posts/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '10');
  const type = searchParams.get('type');
  const tags = searchParams.get('tags')?.split(',');

  const result = await communityService.searchPosts({
    type: type as PostType,
    tags,
    page,
    limit,
    sortBy: 'recent'
  });

  return NextResponse.json(result);
}

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const postData = await request.json();
    
    const post = await communityService.createPost(session.user.id, postData);

    return NextResponse.json({ postId: post.id });

  } catch (error) {
    console.error('Post creation failed:', error);
    return NextResponse.json(
      { error: 'Post creation failed' },
      { status: 500 }
    );
  }
}

// src/app/api/community/posts/[postId]/like/route.ts
export async function POST(
  request: Request,
  { params }: { params: { postId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    await communityService.likePost(session.user.id, params.postId);

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('Like failed:', error);
    return NextResponse.json(
      { error: 'Like failed' },
      { status: 500 }
    );
  }
}

// src/app/api/community/marketplace/route.ts
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const listingData = await request.json();
    
    const listing = await communityService.createMarketplaceListing(
      session.user.id, 
      listingData
    );

    return NextResponse.json({ listingId: listing.id });

  } catch (error) {
    console.error('Listing creation failed:', error);
    return NextResponse.json(
      { error: 'Listing creation failed' },
      { status: 500 }
    );
  }
}

// src/app/api/community/reputation/leaderboard/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const type = searchParams.get('type') || 'global';
  const period = searchParams.get('period');
  const limit = parseInt(searchParams.get('limit') || '10');

  const leaderboard = await reputationService.getLeaderboard(
    type as 'global' | 'local' | 'category',
    limit,
    period as 'week' | 'month' | 'year'
  );

  return NextResponse.json({ leaderboard });
}
```

## Critères d'Acceptation Techniques

### Engagement Communautaire
- [ ] Système de posts avec rich media (texte, images, tags)
- [ ] Interactions sociales (likes, commentaires, partages)
- [ ] Découverte géolocalisée des membres
- [ ] Groupes locaux avec gestion de membres

### Système de Réputation
- [ ] Attribution automatique de points selon actions
- [ ] Niveaux de réputation avec badges
- [ ] Classements périodiques (global, local, catégorie)
- [ ] Modération communautaire

### Marketplace Locale
- [ ] Annonces d'échange/vente avec photos
- [ ] Filtrage géographique et par catégorie
- [ ] Système de messages privés sécurisé
- [ ] Évaluations/avis sur les échanges

## Couverture Exigences Architecture

- **EXG-002.1** : Base de données sociale optimisée
- **EXG-003.1** : Interface responsive communautaire
- **EXG-007.1** : Notifications temps réel
- **EXG-008.1** : Authentification pour contenu social
- **EXG-009.1** : Métriques d'engagement communautaire

## Tests d'Acceptation

```typescript
// tests/integration/community.test.ts
describe('Community Platform', () => {
  test('création et publication de post fonctionne', async () => {
    const postData = createTestPostData();
    
    const post = await communityService.createPost('user-1', postData);
    
    expect(post.id).toBeDefined();
    expect(post.status).toBe('published');
    expect(post.metrics.views).toBe(0);
  });

  test('système de likes fonctionne', async () => {
    const post = await createTestPost();
    
    await communityService.likePost('user-2', post.id);
    
    const updatedPost = await communityService.getPost(post.id);
    expect(updatedPost.metrics.likes).toBe(1);
  });

  test('découverte géolocalisée fonctionne', async () => {
    const members = await communityService.discoverNearbyMembers('user-1', 50);
    
    expect(members).toHaveLength(greaterThan(0));
    expect(members[0].distance).toBeLessThan(50);
  });

  test('système de réputation attribue points correctement', async () => {
    const initialReputation = await reputationService.getReputationProfile('user-1');
    
    await reputationService.awardPoints('user-1', 'post_created');
    
    const updatedReputation = await reputationService.getReputationProfile('user-1');
    expect(updatedReputation.totalScore).toBe(initialReputation.totalScore + 5);
  });
});
```

Cette spécification couvre une plateforme communautaire complète avec partage d'expériences, système de réputation, groupes locaux et marketplace pour créer un écosystème social autour du jardinage.