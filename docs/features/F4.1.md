# **F4.1 - Int√©gration WeatherAPI & Pr√©visions**

## **üìã Informations g√©n√©rales**
- **Score de priorit√©** : 90/100 ‚≠ê PRIORIT√â MAXIMALE
- **EPIC** : INTELLIGENCE M√âT√âO & ALERTES
- **Complexit√©** : Moyenne (API integration + cache)
- **Devices** : üì±üíªüì∫

## **üéØ Description**
Int√©gration WeatherAPI pour fournir donn√©es m√©t√©orologiques temps r√©el avec pr√©visions 10 jours g√©olocalis√©es, incluant indicateurs sp√©cifiques jardinage (gel, canicule, pluviom√©trie) et enrichissement automatique des donn√©es culturales avec contexte m√©t√©orologique.

## **üë• User Stories**

### **Planification intelligente**
- En tant que jardinier, je veux des pr√©visions pr√©cises pour planifier mes interventions optimales
- En tant qu'utilisateur, je veux des donn√©es m√©t√©o contextualis√©es pour mon potager sp√©cifiquement

### **Pr√©vention des risques**
- En tant qu'utilisateur, je veux √™tre alert√© des risques climatiques (gel, canicule) avec anticipation
- En tant que syst√®me, je veux enrichir automatiquement les donn√©es avec le contexte m√©t√©orologique

### **Multi-device exp√©rience**
- En tant qu'utilisateur mobile, je veux la m√©t√©o du jour avec recommandations jardinage
- En tant qu'utilisateur TV, je veux des pr√©visions visuelles immersives

## **üå§Ô∏è Architecture WeatherAPI**

### **Service d'int√©gration m√©t√©orologique**
```typescript
export class WeatherIntegrationService {
  private weatherAPI: WeatherAPI;
  private cache: WeatherCache;
  private geocoding: GeocodingService;
  
  constructor() {
    this.weatherAPI = new WeatherAPI({
      apiKey: process.env.WEATHER_API_KEY,
      baseURL: 'https://api.weatherapi.com/v1'
    });
    this.cache = new WeatherCache(redis);
    this.geocoding = new GeocodingService();
  }

  async getCurrentWeather(jardin: Jardin): Promise<CurrentWeather> {
    const cacheKey = `weather:current:${jardin.id}`;
    
    // 1. Check cache (5 min TTL pour donn√©es actuelles)
    const cached = await this.cache.get(cacheKey);
    if (cached && !this.isExpired(cached, 5 * 60)) {
      return cached;
    }

    // 2. R√©cup√©rer coordonn√©es pr√©cises du jardin
    const coordinates = this.extractCoordinates(jardin.localisation);
    
    // 3. Appel WeatherAPI
    const response = await this.weatherAPI.current({
      q: `${coordinates.latitude},${coordinates.longitude}`,
      aqi: 'yes', // Qualit√© de l'air
      alerts: 'yes' // Alertes m√©t√©o
    });

    // 4. Transformation en format Ba≈°-Malin
    const weather = this.transformCurrentWeather(response, jardin);
    
    // 5. Cache avec TTL
    await this.cache.set(cacheKey, weather, 5 * 60);
    
    // 6. Persistence en base pour historique
    await this.saveWeatherData(weather, jardin.id);
    
    return weather;
  }

  async getForecast(jardin: Jardin, days: number = 10): Promise<WeatherForecast[]> {
    const cacheKey = `weather:forecast:${jardin.id}:${days}d`;
    
    // Cache plus long pour pr√©visions (6h TTL)
    const cached = await this.cache.get(cacheKey);
    if (cached && !this.isExpired(cached, 6 * 60 * 60)) {
      return cached;
    }

    const coordinates = this.extractCoordinates(jardin.localisation);
    
    const response = await this.weatherAPI.forecast({
      q: `${coordinates.latitude},${coordinates.longitude}`,
      days: Math.min(days, 10), // Max 10 jours
      aqi: 'yes',
      alerts: 'yes',
      tp: 1 // Donn√©es horaires
    });

    const forecasts = this.transformForecast(response, jardin);
    
    await this.cache.set(cacheKey, forecasts, 6 * 60 * 60);
    await this.saveForecastData(forecasts, jardin.id);
    
    return forecasts;
  }

  private transformCurrentWeather(apiResponse: any, jardin: Jardin): CurrentWeather {
    const current = apiResponse.current;
    const location = apiResponse.location;
    
    return {
      jardinId: jardin.id,
      timestamp: new Date(current.last_updated),
      source: 'WeatherAPI',
      
      // Donn√©es de base
      temperatureC: current.temp_c,
      temperatureRessentieC: current.feelslike_c,
      humiditePourcent: current.humidity,
      pressionHpa: current.pressure_mb,
      
      // Vent
      vitesseVentKmh: current.wind_kph,
      directionVentDegres: current.wind_degree,
      rafalesVentKmh: current.gust_kph,
      
      // Pr√©cipitations
      precipitationMm: current.precip_mm,
      
      // Ensoleillement
      indiceUV: current.uv,
      visibiliteKm: current.vis_km,
      couvertureNuageusePourcent: current.cloud,
      
      // Conditions
      conditionMeteo: current.condition.text,
      codeCondition: current.condition.code,
      estJour: current.is_day === 1,
      
      // Donn√©es jardinage sp√©cifiques
      indicateursJardinage: this.calculateGardeningIndicators(current, location),
      
      // Alertes
      alertesActives: this.extractAlerts(apiResponse.alerts?.alert || [])
    };
  }

  private calculateGardeningIndicators(current: any, location: any): GardeningIndicators {
    return {
      // Risque de gel (< 3¬∞C = attention, < 0¬∞C = gel)
      risqueGel: {
        niveau: current.temp_c < 0 ? 'ELEVE' : 
                current.temp_c < 3 ? 'MOYEN' : 'FAIBLE',
        temperatureMin: current.temp_c,
        heureRisqueMax: this.predictFrostTime(current, location)
      },
      
      // Conditions d'arrosage
      conditionsArrosage: {
        recommande: this.shouldWater(current),
        raisonnement: this.getWateringReason(current),
        prochainePluiePrevue: null // √Ä calculer avec forecast
      },
      
      // Travail au jardin
      conditionsTravail: {
        favorable: this.isGoodWorkingWeather(current),
        score: this.calculateWorkingScore(current), // 0-10
        limitationsPrincipales: this.getWorkingLimitations(current)
      },
      
      // √âvapotranspiration (besoin en eau des plantes)
      evapotranspiration: {
        et0: this.calculateET0(current), // mm/jour
        categorieBesoins: this.categorizeWaterNeeds(current)
      },
      
      // Indice de croissance (conditions optimales croissance)
      indiceCroissance: {
        score: this.calculateGrowthIndex(current), // 0-100
        facteursLimitants: this.getGrowthLimitingFactors(current)
      }
    };
  }

  private shouldWater(current: any): boolean {
    // Pas d'arrosage si pluie dans les 6h
    if (current.precip_mm > 5) return false;
    
    // Arrosage recommand√© si sec + chaud
    return current.humidity < 60 && current.temp_c > 20;
  }

  private isGoodWorkingWeather(current: any): boolean {
    return (
      current.precip_mm < 1 &&  // Pas de pluie
      current.wind_kph < 25 &&  // Vent mod√©r√©
      current.temp_c > 5 &&     // Pas trop froid
      current.temp_c < 35       // Pas trop chaud
    );
  }

  private calculateWorkingScore(current: any): number {
    let score = 10;
    
    // P√©nalit√©s
    if (current.precip_mm > 0) score -= 3;
    if (current.wind_kph > 20) score -= 2;
    if (current.temp_c < 10) score -= 2;
    if (current.temp_c > 30) score -= 2;
    if (current.humidity > 90) score -= 1;
    
    return Math.max(0, score);
  }
}

interface CurrentWeather {
  jardinId: string;
  timestamp: Date;
  source: 'WeatherAPI' | 'ESP32' | 'Manuel';
  
  // Donn√©es m√©t√©o standard
  temperatureC: number;
  temperatureRessentieC: number;
  humiditePourcent: number;
  pressionHpa: number;
  vitesseVentKmh: number;
  directionVentDegres: number;
  precipitationMm: number;
  indiceUV: number;
  conditionMeteo: string;
  
  // Indicateurs jardinage
  indicateursJardinage: GardeningIndicators;
  alertesActives: WeatherAlert[];
}

interface GardeningIndicators {
  risqueGel: {
    niveau: 'FAIBLE' | 'MOYEN' | 'ELEVE';
    temperatureMin: number;
    heureRisqueMax: string;
  };
  conditionsArrosage: {
    recommande: boolean;
    raisonnement: string;
    prochainePluiePrevue: Date | null;
  };
  conditionsTravail: {
    favorable: boolean;
    score: number; // 0-10
    limitationsPrincipales: string[];
  };
  evapotranspiration: {
    et0: number; // mm/jour
    categorieBesoins: 'FAIBLE' | 'MOYEN' | 'ELEVE';
  };
  indiceCroissance: {
    score: number; // 0-100
    facteursLimitants: string[];
  };
}
```

### **Cache intelligent et optimisation co√ªts**
```typescript
export class WeatherCache {
  private redis: Redis;
  
  constructor(redisInstance: Redis) {
    this.redis = redisInstance;
  }

  async get(key: string): Promise<any> {
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  async set(key: string, data: any, ttlSeconds: number): Promise<void> {
    await this.redis.setex(key, ttlSeconds, JSON.stringify({
      data,
      cachedAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + ttlSeconds * 1000).toISOString()
    }));
  }

  // Cache g√©ographique intelligent
  async getNearbyWeather(coordinates: Coordinates, radiusKm: number = 5): Promise<any> {
    // Recherche dans cache des donn√©es m√©t√©o proches g√©ographiquement
    const nearbyKeys = await this.redis.keys(`weather:current:*`);
    
    for (const key of nearbyKeys) {
      const cached = await this.get(key);
      if (!cached) continue;
      
      const cachedCoords = this.extractCoordsFromData(cached.data);
      const distance = this.calculateDistance(coordinates, cachedCoords);
      
      if (distance <= radiusKm) {
        // R√©utiliser donn√©es proches si r√©centes
        return cached.data;
      }
    }
    
    return null;
  }

  private calculateDistance(coord1: Coordinates, coord2: Coordinates): number {
    const R = 6371; // Rayon terre en km
    const dLat = this.deg2rad(coord2.latitude - coord1.latitude);
    const dLon = this.deg2rad(coord2.longitude - coord1.longitude);
    
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(this.deg2rad(coord1.latitude)) * Math.cos(this.deg2rad(coord2.latitude)) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
}

// Monitoring des co√ªts API
export class WeatherAPIUsageMonitor {
  private usage: Map<string, number> = new Map();
  
  async recordAPICall(endpoint: string, cost: number = 1): Promise<void> {
    const today = format(new Date(), 'yyyy-MM-dd');
    const key = `${today}:${endpoint}`;
    
    this.usage.set(key, (this.usage.get(key) || 0) + cost);
    
    // Persistance en Redis pour suivi multi-instance
    await redis.incr(`weather_api_usage:${key}`);
    
    // Alerte si d√©passement budget
    const dailyUsage = await this.getDailyUsage();
    if (dailyUsage > this.getDailyBudget()) {
      await this.sendBudgetAlert(dailyUsage);
    }
  }

  private getDailyBudget(): number {
    // Budget bas√© sur plan WeatherAPI (ex: 1M calls/mois = ~33k/jour)
    return parseInt(process.env.WEATHER_API_DAILY_LIMIT || '33000');
  }
}
```

## **üíæ Mod√®le de donn√©es (selon data_models_bas_malin.md)**

### **Stockage donn√©es m√©t√©orologiques**
```prisma
model DonneeMeteo {
  id                      String @id @default(cuid())
  jardinId                String
  
  // Timestamp et source
  enregistreA             DateTime
  sourceDonnees           SourceDonneesMeteo
  fournisseurSource       String // "WeatherAPI", "ESP32-01"
  
  // Donn√©es m√©t√©orologiques
  temperatureC            Decimal? @db.Decimal(4,1)
  temperatureRessentieC   Decimal? @db.Decimal(4,1)
  humiditePourcent        Int?
  pressionHpa             Decimal? @db.Decimal(6,1)
  vitesseVentKmh          Decimal? @db.Decimal(4,1)
  directionVentDegres     Int?
  rafalesVentKmh          Decimal? @db.Decimal(4,1)
  precipitationMm         Decimal? @db.Decimal(6,2)
  indiceUV                Decimal? @db.Decimal(3,1)
  
  // Conditions
  conditionMeteo          String?
  codeCondition           Int? // Code WeatherAPI
  visibiliteKm            Decimal? @db.Decimal(4,1)
  couvertureNuageusePourcent Int?
  estJour                 Boolean?
  
  // Pr√©visions (si applicable)
  estPrevision            Boolean @default(false)
  horizonPrevisionHeures  Int?
  scoreConfiance          Decimal? @db.Decimal(3,2)
  
  // Indicateurs jardinage calcul√©s
  indicateursJardinage    Json? // GardeningIndicators
  
  // Alertes m√©t√©o associ√©es
  alertesDetectees        Json? // WeatherAlert[]
  
  // Relations
  jardin Jardin @relation(fields: [jardinId], references: [id])
  
  @@map("donnees_meteo")
  
  // Index pour performance queries temporelles
  @@index([jardinId, enregistreA])
  @@index([sourceDonnees, enregistreA])
}

enum SourceDonneesMeteo {
  API
  CAPTEUR
  MANUEL
}

// Table des alertes m√©t√©o g√©n√©r√©es
model AlerteMeteoGeneree {
  id                  String @id @default(cuid())
  jardinId            String
  donneesMeteoId      String?
  
  typeAlerte          TypeAlerte
  severite            Severite
  
  // Timing
  debutPrevu          DateTime
  finPrevue           DateTime
  detecteA            DateTime @default(now())
  
  // D√©tails alerte
  titre               String
  description         String
  valeurSeuil         Decimal? @db.Decimal(8,2)
  valeurMesuree       Decimal? @db.Decimal(8,2)
  
  // √âtat
  statut              StatutAlerte @default(ACTIVE)
  traiteeA            DateTime?
  
  // Relations
  jardin       Jardin @relation(fields: [jardinId], references: [id])
  donneesMeteo DonneeMeteo? @relation(fields: [donneesMeteoId], references: [id])
  
  @@map("alertes_meteo_generees")
}
```

## **üì± Interface Mobile (M√©t√©o du jour)**

### **Widget m√©t√©o contextualis√© jardinage**
```typescript
const MobileWeatherDashboard = () => {
  const { jardinId } = useCurrentJardin();
  const { data: currentWeather } = useCurrentWeather(jardinId);
  const { data: hourlyForecast } = useHourlyForecast(jardinId, 24);
  const { data: todayTasks } = useTodayTasks();

  return (
    <div className="bg-gradient-to-br from-blue-400 to-blue-600 text-white min-h-screen">
      {/* M√©t√©o actuelle avec indicateurs jardinage */}
      <div className="p-6">
        <div className="text-center mb-6">
          <div className="text-6xl mb-2">
            {getWeatherIcon(currentWeather.codeCondition, currentWeather.estJour)}
          </div>
          <div className="text-4xl font-bold">
            {Math.round(currentWeather.temperatureC)}¬∞C
          </div>
          <div className="text-lg opacity-90">
            Ressenti {Math.round(currentWeather.temperatureRessentieC)}¬∞C
          </div>
          <div className="text-sm opacity-75 mt-2">
            {currentWeather.conditionMeteo}
          </div>
        </div>

        {/* Indicateurs jardinage critiques */}
        <GardeningWeatherAlerts 
          indicators={currentWeather.indicateursJardinage}
          activeAlerts={currentWeather.alertesActives}
        />
      </div>

      {/* M√©triques jardinage rapides */}
      <div className="px-6 pb-4">
        <div className="grid grid-cols-2 gap-4">
          <WeatherMetricCard
            icon="üíß"
            title="Arrosage"
            value={currentWeather.indicateursJardinage.conditionsArrosage.recommande ? "Recommand√©" : "Pas n√©cessaire"}
            subtitle={currentWeather.indicateursJardinage.conditionsArrosage.raisonnement}
            color="blue"
          />
          
          <WeatherMetricCard
            icon="üå±"
            title="Croissance"
            value={`${currentWeather.indicateursJardinage.indiceCroissance.score}%`}
            subtitle="Conditions optimales"
            color="green"
          />
          
          <WeatherMetricCard
            icon="‚öíÔ∏è"
            title="Travail jardin"
            value={`${currentWeather.indicateursJardinage.conditionsTravail.score}/10`}
            subtitle={currentWeather.indicateursJardinage.conditionsTravail.favorable ? "Favorable" : "Limit√©"}
            color="orange"
          />
          
          <WeatherMetricCard
            icon="‚ùÑÔ∏è"
            title="Risque gel"
            value={currentWeather.indicateursJardinage.risqueGel.niveau}
            subtitle={`Min: ${currentWeather.indicateursJardinage.risqueGel.temperatureMin}¬∞C`}
            color={currentWeather.indicateursJardinage.risqueGel.niveau === 'ELEVE' ? 'red' : 'gray'}
          />
        </div>
      </div>

      {/* Pr√©visions horaires scrollables */}
      <div className="px-6 pb-4">
        <h3 className="text-lg font-medium mb-3">Prochaines 24h</h3>
        <ScrollView horizontal className="space-x-3">
          {hourlyForecast.map((hour, index) => (
            <HourlyForecastCard 
              key={index}
              hour={hour}
              isNow={index === 0}
            />
          ))}
        </ScrollView>
      </div>

      {/* Actions recommand√©es selon m√©t√©o */}
      <div className="px-6 pb-6">
        <WeatherBasedRecommendations 
          weather={currentWeather}
          todayTasks={todayTasks}
        />
      </div>
    </div>
  );
};

const GardeningWeatherAlerts = ({ indicators, activeAlerts }) => {
  const criticalAlerts = activeAlerts.filter(alert => alert.severite === 'CRITIQUE');
  const importantIndicators = [
    indicators.risqueGel.niveau === 'ELEVE' && {
      icon: 'üßä',
      message: `Risque de gel √©lev√© - ${indicators.risqueGel.temperatureMin}¬∞C`,
      action: 'Prot√©ger cultures sensibles'
    },
    indicators.conditionsTravail.score < 5 && {
      icon: '‚ö†Ô∏è',
      message: 'Conditions difficiles pour travaux',
      action: indicators.conditionsTravail.limitationsPrincipales[0]
    }
  ].filter(Boolean);

  if (criticalAlerts.length === 0 && importantIndicators.length === 0) {
    return null;
  }

  return (
    <div className="space-y-2">
      {/* Alertes critiques */}
      {criticalAlerts.map(alert => (
        <div key={alert.id} className="bg-red-500 bg-opacity-20 border border-red-300 rounded-lg p-3">
          <div className="flex items-center space-x-3">
            <div className="text-2xl">üö®</div>
            <div>
              <div className="font-medium">{alert.titre}</div>
              <div className="text-sm opacity-90">{alert.description}</div>
            </div>
          </div>
        </div>
      ))}
      
      {/* Indicateurs importants */}
      {importantIndicators.map((indicator, index) => (
        <div key={index} className="bg-yellow-500 bg-opacity-20 border border-yellow-300 rounded-lg p-3">
          <div className="flex items-center space-x-3">
            <div className="text-xl">{indicator.icon}</div>
            <div>
              <div className="font-medium">{indicator.message}</div>
              <div className="text-sm opacity-90">{indicator.action}</div>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

const HourlyForecastCard = ({ hour, isNow }) => (
  <div className={`bg-white bg-opacity-10 rounded-lg p-3 min-w-[80px] text-center ${
    isNow ? 'ring-2 ring-white' : ''
  }`}>
    <div className="text-xs opacity-75 mb-1">
      {isNow ? 'Maintenant' : format(hour.timestamp, 'HH:mm')}
    </div>
    
    <div className="text-2xl mb-1">
      {getWeatherIcon(hour.codeCondition, hour.estJour)}
    </div>
    
    <div className="font-medium">
      {Math.round(hour.temperatureC)}¬∞
    </div>
    
    {hour.precipitationMm > 0 && (
      <div className="text-xs mt-1 text-blue-200">
        üåßÔ∏è {hour.precipitationMm}mm
      </div>
    )}
    
    {hour.vitesseVentKmh > 15 && (
      <div className="text-xs mt-1 text-gray-200">
        üí® {Math.round(hour.vitesseVentKmh)}
      </div>
    )}
  </div>
);
```

## **üíª Desktop (Pr√©visions d√©taill√©es)**

### **Dashboard m√©t√©orologique avanc√©**
```typescript
const DesktopWeatherDashboard = () => {
  const { data: currentWeather } = useCurrentWeather();
  const { data: forecast10days } = useForecast(10);
  const { data: historicalWeather } = useWeatherHistory(30);
  
  return (
    <div className="grid grid-cols-12 gap-6 p-6">
      {/* M√©t√©o actuelle d√©taill√©e */}
      <div className="col-span-4">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center space-x-2">
              <span>üå§Ô∏è</span>
              <span>Conditions actuelles</span>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <CurrentWeatherDetailed weather={currentWeather} />
          </CardContent>
        </Card>
      </div>

      {/* Graphique pr√©visions */}
      <div className="col-span-8">
        <Card>
          <CardHeader>
            <CardTitle>Pr√©visions 10 jours</CardTitle>
          </CardHeader>
          <CardContent>
            <WeatherForecastChart data={forecast10days} />
          </CardContent>
        </Card>
      </div>

      {/* Indicateurs jardinage d√©taill√©s */}
      <div className="col-span-6">
        <Card>
          <CardHeader>
            <CardTitle>üå± Indicateurs jardinage</CardTitle>
          </CardHeader>
          <CardContent>
            <GardeningIndicatorsDetailed 
              indicators={currentWeather.indicateursJardinage}
              forecast={forecast10days}
            />
          </CardContent>
        </Card>
      </div>

      {/* Historique et comparaisons */}
      <div className="col-span-6">
        <Card>
          <CardHeader>
            <CardTitle>üìä Historique 30 jours</CardTitle>
          </CardHeader>
          <CardContent>
            <WeatherHistoryChart 
              data={historicalWeather}
              compareWith="last_year"
            />
          </CardContent>
        </Card>
      </div>

      {/* Alertes et recommandations */}
      <div className="col-span-12">
        <Card>
          <CardHeader>
            <CardTitle>üö® Alertes et recommandations</CardTitle>
          </CardHeader>
          <CardContent>
            <WeatherAlertsAndRecommendations 
              current={currentWeather}
              forecast={forecast10days}
            />
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

const WeatherForecastChart = ({ data }) => {
  const chartConfig = {
    temperature: {
      label: "Temp√©rature",
      color: "hsl(var(--chart-1))",
    },
    precipitation: {
      label: "Pr√©cipitations",
      color: "hsl(var(--chart-2))",
    },
    humidity: {
      label: "Humidit√©",
      color: "hsl(var(--chart-3))",
    },
  };

  return (
    <ChartContainer config={chartConfig} className="h-80">
      <ResponsiveContainer width="100%" height="100%">
        <ComposedChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis 
            dataKey="date" 
            tickFormatter={(date) => format(new Date(date), 'dd/MM')}
          />
          <YAxis yAxisId="temp" orientation="left" />
          <YAxis yAxisId="precip" orientation="right" />
          
          <Tooltip
            labelFormatter={(date) => format(new Date(date), 'EEEE dd MMMM', { locale: fr })}
            formatter={(value, name) => [
              name === 'temperature' ? `${value}¬∞C` :
              name === 'precipitation' ? `${value}mm` :
              `${value}%`,
              chartConfig[name]?.label || name
            ]}
          />
          
          <Legend />
          
          {/* Zone de temp√©rature (min-max) */}
          <Area
            yAxisId="temp"
            type="monotone"
            dataKey="temperatureMax"
            fill="rgba(239, 68, 68, 0.2)"
            stroke="transparent"
          />
          <Area
            yAxisId="temp"
            type="monotone"
            dataKey="temperatureMin"
            fill="rgba(59, 130, 246, 0.2)"
            stroke="transparent"
          />
          
          {/* Ligne temp√©rature moyenne */}
          <Line
            yAxisId="temp"
            type="monotone"
            dataKey="temperatureMoyenne"
            stroke="hsl(var(--chart-1))"
            strokeWidth={2}
            dot={{ fill: 'hsl(var(--chart-1))' }}
          />
          
          {/* Barres pr√©cipitations */}
          <Bar
            yAxisId="precip"
            dataKey="precipitationMm"
            fill="hsl(var(--chart-2))"
            opacity={0.6}
          />
          
          {/* Ligne humidit√© */}
          <Line
            yAxisId="precip"
            type="monotone"
            dataKey="humiditePourcent"
            stroke="hsl(var(--chart-3))"
            strokeWidth={1}
            strokeDasharray="5 5"
            dot={false}
          />
        </ComposedChart>
      </ResponsiveContainer>
    </ChartContainer>
  );
};

const GardeningIndicatorsDetailed = ({ indicators, forecast }) => (
  <div className="space-y-4">
    {/* Conditions d'arrosage avec pr√©vision */}
    <div className="p-4 border rounded-lg">
      <h3 className="font-medium flex items-center space-x-2 mb-3">
        <span>üíß</span>
        <span>Arrosage</span>
      </h3>
      
      <div className="grid grid-cols-2 gap-4">
        <div>
          <div className="text-2xl font-bold">
            {indicators.conditionsArrosage.recommande ? '‚úÖ' : '‚ùå'}
          </div>
          <div className="text-sm text-gray-600">
            {indicators.conditionsArrosage.raisonnement}
          </div>
        </div>
        
        <div>
          <div className="text-sm text-gray-500">Prochaine pluie</div>
          <div className="font-medium">
            {indicators.conditionsArrosage.prochainePluiePrevue 
              ? formatDistance(indicators.conditionsArrosage.prochainePluiePrevue, new Date(), { locale: fr })
              : 'Non pr√©vue'
            }
          </div>
        </div>
      </div>
      
      {/* √âvapotranspiration */}
      <div className="mt-3 p-3 bg-blue-50 rounded">
        <div className="flex justify-between items-center">
          <span className="text-sm text-blue-800">√âvapotranspiration (ET0)</span>
          <span className="font-medium text-blue-900">
            {indicators.evapotranspiration.et0.toFixed(1)} mm/jour
          </span>
        </div>
        <div className="text-xs text-blue-600 mt-1">
          Besoins en eau : {indicators.evapotranspiration.categorieBesoins.toLowerCase()}
        </div>
      </div>
    </div>

    {/* Conditions de croissance */}
    <div className="p-4 border rounded-lg">
      <h3 className="font-medium flex items-center space-x-2 mb-3">
        <span>üå±</span>
        <span>Conditions de croissance</span>
      </h3>
      
      <div className="flex items-center space-x-4 mb-3">
        <div className="text-3xl font-bold text-green-600">
          {indicators.indiceCroissance.score}%
        </div>
        <div className="flex-1">
          <div className="bg-gray-200 rounded-full h-3">
            <div 
              className="bg-green-500 rounded-full h-3 transition-all duration-300"
              style={{ width: `${indicators.indiceCroissance.score}%` }}
            />
          </div>
        </div>
      </div>
      
      {indicators.indiceCroissance.facteursLimitants.length > 0 && (
        <div>
          <div className="text-sm text-gray-500 mb-1">Facteurs limitants :</div>
          <div className="space-y-1">
            {indicators.indiceCroissance.facteursLimitants.map((facteur, index) => (
              <div key={index} className="text-sm text-red-600 bg-red-50 px-2 py-1 rounded">
                {facteur}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>

    {/* Conditions de travail */}
    <div className="p-4 border rounded-lg">
      <h3 className="font-medium flex items-center space-x-2 mb-3">
        <span>‚öíÔ∏è</span>
        <span>Conditions de travail</span>
      </h3>
      
      <div className="flex items-center justify-between mb-3">
        <span className={`px-3 py-1 rounded-full text-sm font-medium ${
          indicators.conditionsTravail.favorable 
            ? 'bg-green-100 text-green-800' 
            : 'bg-red-100 text-red-800'
        }`}>
          {indicators.conditionsTravail.favorable ? 'Favorable' : 'D√©favorable'}
        </span>
        
        <span className="text-lg font-bold">
          {indicators.conditionsTravail.score}/10
        </span>
      </div>
      
      {indicators.conditionsTravail.limitationsPrincipales.length > 0 && (
        <div>
          <div className="text-sm text-gray-500 mb-1">Limitations :</div>
          <ul className="text-sm space-y-1">
            {indicators.conditionsTravail.limitationsPrincipales.map((limitation, index) => (
              <li key={index} className="flex items-center space-x-2">
                <span className="text-yellow-500">‚ö†Ô∏è</span>
                <span>{limitation}</span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  </div>
);
```

## **üì∫ TV (Pr√©visions visuelles immersives)**

### **Interface m√©t√©o spectaculaire**
```typescript
const TVWeatherShowcase = () => {
  const { data: currentWeather } = useCurrentWeather();
  const { data: forecast } = useForecast(7);
  const [backgroundVideo, setBackgroundVideo] = useState<string>();

  useEffect(() => {
    // Vid√©o d'arri√®re-plan selon conditions m√©t√©o
    const videoMap = {
      'sunny': '/videos/sunny-garden.mp4',
      'rainy': '/videos/rainy-garden.mp4', 
      'cloudy': '/videos/cloudy-garden.mp4',
      'snowy': '/videos/winter-garden.mp4'
    };
    
    setBackgroundVideo(videoMap[currentWeather.conditionType] || videoMap.sunny);
  }, [currentWeather]);

  return (
    <div className="h-screen relative overflow-hidden text-white">
      {/* Vid√©o d'arri√®re-plan */}
      <video
        autoPlay
        loop
        muted
        className="absolute inset-0 w-full h-full object-cover"
        src={backgroundVideo}
      />
      
      {/* Overlay gradient */}
      <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-black/30" />
      
      {/* Contenu principal */}
      <div className="relative z-10 h-full flex flex-col">
        {/* Header avec m√©t√©o actuelle */}
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center space-y-6">
            {/* Ic√¥ne m√©t√©o g√©ante */}
            <motion.div
              animate={{ scale: [1, 1.05, 1] }}
              transition={{ duration: 3, repeat: Infinity }}
              className="text-9xl"
            >
              {getWeatherIcon(currentWeather.codeCondition, currentWeather.estJour)}
            </motion.div>
            
            {/* Temp√©rature principale */}
            <div className="space-y-2">
              <div className="text-8xl font-bold">
                {Math.round(currentWeather.temperatureC)}¬∞
              </div>
              <div className="text-2xl opacity-80">
                Ressenti {Math.round(currentWeather.temperatureRessentieC)}¬∞C
              </div>
              <div className="text-xl opacity-70">
                {currentWeather.conditionMeteo}
              </div>
            </div>

            {/* Indicateurs jardinage critiques */}
            <TVGardeningAlerts indicators={currentWeather.indicateursJardinage} />
          </div>
        </div>

        {/* Pr√©visions 7 jours en bas */}
        <div className="bg-black bg-opacity-40 backdrop-blur-sm p-8">
          <h2 className="text-3xl font-bold text-center mb-6">
            Pr√©visions 7 jours
          </h2>
          
          <div className="grid grid-cols-7 gap-4">
            {forecast.map((day, index) => (
              <TVDayForecast 
                key={day.date}
                day={day}
                isToday={index === 0}
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

const TVGardeningAlerts = ({ indicators }) => {
  const alerts = [];

  // Risque de gel
  if (indicators.risqueGel.niveau === 'ELEVE') {
    alerts.push({
      icon: 'üßä',
      title: 'RISQUE DE GEL',
      message: `${indicators.risqueGel.temperatureMin}¬∞C attendu`,
      color: 'text-blue-300'
    });
  }

  // Arrosage recommand√©
  if (indicators.conditionsArrosage.recommande) {
    alerts.push({
      icon: 'üíß',
      title: 'ARROSAGE RECOMMAND√â',
      message: indicators.conditionsArrosage.raisonnement,
      color: 'text-blue-300'
    });
  }

  // Conditions de croissance optimales
  if (indicators.indiceCroissance.score > 80) {
    alerts.push({
      icon: 'üå±',
      title: 'CONDITIONS OPTIMALES',
      message: `Croissance ${indicators.indiceCroissance.score}%`,
      color: 'text-green-300'
    });
  }

  if (alerts.length === 0) return null;

  return (
    <div className="space-y-3 max-w-2xl">
      {alerts.map((alert, index) => (
        <motion.div
          key={index}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: index * 0.2 }}
          className={`bg-black bg-opacity-40 backdrop-blur-sm rounded-lg p-4 ${alert.color}`}
        >
          <div className="flex items-center space-x-4">
            <div className="text-4xl">{alert.icon}</div>
            <div>
              <div className="text-xl font-bold">{alert.title}</div>
              <div className="text-sm opacity-80">{alert.message}</div>
            </div>
          </div>
        </motion.div>
      ))}
    </div>
  );
};

const TVDayForecast = ({ day, isToday }) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    className={`text-center p-4 rounded-lg backdrop-blur-sm ${
      isToday 
        ? 'bg-white bg-opacity-20 ring-2 ring-white' 
        : 'bg-white bg-opacity-10'
    }`}
  >
    <div className="text-lg font-medium mb-2">
      {isToday ? 'Aujourd\'hui' : format(day.date, 'EEEE', { locale: fr })}
    </div>
    
    <div className="text-4xl mb-3">
      {getWeatherIcon(day.codeCondition, true)}
    </div>
    
    <div className="space-y-1">
      <div className="text-2xl font-bold">
        {Math.round(day.temperatureMax)}¬∞
      </div>
      <div className="text-lg opacity-75">
        {Math.round(day.temperatureMin)}¬∞
      </div>
    </div>
    
    {day.precipitationMm > 0 && (
      <div className="text-sm mt-2 text-blue-200">
        üåßÔ∏è {day.precipitationMm}mm
      </div>
    )}
    
    {/* Indicateur jardinage rapide */}
    {day.indicateursJardinage?.conditionsArrosage?.recommande && (
      <div className="text-xs mt-2 bg-blue-500 bg-opacity-30 rounded px-2 py-1">
        üíß Arrosage
      </div>
    )}
  </motion.div>
);
```

## **‚úÖ Crit√®res d'acceptation**

### **Int√©gration WeatherAPI**
- [ ] **Pr√©visions 10 jours** avec g√©olocalisation pr√©cise ‚úÖ
- [ ] **Cache intelligent** 5min (current) / 6h (forecast) ‚úÖ
- [ ] **Donn√©es temps r√©el** synchronis√©es quotidiennement ‚úÖ
- [ ] **Fallback robuste** en cas d'indisponibilit√© API ‚úÖ

### **Indicateurs jardinage**
- [ ] **Calculs contextualis√©s** : arrosage, croissance, travail ‚úÖ
- [ ] **D√©tection risques** : gel, canicule, s√©cheresse ‚úÖ
- [ ] **√âvapotranspiration ET0** calcul√©e quotidiennement ‚úÖ
- [ ] **Recommandations automatiques** selon conditions ‚úÖ

### **Interface multi-device**
- [ ] **Mobile** : M√©t√©o du jour + recommandations ‚úÖ
- [ ] **Desktop** : Dashboard avanc√© + historique 30j ‚úÖ
- [ ] **TV** : Interface spectaculaire + vid√©os contextuelles ‚úÖ

### **Performance & Co√ªts**
- [ ] **Budget API** : < 33k appels/jour (1M/mois) ‚úÖ
- [ ] **Cache g√©ographique** pour r√©duire appels ‚úÖ
- [ ] **Monitoring usage** avec alertes d√©passement ‚úÖ
- [ ] **Temps de r√©ponse** < 1s avec cache ‚úÖ

### **Donn√©es & Historique**
- [ ] **Stockage PostgreSQL** pour analyses historiques ‚úÖ
- [ ] **Index optimis√©s** pour queries temporelles ‚úÖ
- [ ] **Export donn√©es** CSV/JSON ‚úÖ
- [ ] **Comparaisons inter-annuelles** disponibles ‚úÖ

## **üèóÔ∏è Exigences architecturales couvertes**

- **EXG-001.2** : API Routes `/src/app/api/weather/*` ‚úÖ
- **EXG-002.1** : PostgreSQL stockage DonneeMeteo ‚úÖ
- **EXG-002.3** : Redis cache avec TTL intelligent ‚úÖ
- **EXG-003.2** : Interface responsive üì±üíªüì∫ ‚úÖ
- **EXG-007.3** : Performance < 2s avec cache ‚úÖ
- **EXG-009.1** : WeatherAPI pr√©visions 10j + g√©oloc ‚úÖ
- **EXG-009.2** : Retry logic + fallback gracieux ‚úÖ
- **EXG-010.1** : Logs structur√©s Winston ‚úÖ

## **üöÄ Plan d'impl√©mentation**

### **Phase 1 : Service WeatherAPI (3j)**
1. Int√©gration WeatherAPI + transformation donn√©es
2. Cache Redis intelligent avec TTL
3. Service calcul indicateurs jardinage
4. Tests d'int√©gration et pr√©cision

### **Phase 2 : Interface Mobile (2j)**  
1. Widget m√©t√©o contextualis√©
2. Recommandations jardinage temps r√©el
3. Pr√©visions horaires scrollables
4. Alertes critiques visuelles

### **Phase 3 : Interface Desktop (3j)**
1. Dashboard m√©t√©o avanc√©
2. Graphiques pr√©visions interactifs
3. Historique et comparaisons
4. Export donn√©es et rapports

### **Phase 4 : Interface TV (2j)**
1. Interface spectaculaire avec vid√©os
2. Animations et transitions immersives
3. Timeline pr√©visions 7 jours
4. Mode pr√©sentation automatique

### **Phase 5 : Optimisation & Monitoring (2j)**
1. Monitoring usage et co√ªts API
2. Optimisation cache g√©ographique
3. Tests de charge et performance
4. Documentation compl√®te

**Dur√©e totale estim√©e : 12 jours**