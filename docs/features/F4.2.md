# F4.2 - Syst√®me d'Alertes & Notifications

**Score Priorit√© :** 85/100  
**Statut :** PRIORIT√â √âLEV√âE  
**Epic :** EPIC 4 - PILIER OPTIMISER  
**Effort estim√© :** 16 jours  

## Description

Syst√®me intelligent d'alertes et notifications multi-canal avec personnalisation avanc√©e, priorisation contextuelle et adaptation automatique selon les conditions m√©t√©orologiques et l'√©tat du jardin.

## User Stories

### US4.2.1 - Alertes Intelligentes M√©t√©o
**En tant qu'** expert jardinier  
**Je veux** recevoir des alertes pr√©ventives bas√©es sur la m√©t√©o  
**Afin de** prot√©ger mes cultures proactivement  

**Crit√®res d'acceptation :**
- Alerte gel 24h √† l'avance avec conseils protection
- Notification canicule avec plan d'arrosage d'urgence
- Alerte orage/gr√™le avec actions pr√©ventives
- Pr√©diction conditions optimales pour interventions
- Personnalisation seuils par culture et zone

### US4.2.2 - Notifications Multi-Canal
**En tant qu'** utilisateur occasionnel  
**Je veux** recevoir les alertes sur mes canaux pr√©f√©r√©s  
**Afin de** ne jamais manquer d'information critique  

**Crit√®res d'acceptation :**
- Push mobile (PWA) avec son personnalis√©
- Email avec r√©sum√© visuel et actions directes
- SMS pour alertes critiques uniquement
- Notification desktop/TV en mode ambient
- Int√©gration Home Assistant pour domotique

### US4.2.3 - Priorisation Contextuelle
**En tant qu'** utilisateur multi-jardin  
**Je veux** que les alertes soient prioris√©es intelligemment  
**Afin de** me concentrer sur l'essentiel  

**Crit√®res d'acceptation :**
- Scoring automatique de l'urgence
- Regroupement d'alertes similaires
- Silence automatique pendant absence
- Escalade selon non-r√©action
- Apprentissage des pr√©f√©rences utilisateur

## Architecture Technique

### Syst√®me de Notifications

```typescript
// src/services/notifications/notification.service.ts
export interface Alert {
  id: string;
  type: AlertType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  message: string;
  source: AlertSource;
  context: AlertContext;
  triggers: AlertTrigger[];
  actions: AlertAction[];
  schedule: AlertSchedule;
  targets: NotificationTarget[];
  createdAt: Date;
  expiresAt?: Date;
  status: 'active' | 'acknowledged' | 'resolved' | 'expired';
}

export interface NotificationTarget {
  type: 'push' | 'email' | 'sms' | 'homeassistant' | 'desktop';
  enabled: boolean;
  config: Record<string, any>;
  constraints: NotificationConstraints;
}

export interface NotificationConstraints {
  quietHours: { start: string; end: string; };
  maxFrequency: number; // par heure
  severityThreshold: string;
  locationBased: boolean;
}

export class NotificationService {
  private alertEngineService: AlertEngineService;
  private channelHandlers: Map<string, NotificationHandler>;
  private userPreferences: Map<string, UserNotificationPreferences>;

  constructor(
    private prisma: PrismaClient,
    private weatherService: WeatherService,
    private iotService: IoTService,
    private aiService: AIService,
    private homeAssistantService: HomeAssistantService
  ) {
    this.initializeChannelHandlers();
    this.alertEngineService = new AlertEngineService();
  }

  async processAlert(alert: Alert): Promise<void> {
    // Validation et enrichissement
    const enrichedAlert = await this.enrichAlert(alert);
    
    // Calcul de priorit√© contextuelle
    const priority = await this.calculatePriority(enrichedAlert);
    
    // Filtrage selon pr√©f√©rences utilisateur
    const targets = await this.filterTargets(enrichedAlert, priority);
    
    // Envoi multi-canal
    await this.sendToChannels(enrichedAlert, targets);
    
    // Stockage et tracking
    await this.storeAlert(enrichedAlert);
    
    // Programmation des suivis
    await this.scheduleFollowUps(enrichedAlert);
  }

  private async enrichAlert(alert: Alert): Promise<EnrichedAlert> {
    // Enrichissement avec donn√©es m√©t√©o
    const weather = await this.weatherService.getCurrentConditions();
    
    // Enrichissement avec donn√©es IoT
    const iotData = await this.iotService.getRelevantReadings(alert.context);
    
    // Enrichissement avec analyse IA
    const aiInsights = await this.aiService.analyzeAlertContext(alert, {
      weather,
      iotData,
      historicalPatterns: await this.getHistoricalPatterns(alert.type)
    });

    return {
      ...alert,
      enrichments: {
        weather,
        iotData,
        aiInsights,
        contextualRecommendations: aiInsights.recommendations
      },
      enhancedSeverity: aiInsights.suggestedSeverity,
      predictedImpact: aiInsights.impactAssessment
    };
  }

  private async calculatePriority(alert: EnrichedAlert): Promise<AlertPriority> {
    const factors = {
      baseSeverity: this.getSeverityScore(alert.severity),
      weatherImpact: this.assessWeatherImpact(alert),
      timelineUrgency: this.calculateTimelineUrgency(alert),
      cropValue: await this.assessCropValue(alert.context),
      historicalImportance: await this.getHistoricalImportance(alert.type),
      userEngagement: await this.getUserEngagementScore(alert.source.userId, alert.type)
    };

    const priorityScore = this.weightedPriorityCalculation(factors);
    
    return {
      score: priorityScore,
      level: this.scoreToPriorityLevel(priorityScore),
      factors,
      recommendation: this.generatePriorityRecommendation(factors)
    };
  }
}
```

### Moteur d'Alertes M√©t√©o

```typescript
// src/services/notifications/weather-alerts.service.ts
export class WeatherAlertsService {
  private readonly ALERT_THRESHOLDS = {
    frost: { temperature: 2, probability: 0.3 },
    heatwave: { temperature: 35, duration: 3 },
    storm: { windSpeed: 50, probability: 0.5 },
    drought: { precipitationDeficit: 20, duration: 14 }
  };

  constructor(
    private weatherService: WeatherService,
    private notificationService: NotificationService,
    private gardenService: GardenService
  ) {
    // Monitoring continu toutes les 30 minutes
    setInterval(() => this.checkWeatherConditions(), 30 * 60 * 1000);
  }

  async checkWeatherConditions(): Promise<void> {
    const gardens = await this.gardenService.getAllActiveGardens();
    
    for (const garden of gardens) {
      const forecast = await this.weatherService.getDetailedForecast(
        garden.latitude, 
        garden.longitude
      );

      await Promise.all([
        this.checkFrostRisk(garden, forecast),
        this.checkHeatwaveRisk(garden, forecast),
        this.checkStormRisk(garden, forecast),
        this.checkDroughtRisk(garden, forecast),
        this.checkOptimalConditions(garden, forecast)
      ]);
    }
  }

  private async checkFrostRisk(garden: Garden, forecast: WeatherForecast): Promise<void> {
    const frostRisk = forecast.hourly
      .filter(hour => hour.timestamp > new Date())
      .find(hour => 
        hour.temperature <= this.ALERT_THRESHOLDS.frost.temperature &&
        hour.frostProbability >= this.ALERT_THRESHOLDS.frost.probability
      );

    if (!frostRisk) return;

    // Analyse des cultures sensibles
    const sensitiveCrops = await this.gardenService.getFrostSensitiveCrops(garden.id);
    
    if (sensitiveCrops.length === 0) return;

    const hoursUntilFrost = Math.floor(
      (frostRisk.timestamp.getTime() - Date.now()) / (1000 * 60 * 60)
    );

    const alert: Alert = {
      id: `frost-${garden.id}-${Date.now()}`,
      type: 'weather_frost',
      severity: hoursUntilFrost < 6 ? 'critical' : 'high',
      title: `üßä Alerte Gel dans ${hoursUntilFrost}h`,
      message: `Risque de gel √† ${frostRisk.temperature}¬∞C. ${sensitiveCrops.length} culture(s) sensible(s) √† prot√©ger.`,
      source: { type: 'weather', sourceId: 'weatherapi', userId: garden.userId },
      context: {
        gardenId: garden.id,
        affectedCrops: sensitiveCrops.map(crop => crop.id),
        timeUntilEvent: hoursUntilFrost,
        expectedConditions: frostRisk
      },
      actions: await this.generateFrostProtectionActions(sensitiveCrops, frostRisk),
      schedule: {
        immediate: true,
        followUps: [
          { delayHours: 2, type: 'reminder' },
          { delayHours: 6, type: 'status_check' }
        ]
      },
      targets: await this.getNotificationTargets(garden.userId, 'weather_frost'),
      createdAt: new Date(),
      expiresAt: new Date(frostRisk.timestamp.getTime() + 6 * 60 * 60 * 1000),
      status: 'active'
    };

    await this.notificationService.processAlert(alert);
  }

  private async generateFrostProtectionActions(
    crops: SensitiveCrop[], 
    frostConditions: WeatherHour
  ): Promise<AlertAction[]> {
    const actions: AlertAction[] = [];

    // Actions g√©n√©riques
    actions.push({
      id: 'cover_crops',
      type: 'manual',
      label: 'Couvrir les cultures',
      description: 'Installer voiles d\'hivernage ou b√¢ches',
      urgency: 'high',
      estimatedTime: 30,
      materials: ['voile_hivernage', 'baches', 'piquets']
    });

    // Actions sp√©cifiques selon les cultures
    for (const crop of crops) {
      if (crop.varieteCulture.besoinsEau.includes('arrosage_protection_gel')) {
        actions.push({
          id: `water_${crop.id}`,
          type: 'irrigation',
          label: `Arroser ${crop.varieteCulture.nom}`,
          description: 'Arrosage pr√©ventif contre le gel',
          urgency: 'medium',
          estimatedTime: 10,
          automatable: true
        });
      }
    }

    // Actions domotiques si disponible
    const homeAssistantDevices = await this.getAvailableProtectionDevices(crops[0].zoneId);
    if (homeAssistantDevices.length > 0) {
      actions.push({
        id: 'activate_heating',
        type: 'automation',
        label: 'Activer chauffage de serre',
        description: 'D√©marrage automatique des syst√®mes de protection',
        urgency: 'high',
        automatable: true,
        devices: homeAssistantDevices
      });
    }

    return actions;
  }
}
```

### Handlers de Notification

```typescript
// src/services/notifications/handlers/push-notification.handler.ts
export class PushNotificationHandler implements NotificationHandler {
  type = 'push';

  constructor(private webPushService: WebPushService) {}

  async send(alert: EnrichedAlert, target: NotificationTarget): Promise<NotificationResult> {
    const payload = {
      title: alert.title,
      body: alert.message,
      icon: this.getIconForAlertType(alert.type),
      badge: '/icons/badge.png',
      data: {
        alertId: alert.id,
        actions: alert.actions.slice(0, 3), // Limite PWA
        url: `/alerts/${alert.id}`
      },
      actions: alert.actions.slice(0, 2).map(action => ({
        action: action.id,
        title: action.label,
        icon: this.getIconForAction(action.type)
      })),
      requireInteraction: alert.severity === 'critical',
      silent: alert.severity === 'low',
      vibrate: this.getVibrationPattern(alert.severity)
    };

    try {
      const result = await this.webPushService.sendNotification(
        target.config.subscription,
        JSON.stringify(payload)
      );

      return {
        success: true,
        messageId: result.messageId,
        deliveredAt: new Date()
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        retryable: this.isRetryableError(error)
      };
    }
  }

  private getVibrationPattern(severity: string): number[] {
    switch (severity) {
      case 'critical': return [200, 100, 200, 100, 200];
      case 'high': return [200, 100, 200];
      case 'medium': return [200];
      default: return [];
    }
  }
}

// src/services/notifications/handlers/email-notification.handler.ts
export class EmailNotificationHandler implements NotificationHandler {
  type = 'email';

  constructor(
    private emailService: EmailService,
    private templateService: TemplateService
  ) {}

  async send(alert: EnrichedAlert, target: NotificationTarget): Promise<NotificationResult> {
    const template = await this.selectTemplate(alert);
    const context = await this.buildTemplateContext(alert);
    
    const emailContent = await this.templateService.render(template, context);

    const emailOptions = {
      to: target.config.email,
      subject: this.buildSubject(alert),
      html: emailContent.html,
      text: emailContent.text,
      attachments: await this.buildAttachments(alert)
    };

    try {
      const result = await this.emailService.send(emailOptions);
      return {
        success: true,
        messageId: result.messageId,
        deliveredAt: new Date()
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        retryable: true
      };
    }
  }

  private async buildTemplateContext(alert: EnrichedAlert): Promise<any> {
    return {
      alert,
      garden: await this.getGardenInfo(alert.context.gardenId),
      weather: alert.enrichments.weather,
      recommendations: alert.enrichments.aiInsights.recommendations,
      actionButtons: alert.actions.map(action => ({
        label: action.label,
        url: `${process.env.BASE_URL}/alerts/${alert.id}/action/${action.id}`
      })),
      unsubscribeUrl: `${process.env.BASE_URL}/notifications/unsubscribe`
    };
  }
}
```

## Interfaces Multi-Device

### üì± Interface Mobile

```typescript
// src/app/alerts/page.tsx
export default function AlertsMobilePage() {
  const { alerts, markAsRead, executeAction } = useAlerts();
  
  return (
    <div className="min-h-screen bg-gray-50">
      <MobileHeader title="Alertes & Notifications" />
      
      <div className="p-4 space-y-4">
        {/* Alertes critiques en haut */}
        <CriticalAlertsSection alerts={alerts.filter(a => a.severity === 'critical')} />
        
        {/* Alertes par cat√©gorie */}
        <AlertCategoriesNav />
        
        {/* Liste des alertes */}
        <AlertsList 
          alerts={alerts}
          onMarkAsRead={markAsRead}
          onExecuteAction={executeAction}
        />
      </div>
      
      <FloatingActionButton 
        onClick={() => router.push('/alerts/settings')}
        icon={<SettingsIcon />}
      />
    </div>
  );
}

const CriticalAlertsSection = ({ alerts }: { alerts: Alert[] }) => {
  if (alerts.length === 0) return null;
  
  return (
    <div className="space-y-3">
      <h2 className="text-lg font-semibold text-red-700 flex items-center">
        <AlertTriangleIcon className="w-5 h-5 mr-2" />
        Alertes Critiques
      </h2>
      
      {alerts.map(alert => (
        <CriticalAlertCard key={alert.id} alert={alert} />
      ))}
    </div>
  );
};

const CriticalAlertCard = ({ alert }: { alert: Alert }) => {
  return (
    <Card className="border-red-300 bg-red-50">
      <div className="p-4">
        <div className="flex justify-between items-start">
          <div className="flex-1">
            <h3 className="font-semibold text-red-900">{alert.title}</h3>
            <p className="text-sm text-red-700 mt-1">{alert.message}</p>
            <div className="flex items-center mt-2 text-xs text-red-600">
              <ClockIcon className="w-4 h-4 mr-1" />
              <TimeAgo date={alert.createdAt} />
            </div>
          </div>
          <Badge variant="destructive" className="ml-2">
            URGENT
          </Badge>
        </div>
        
        <div className="mt-4 grid grid-cols-2 gap-2">
          {alert.actions.slice(0, 2).map(action => (
            <Button
              key={action.id}
              size="sm"
              variant={action.urgency === 'high' ? 'default' : 'outline'}
              className="text-xs"
              onClick={() => executeAction(alert.id, action.id)}
            >
              {action.label}
            </Button>
          ))}
        </div>
      </div>
    </Card>
  );
};
```

### üíª Interface Desktop

```typescript
// Centre de contr√¥le des notifications desktop
const NotificationControlCenter = () => {
  const { alerts, filters, updateFilters } = useNotificationCenter();
  
  return (
    <div className="h-screen flex">
      {/* Sidebar filters */}
      <div className="w-80 border-r bg-gray-50 p-6">
        <h2 className="text-lg font-semibold mb-4">Centre de Notifications</h2>
        
        <NotificationFilters 
          filters={filters}
          onUpdateFilters={updateFilters}
        />
        
        <div className="mt-6">
          <h3 className="font-medium mb-3">Actions Rapides</h3>
          <QuickActionsPanel />
        </div>
      </div>
      
      {/* Main content */}
      <div className="flex-1 flex flex-col">
        <div className="border-b p-4">
          <NotificationToolbar />
        </div>
        
        <div className="flex-1 overflow-auto">
          <AlertsTimeline alerts={alerts} />
        </div>
      </div>
      
      {/* Details panel */}
      <div className="w-96 border-l bg-white">
        <AlertDetailsPanel />
      </div>
    </div>
  );
};

const AlertsTimeline = ({ alerts }: { alerts: Alert[] }) => {
  return (
    <div className="p-6">
      <div className="space-y-6">
        {alerts.map(alert => (
          <AlertTimelineItem key={alert.id} alert={alert} />
        ))}
      </div>
    </div>
  );
};

const AlertTimelineItem = ({ alert }: { alert: Alert }) => {
  return (
    <div className="flex space-x-4">
      <div className="flex-shrink-0">
        <div className={`w-3 h-3 rounded-full ${getSeverityColor(alert.severity)}`} />
        <div className="w-px bg-gray-200 h-12 mx-auto mt-2" />
      </div>
      
      <div className="flex-1 bg-white rounded-lg border p-4 hover:shadow-md transition-shadow">
        <div className="flex justify-between items-start">
          <div>
            <h3 className="font-semibold">{alert.title}</h3>
            <p className="text-gray-600 text-sm mt-1">{alert.message}</p>
          </div>
          <Badge variant={getSeverityVariant(alert.severity)}>
            {alert.severity.toUpperCase()}
          </Badge>
        </div>
        
        {alert.enrichments?.aiInsights?.recommendations && (
          <div className="mt-3 p-3 bg-blue-50 rounded border-l-4 border-blue-400">
            <p className="text-sm font-medium text-blue-900">Recommandation IA</p>
            <p className="text-sm text-blue-700 mt-1">
              {alert.enrichments.aiInsights.recommendations}
            </p>
          </div>
        )}
        
        <div className="mt-4 flex items-center justify-between">
          <div className="flex space-x-2">
            {alert.actions.map(action => (
              <Button
                key={action.id}
                size="sm"
                variant="outline"
                onClick={() => executeAction(alert.id, action.id)}
              >
                {action.label}
              </Button>
            ))}
          </div>
          
          <span className="text-xs text-gray-500">
            <TimeAgo date={alert.createdAt} />
          </span>
        </div>
      </div>
    </div>
  );
};
```

### üì∫ Interface TV

```typescript
// Affichage ambient pour monitoring TV
const AlertsTVDisplay = () => {
  const { criticalAlerts, recentAlerts } = useAlertsTV();
  
  return (
    <div className="h-screen bg-gradient-to-br from-blue-900 to-green-900 text-white p-8">
      {criticalAlerts.length > 0 && (
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-6 text-red-400 animate-pulse">
            üö® ALERTES CRITIQUES
          </h1>
          
          <div className="grid grid-cols-2 gap-6">
            {criticalAlerts.map(alert => (
              <CriticalAlertTVCard key={alert.id} alert={alert} />
            ))}
          </div>
        </div>
      )}
      
      <div>
        <h2 className="text-3xl font-bold mb-6">
          Notifications R√©centes
        </h2>
        
        <div className="grid grid-cols-3 gap-6">
          {recentAlerts.map(alert => (
            <AlertTVCard key={alert.id} alert={alert} />
          ))}
        </div>
      </div>
      
      <div className="fixed bottom-8 right-8">
        <div className="text-right">
          <div className="text-xl font-semibold">
            {new Date().toLocaleTimeString('fr-FR')}
          </div>
          <div className="text-sm opacity-75">
            Derni√®re mise √† jour
          </div>
        </div>
      </div>
    </div>
  );
};

const CriticalAlertTVCard = ({ alert }: { alert: Alert }) => {
  return (
    <div className="bg-red-600/20 border-2 border-red-400 rounded-2xl p-6 backdrop-blur-sm">
      <div className="flex items-center mb-4">
        <AlertTriangleIcon className="w-8 h-8 text-red-400 mr-3" />
        <h3 className="text-2xl font-bold">{alert.title}</h3>
      </div>
      
      <p className="text-lg mb-4">{alert.message}</p>
      
      <div className="space-y-2">
        {alert.actions.slice(0, 2).map(action => (
          <div key={action.id} className="flex items-center text-yellow-300">
            <ArrowRightIcon className="w-5 h-5 mr-2" />
            <span>{action.label}</span>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## API Routes

```typescript
// src/app/api/alerts/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const severity = searchParams.get('severity');
  const status = searchParams.get('status');
  const type = searchParams.get('type');

  const alerts = await prisma.alerte.findMany({
    where: {
      ...(severity && { severite: severity }),
      ...(status && { statut: status }),
      ...(type && { type: type })
    },
    include: {
      enrichissements: true,
      actions: true,
      notifications: true
    },
    orderBy: [
      { severite: 'desc' },
      { createdAt: 'desc' }
    ]
  });

  return NextResponse.json({
    alerts: alerts.map(alert => ({
      id: alert.id,
      type: alert.type,
      severity: alert.severite,
      title: alert.titre,
      message: alert.message,
      context: alert.contexte,
      actions: alert.actions,
      status: alert.statut,
      createdAt: alert.createdAt,
      enrichments: alert.enrichissements
    }))
  });
}

// src/app/api/alerts/[alertId]/actions/[actionId]/route.ts
export async function POST(
  request: Request,
  { params }: { params: { alertId: string; actionId: string } }
) {
  const alert = await prisma.alerte.findUnique({
    where: { id: params.alertId },
    include: { actions: true }
  });

  if (!alert) {
    return NextResponse.json({ error: 'Alert not found' }, { status: 404 });
  }

  const action = alert.actions.find(a => a.id === params.actionId);
  if (!action) {
    return NextResponse.json({ error: 'Action not found' }, { status: 404 });
  }

  // Ex√©cution de l'action
  const result = await actionExecutorService.execute(action, alert);

  // Mise √† jour statut alerte
  await prisma.alerte.update({
    where: { id: params.alertId },
    data: { 
      statut: result.success ? 'resolved' : 'active',
      derniereMiseAJour: new Date()
    }
  });

  return NextResponse.json({ 
    success: result.success,
    message: result.message 
  });
}
```

## Crit√®res d'Acceptation Techniques

### Performance
- [ ] Latence notification : < 3s apr√®s trigger
- [ ] Throughput : > 1000 notifications/minute
- [ ] Taux de livraison : > 98% pour push/email
- [ ] Temps de traitement IA : < 5s par alerte

### Fiabilit√©
- [ ] Disponibilit√© service : > 99.9%
- [ ] Retry automatique avec backoff exponentiel
- [ ] Fallback entre canaux en cas d'√©chec
- [ ] Persistent queue pour notifications offline

### Intelligence
- [ ] Pr√©cision pr√©diction m√©t√©o : > 85%
- [ ] R√©duction alertes redondantes : > 70%
- [ ] Apprentissage pr√©f√©rences utilisateur
- [ ] Adaptation contextuelle temps r√©el

## Couverture Exigences Architecture

- **EXG-001.3** : Interface multi-device adapt√©e
- **EXG-004.1** : Int√©gration WeatherAPI pour alertes m√©t√©o
- **EXG-005.1** : IA pour priorisation et recommandations
- **EXG-006.1** : Int√©gration Home Assistant pour notifications domotiques
- **EXG-007.1** : Notifications temps r√©el multi-device
- **EXG-007.2** : PWA avec notifications push
- **EXG-009.1** : Monitoring et m√©triques des notifications

## Tests d'Acceptation

```typescript
// tests/integration/notifications.test.ts
describe('Notification System', () => {
  test('alerte gel g√©n√©r√©e correctement avec m√©t√©o', async () => {
    const forecast = createMockFrostForecast();
    const garden = await createTestGarden();
    
    await weatherAlertsService.checkFrostRisk(garden, forecast);
    
    const alerts = await prisma.alerte.findMany({
      where: { type: 'weather_frost' }
    });
    
    expect(alerts).toHaveLength(1);
    expect(alerts[0].severite).toBe('critical');
  });

  test('notification multi-canal fonctionne', async () => {
    const alert = createTestAlert();
    const targets = [
      { type: 'push', config: { subscription: 'test' } },
      { type: 'email', config: { email: 'test@example.com' } }
    ];
    
    const results = await notificationService.sendToChannels(alert, targets);
    
    expect(results.every(r => r.success)).toBe(true);
  });

  test('priorisation contextuelle fonctionne', async () => {
    const lowPriorityAlert = createWeatherAlert('light_rain');
    const highPriorityAlert = createWeatherAlert('frost');
    
    const lowPriority = await notificationService.calculatePriority(lowPriorityAlert);
    const highPriority = await notificationService.calculatePriority(highPriorityAlert);
    
    expect(highPriority.score).toBeGreaterThan(lowPriority.score);
  });
});
```

Cette sp√©cification couvre un syst√®me complet d'alertes et notifications intelligent, capable de s'adapter aux conditions m√©t√©orologiques et aux pr√©f√©rences utilisateur pour optimiser la gestion du jardin.