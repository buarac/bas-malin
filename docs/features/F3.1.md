# F3.1 - Collecte & Consolidation Automatique

**Score Priorité :** 85/100  
**Statut :** PRIORITÉ ÉLEVÉE  
**Epic :** EPIC 3 - PILIER COMPRENDRE  
**Effort estimé :** 18 jours  

## Description

Système automatisé de collecte et consolidation des données multi-sources (IoT, météo, photos, saisies manuelles) avec enrichissement intelligent des données et synchronisation temps réel entre les différents appareils.

## User Stories

### US3.1.1 - Collecte Multi-Sources
**En tant qu'** expert jardinier  
**Je veux** que le système collecte automatiquement les données de toutes mes sources  
**Afin de** avoir une vue consolidée sans effort manuel  

**Critères d'acceptation :**
- Collecte automatique depuis capteurs IoT (ESP32 + Home Assistant)
- Intégration données météo (WeatherAPI)
- Consolidation photos avec métadonnées EXIF
- Récupération saisies manuelles multi-device
- Fréquence configurable par source de données

### US3.1.2 - Enrichissement Intelligent
**En tant qu'** utilisateur occasionnel  
**Je veux** que mes données soient enrichies automatiquement  
**Afin de** bénéficier d'insights sans expertise technique  

**Critères d'acceptation :**
- Analyse contextuelle des photos (reconnaissance plantes/maladies)
- Calculs automatiques (croissance, rendement, efficacité eau)
- Géolocalisation automatique des interventions
- Horodatage intelligent avec correction timezone
- Tags automatiques basés sur le contenu

### US3.1.3 - Consolidation Temps Réel
**En tant qu'** utilisateur multi-device  
**Je veux** que mes données soient synchronisées instantanément  
**Afin de** accéder aux informations à jour sur tous mes appareils  

**Critères d'acceptation :**
- Synchronisation < 5 secondes entre appareils
- Résolution intelligente des conflits
- Mise à jour progressive (delta sync)
- Notification des changements critiques
- Mode offline avec queue de synchronisation

## Architecture Technique

### Structure des Services de Collecte

```typescript
// src/services/data-collection/collector.service.ts
import { IoTService } from './iot/iot.service';
import { WeatherService } from './weather/weather.service';
import { PhotoService } from './photo/photo.service';
import { ManualDataService } from './manual/manual-data.service';

export interface DataSource {
  id: string;
  type: 'iot' | 'weather' | 'photo' | 'manual';
  frequency: number; // millisecondes
  enabled: boolean;
  lastCollection: Date;
  config: Record<string, any>;
}

export interface CollectionResult {
  sourceId: string;
  timestamp: Date;
  data: any;
  enrichments: DataEnrichment[];
  metadata: CollectionMetadata;
}

export interface DataEnrichment {
  type: 'ai_analysis' | 'calculation' | 'geolocation' | 'temporal';
  confidence: number;
  result: any;
  processingTime: number;
}

export class DataCollectorService {
  private sources: Map<string, DataSource> = new Map();
  private collectors: Map<string, BaseCollector> = new Map();
  private enrichmentPipeline: EnrichmentPipeline;

  constructor(
    private iotService: IoTService,
    private weatherService: WeatherService,
    private photoService: PhotoService,
    private manualDataService: ManualDataService,
    private prisma: PrismaClient,
    private redis: Redis,
    private eventEmitter: EventEmitter
  ) {
    this.initializeCollectors();
    this.enrichmentPipeline = new EnrichmentPipeline();
  }

  async startCollection(sourceId: string): Promise<void> {
    const source = this.sources.get(sourceId);
    if (!source || !source.enabled) return;

    const collector = this.collectors.get(source.type);
    if (!collector) throw new Error(`No collector for type ${source.type}`);

    setInterval(async () => {
      try {
        const rawData = await collector.collect(source.config);
        const enrichedData = await this.enrichmentPipeline.process(rawData);
        
        const result: CollectionResult = {
          sourceId,
          timestamp: new Date(),
          data: rawData,
          enrichments: enrichedData.enrichments,
          metadata: {
            collectionDuration: Date.now() - enrichedData.startTime,
            dataQuality: this.assessDataQuality(rawData),
            conflicts: []
          }
        };

        await this.storeAndSync(result);
        this.eventEmitter.emit('dataCollected', result);
        
      } catch (error) {
        console.error(`Collection failed for ${sourceId}:`, error);
        await this.handleCollectionError(sourceId, error);
      }
    }, source.frequency);
  }

  private async storeAndSync(result: CollectionResult): Promise<void> {
    // Stockage local avec transaction
    await this.prisma.$transaction(async (tx) => {
      await tx.donneesCollectees.create({
        data: {
          sourceId: result.sourceId,
          timestamp: result.timestamp,
          donneesRaw: result.data,
          enrichissements: result.enrichments,
          metadata: result.metadata
        }
      });

      // Mise à jour cache Redis
      await this.redis.setex(
        `collection:${result.sourceId}:latest`,
        3600,
        JSON.stringify(result)
      );
    });

    // Synchronisation multi-device
    await this.syncToAllDevices(result);
  }
}
```

### Pipeline d'Enrichissement

```typescript
// src/services/data-collection/enrichment/enrichment-pipeline.ts
export interface EnrichmentProcessor {
  type: string;
  priority: number;
  process(data: any): Promise<DataEnrichment[]>;
}

export class EnrichmentPipeline {
  private processors: EnrichmentProcessor[] = [];

  constructor() {
    this.initializeProcessors();
  }

  private initializeProcessors(): void {
    this.processors = [
      new AIAnalysisProcessor(),
      new GeolocationProcessor(),
      new TemporalProcessor(),
      new CalculationProcessor(),
      new ContextualProcessor()
    ].sort((a, b) => a.priority - b.priority);
  }

  async process(rawData: any): Promise<EnrichedData> {
    const startTime = Date.now();
    const enrichments: DataEnrichment[] = [];

    for (const processor of this.processors) {
      try {
        const processorResults = await processor.process(rawData);
        enrichments.push(...processorResults);
      } catch (error) {
        console.error(`Enrichment processor ${processor.type} failed:`, error);
      }
    }

    return {
      originalData: rawData,
      enrichments,
      startTime,
      processingTime: Date.now() - startTime
    };
  }
}

// Processeur d'analyse IA
export class AIAnalysisProcessor implements EnrichmentProcessor {
  type = 'ai_analysis';
  priority = 1;

  constructor(private aiService: AIService) {}

  async process(data: any): Promise<DataEnrichment[]> {
    const enrichments: DataEnrichment[] = [];

    // Analyse des photos
    if (data.type === 'photo' && data.imageUrl) {
      const analysis = await this.aiService.analyzeImage(data.imageUrl, {
        detectPlants: true,
        detectDiseases: true,
        detectPests: true,
        extractMetrics: true
      });

      enrichments.push({
        type: 'ai_analysis',
        confidence: analysis.confidence,
        result: {
          plantDetection: analysis.plants,
          healthAssessment: analysis.health,
          actionRecommendations: analysis.recommendations
        },
        processingTime: analysis.processingTime
      });
    }

    // Analyse des données IoT
    if (data.type === 'iot' && data.sensorReadings) {
      const patterns = await this.aiService.detectPatterns(data.sensorReadings);
      
      enrichments.push({
        type: 'ai_analysis',
        confidence: patterns.confidence,
        result: {
          anomalies: patterns.anomalies,
          trends: patterns.trends,
          predictions: patterns.predictions
        },
        processingTime: patterns.processingTime
      });
    }

    return enrichments;
  }
}
```

### Collecteurs Spécialisés

```typescript
// src/services/data-collection/collectors/iot-collector.ts
export class IoTCollector extends BaseCollector {
  type = 'iot';

  async collect(config: IoTCollectorConfig): Promise<any> {
    const devices = await this.iotService.getActiveDevices(config.gardenId);
    const readings: SensorReading[] = [];

    for (const device of devices) {
      try {
        const deviceReadings = await this.iotService.getLatestReadings(device.id);
        readings.push(...deviceReadings.map(reading => ({
          deviceId: device.id,
          sensorType: reading.type,
          value: reading.value,
          unit: reading.unit,
          timestamp: reading.timestamp,
          quality: this.assessReadingQuality(reading),
          location: device.location
        })));
      } catch (error) {
        console.warn(`Failed to collect from device ${device.id}:`, error);
      }
    }

    return {
      type: 'iot',
      gardenId: config.gardenId,
      readings,
      collectionTimestamp: new Date(),
      deviceCount: devices.length,
      successfulReadings: readings.length
    };
  }

  private assessReadingQuality(reading: any): DataQuality {
    // Validation des valeurs
    if (reading.value < reading.sensor.minValue || 
        reading.value > reading.sensor.maxValue) {
      return { level: 'poor', issues: ['out_of_range'] };
    }

    // Vérification de la fraîcheur
    const age = Date.now() - reading.timestamp.getTime();
    if (age > 30 * 60 * 1000) { // 30 minutes
      return { level: 'degraded', issues: ['stale_data'] };
    }

    return { level: 'excellent', issues: [] };
  }
}

// src/services/data-collection/collectors/photo-collector.ts
export class PhotoCollector extends BaseCollector {
  type = 'photo';

  async collect(config: PhotoCollectorConfig): Promise<any> {
    // Collecte depuis galerie locale
    const localPhotos = await this.scanLocalPhotos(config.watchDirectories);
    
    // Collecte depuis uploads récents
    const recentUploads = await this.getRecentUploads(config.gardenId);

    const photos = [...localPhotos, ...recentUploads];
    const processedPhotos = [];

    for (const photo of photos) {
      try {
        const metadata = await this.extractPhotoMetadata(photo);
        const geoLocation = await this.extractGeoLocation(metadata.exif);
        
        processedPhotos.push({
          id: photo.id,
          url: photo.url,
          timestamp: metadata.dateTime || photo.createdAt,
          location: geoLocation,
          metadata: metadata,
          size: photo.size,
          format: photo.format
        });
      } catch (error) {
        console.warn(`Failed to process photo ${photo.id}:`, error);
      }
    }

    return {
      type: 'photo',
      gardenId: config.gardenId,
      photos: processedPhotos,
      collectionTimestamp: new Date(),
      totalPhotos: photos.length,
      processedPhotos: processedPhotos.length
    };
  }
}
```

## Interfaces Multi-Device

### 📱 Interface Mobile

```typescript
// src/app/collect/page.tsx
export default function DataCollectionMobilePage() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50">
      <MobileHeader title="Collecte Automatique" />
      
      <div className="p-4 space-y-4">
        {/* Status en temps réel */}
        <CollectionStatusCard />
        
        {/* Sources de données actives */}
        <ActiveSourcesList />
        
        {/* Dernières collectes */}
        <RecentCollectionsTimeline />
        
        {/* Configuration rapide */}
        <QuickConfigPanel />
      </div>
      
      <FloatingActionButton 
        onClick={() => router.push('/collect/configure')}
        icon={<SettingsIcon />}
      />
    </div>
  );
}

const CollectionStatusCard = () => {
  const { status } = useCollectionStatus();
  
  return (
    <Card className="p-4 bg-white/80 backdrop-blur-sm">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="font-semibold text-gray-900">État de Collecte</h3>
          <p className="text-sm text-gray-600">
            {status.activeSources} sources actives
          </p>
        </div>
        <div className="flex items-center space-x-2">
          <div className={`w-3 h-3 rounded-full ${
            status.overall === 'healthy' ? 'bg-green-500' :
            status.overall === 'warning' ? 'bg-yellow-500' : 'bg-red-500'
          }`} />
          <span className="text-sm font-medium">
            {status.overall === 'healthy' ? 'Optimal' :
             status.overall === 'warning' ? 'Attention' : 'Problème'}
          </span>
        </div>
      </div>
      
      <div className="mt-4 grid grid-cols-3 gap-3">
        <MetricCard 
          label="IoT" 
          value={status.iot.count} 
          status={status.iot.status} 
        />
        <MetricCard 
          label="Photos" 
          value={status.photos.count} 
          status={status.photos.status} 
        />
        <MetricCard 
          label="Météo" 
          value={status.weather.freshness} 
          status={status.weather.status} 
        />
      </div>
    </Card>
  );
};
```

### 💻 Interface Desktop

```typescript
// Interface de monitoring avancé
const DataCollectionDashboard = () => {
  return (
    <div className="h-screen flex flex-col">
      <DashboardHeader />
      
      <div className="flex-1 grid grid-cols-12 gap-6 p-6">
        {/* Panel de contrôle */}
        <div className="col-span-3 space-y-4">
          <SourceControlPanel />
          <EnrichmentConfigPanel />
          <AlertsPanel />
        </div>
        
        {/* Visualisations en temps réel */}
        <div className="col-span-6 space-y-4">
          <CollectionTimelineChart />
          <DataQualityMatrix />
          <EnrichmentPipelineVisualization />
        </div>
        
        {/* Détails et logs */}
        <div className="col-span-3 space-y-4">
          <SourceDetailsPanel />
          <CollectionLogsPanel />
          <PerformanceMetrics />
        </div>
      </div>
    </div>
  );
};

const CollectionTimelineChart = () => {
  const { data } = useCollectionTimeline();
  
  return (
    <Card className="p-6">
      <h3 className="text-lg font-semibold mb-4">Timeline de Collecte</h3>
      <ResponsiveContainer width="100%" height={300}>
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="timestamp" />
          <YAxis />
          <Tooltip />
          <Line 
            type="monotone" 
            dataKey="iot" 
            stroke="#10b981" 
            strokeWidth={2}
            name="Données IoT"
          />
          <Line 
            type="monotone" 
            dataKey="photos" 
            stroke="#3b82f6" 
            strokeWidth={2}
            name="Photos"
          />
          <Line 
            type="monotone" 
            dataKey="manual" 
            stroke="#f59e0b" 
            strokeWidth={2}
            name="Saisies Manuelles"
          />
        </LineChart>
      </ResponsiveContainer>
    </Card>
  );
};
```

### 📺 Interface TV

```typescript
// Vue panoramique pour monitoring TV
const CollectionTVDashboard = () => {
  return (
    <div className="h-screen bg-gradient-to-br from-gray-900 to-green-900 text-white">
      <div className="p-8">
        <h1 className="text-4xl font-bold mb-8">
          Baš-Malin - Collecte de Données
        </h1>
        
        <div className="grid grid-cols-4 gap-8 mb-8">
          <BigMetricCard 
            title="Sources Actives"
            value="12"
            icon={<DatabaseIcon />}
            color="green"
          />
          <BigMetricCard 
            title="Données/Heure"
            value="247"
            icon={<TrendingUpIcon />}
            color="blue"
          />
          <BigMetricCard 
            title="Qualité Moyenne"
            value="94%"
            icon={<CheckCircleIcon />}
            color="emerald"
          />
          <BigMetricCard 
            title="Latence Sync"
            value="2.3s"
            icon={<ClockIcon />}
            color="purple"
          />
        </div>
        
        <div className="grid grid-cols-2 gap-8">
          <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-6">
            <h3 className="text-2xl font-semibold mb-4">
              Flux de Données Temps Réel
            </h3>
            <LiveDataStreamVisualization />
          </div>
          
          <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-6">
            <h3 className="text-2xl font-semibold mb-4">
              Santé du Système
            </h3>
            <SystemHealthRadar />
          </div>
        </div>
      </div>
    </div>
  );
};
```

## API Routes

```typescript
// src/app/api/collection/sources/route.ts
export async function GET(request: Request) {
  const sources = await prisma.sourceCollecte.findMany({
    include: {
      derniereCollecte: true,
      metriquesPerformance: true
    }
  });

  return NextResponse.json({
    sources: sources.map(source => ({
      id: source.id,
      type: source.type,
      enabled: source.enabled,
      frequency: source.frequenceMs,
      lastCollection: source.derniereCollecte?.timestamp,
      status: source.derniereCollecte?.status,
      performance: source.metriquesPerformance
    }))
  });
}

export async function POST(request: Request) {
  const body = await request.json();
  
  const source = await prisma.sourceCollecte.create({
    data: {
      type: body.type,
      configuration: body.config,
      frequenceMs: body.frequency,
      enabled: true,
      jardinId: body.gardenId
    }
  });

  // Démarrage automatique de la collecte
  await dataCollectorService.startCollection(source.id);

  return NextResponse.json({ sourceId: source.id });
}

// src/app/api/collection/[sourceId]/route.ts
export async function PATCH(
  request: Request,
  { params }: { params: { sourceId: string } }
) {
  const body = await request.json();
  
  const source = await prisma.sourceCollecte.update({
    where: { id: params.sourceId },
    data: {
      enabled: body.enabled,
      frequenceMs: body.frequency,
      configuration: body.config
    }
  });

  if (body.enabled) {
    await dataCollectorService.startCollection(source.id);
  } else {
    await dataCollectorService.stopCollection(source.id);
  }

  return NextResponse.json({ success: true });
}
```

## Critères d'Acceptation Techniques

### Performance
- [ ] Collecte IoT : < 100ms par capteur
- [ ] Enrichissement IA : < 5s par photo
- [ ] Synchronisation : < 5s entre appareils
- [ ] Stockage : compression intelligente > 70%

### Fiabilité
- [ ] Uptime collecte : > 99.5%
- [ ] Récupération automatique après panne < 30s
- [ ] Gestion gracieuse des timeouts
- [ ] Queue de retry avec backoff exponentiel

### Sécurité
- [ ] Chiffrement données sensibles en transit
- [ ] Validation stricte des données entrantes
- [ ] Audit trail complet des collectes
- [ ] Isolation des sources non fiables

## Couverture Exigences Architecture

- **EXG-001.2** : Architecture modulaire avec collecteurs spécialisés
- **EXG-002.1** : Stockage PostgreSQL optimisé avec index
- **EXG-002.2** : Cache Redis pour accès rapide aux dernières données
- **EXG-003.1** : Interface responsive adaptée à chaque appareil
- **EXG-005.1** : Pipeline d'enrichissement IA avec OpenAI/Claude
- **EXG-005.2** : Analyse automatique des photos et données IoT
- **EXG-006.1** : Intégration Home Assistant pour IoT
- **EXG-007.1** : Synchronisation temps réel multi-device
- **EXG-009.1** : Monitoring avancé des performances de collecte

## Tests d'Acceptation

```typescript
// tests/integration/collection.test.ts
describe('Data Collection System', () => {
  test('collecte automatique IoT fonctionne correctement', async () => {
    const collector = new IoTCollector();
    const config = { gardenId: 'test-garden', deviceTypes: ['temperature', 'humidity'] };
    
    const result = await collector.collect(config);
    
    expect(result.readings).toHaveLength(greaterThan(0));
    expect(result.successfulReadings).toBeGreaterThan(0);
  });

  test('enrichissement IA traite les photos correctement', async () => {
    const pipeline = new EnrichmentPipeline();
    const photoData = { type: 'photo', imageUrl: 'test-image.jpg' };
    
    const enriched = await pipeline.process(photoData);
    
    expect(enriched.enrichments).toContainEqual(
      expect.objectContaining({ type: 'ai_analysis' })
    );
  });

  test('synchronisation multi-device fonctionne sous 5s', async () => {
    const startTime = Date.now();
    
    await dataCollectorService.syncToAllDevices(testCollectionResult);
    
    const syncDuration = Date.now() - startTime;
    expect(syncDuration).toBeLessThan(5000);
  });
});
```

Cette spécification couvre l'ensemble du système de collecte et consolidation automatique, permettant au jardin intelligent de fonctionner de manière autonome tout en enrichissant les données pour fournir des insights précieux à l'utilisateur.