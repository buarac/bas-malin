# F5.1 - Intégration IoT & Capteurs

**Score Priorité :** 80/100  
**Statut :** PRIORITÉ ÉLEVÉE  
**Epic :** EPIC 5 - EXTENSION IoT  
**Effort estimé :** 22 jours  

## Description

Intégration complète de capteurs IoT (ESP32) avec Home Assistant pour monitoring automatique du jardin, collecte de données environnementales temps réel et déclenchement d'actions automatisées basées sur les seuils configurés.

## User Stories

### US5.1.1 - Configuration Capteurs ESP32
**En tant qu'** expert jardinier  
**Je veux** connecter facilement mes capteurs ESP32 au système  
**Afin de** monitorer automatiquement les conditions de mon jardin  

**Critères d'acceptation :**
- Auto-découverte des appareils ESP32 via mDNS
- Configuration Wi-Fi simplifiée via interface web
- Calibrage automatique des capteurs
- Mapping capteurs vers zones de jardin
- Interface de diagnostic et maintenance

### US5.1.2 - Monitoring Temps Réel
**En tant qu'** utilisateur occasionnel  
**Je veux** voir les données de mes capteurs en temps réel  
**Afin de** comprendre l'état actuel de mon jardin  

**Critères d'acceptation :**
- Dashboard temps réel avec métriques visuelles
- Graphiques historiques sur 24h/7j/30j
- Alertes automatiques selon seuils définis
- Corrélation avec données météo externes
- Mode offline avec stockage local

### US5.1.3 - Automatisation Home Assistant
**En tant qu'** utilisateur avancé  
**Je veux** déclencher des actions automatiques via Home Assistant  
**Afin d'** optimiser l'entretien sans intervention manuelle  

**Critères d'acceptation :**
- Intégration native Home Assistant HACS
- Déclenchement automatique arrosage/ventilation
- Scénarios complexes multi-capteurs
- Notifications push via Home Assistant
- Historique des actions automatisées

## Architecture Technique

### Service d'Intégration IoT

```typescript
// src/services/iot/iot-integration.service.ts
import { EventEmitter } from 'events';
import { WebSocket } from 'ws';
import { mDNS } from 'mdns';

export interface IoTDevice {
  id: string;
  name: string;
  type: 'esp32' | 'arduino' | 'raspberry_pi';
  ip: string;
  mac: string;
  version: string;
  capabilities: IoTCapability[];
  location: DeviceLocation;
  status: 'online' | 'offline' | 'error';
  lastSeen: Date;
  config: DeviceConfig;
}

export interface IoTSensor {
  id: string;
  deviceId: string;
  type: SensorType;
  name: string;
  unit: string;
  precision: number;
  range: { min: number; max: number };
  calibration: CalibrationConfig;
  alertThresholds: AlertThreshold[];
}

export interface SensorReading {
  sensorId: string;
  deviceId: string;
  timestamp: Date;
  value: number;
  quality: DataQuality;
  batteryLevel?: number;
  signalStrength?: number;
}

export type SensorType = 
  | 'temperature'
  | 'humidity' 
  | 'soil_moisture'
  | 'light_intensity'
  | 'ph_level'
  | 'conductivity'
  | 'water_level'
  | 'air_pressure'
  | 'wind_speed'
  | 'rain_gauge';

export class IoTIntegrationService extends EventEmitter {
  private devices: Map<string, IoTDevice> = new Map();
  private sensors: Map<string, IoTSensor> = new Map();
  private connections: Map<string, WebSocket> = new Map();
  private discoveryService: DeviceDiscoveryService;
  private homeAssistantService: HomeAssistantIntegrationService;

  constructor(
    private prisma: PrismaClient,
    private redis: Redis,
    private configService: ConfigService
  ) {
    super();
    this.discoveryService = new DeviceDiscoveryService();
    this.homeAssistantService = new HomeAssistantIntegrationService();
    this.initializeDiscovery();
  }

  async initializeDiscovery(): Promise<void> {
    // Auto-découverte mDNS pour ESP32
    this.discoveryService.on('deviceFound', this.handleDeviceDiscovered.bind(this));
    this.discoveryService.startDiscovery();

    // Connexion existants devices
    const existingDevices = await this.loadExistingDevices();
    for (const device of existingDevices) {
      await this.connectToDevice(device);
    }

    // Synchronisation avec Home Assistant
    await this.homeAssistantService.synchronizeDevices();
  }

  private async handleDeviceDiscovered(deviceInfo: DiscoveredDevice): Promise<void> {
    console.log(`Discovered IoT device: ${deviceInfo.name} at ${deviceInfo.ip}`);
    
    try {
      // Vérification si déjà connu
      const existingDevice = await this.prisma.appareilIoT.findFirst({
        where: { adresseMac: deviceInfo.mac }
      });

      if (existingDevice) {
        // Mise à jour IP si changée
        if (existingDevice.adresseIP !== deviceInfo.ip) {
          await this.updateDeviceIP(existingDevice.id, deviceInfo.ip);
        }
        await this.connectToDevice(existingDevice);
      } else {
        // Nouveau device - proposer configuration
        this.emit('newDeviceFound', deviceInfo);
      }
    } catch (error) {
      console.error(`Failed to handle discovered device:`, error);
    }
  }

  async configureNewDevice(deviceInfo: DiscoveredDevice, config: DeviceSetupConfig): Promise<IoTDevice> {
    // Connexion initiale pour configuration
    const setupConnection = await this.establishSetupConnection(deviceInfo.ip);
    
    try {
      // Configuration Wi-Fi et credentials
      await this.configureDeviceNetwork(setupConnection, config.network);
      
      // Configuration capteurs
      const sensors = await this.configureSensors(setupConnection, config.sensors);
      
      // Enregistrement en base
      const device = await this.prisma.appareilIoT.create({
        data: {
          nom: config.name,
          type: deviceInfo.type,
          adresseIP: deviceInfo.ip,
          adresseMac: deviceInfo.mac,
          version: deviceInfo.version,
          statut: 'online',
          configuration: config,
          jardinId: config.gardenId,
          zoneId: config.zoneId
        }
      });

      // Création des capteurs
      for (const sensorConfig of sensors) {
        await this.prisma.capteurIoT.create({
          data: {
            nom: sensorConfig.name,
            type: sensorConfig.type,
            unite: sensorConfig.unit,
            precision: sensorConfig.precision,
            plageMin: sensorConfig.range.min,
            plageMax: sensorConfig.range.max,
            seuilsAlerte: sensorConfig.alertThresholds,
            appareilIoTId: device.id
          }
        });
      }

      // Connexion permanente
      await this.connectToDevice(device);
      
      // Intégration Home Assistant
      await this.homeAssistantService.addDevice(device);

      this.emit('deviceConfigured', device);
      return device;

    } finally {
      setupConnection.close();
    }
  }

  private async connectToDevice(device: IoTDevice): Promise<void> {
    try {
      const ws = new WebSocket(`ws://${device.ip}:81/ws`);
      
      ws.on('open', () => {
        console.log(`Connected to device ${device.name}`);
        this.connections.set(device.id, ws);
        this.devices.set(device.id, { ...device, status: 'online', lastSeen: new Date() });
        
        // Démarrage de la collecte de données
        this.startDataCollection(device.id);
        this.emit('deviceConnected', device);
      });

      ws.on('message', (data) => {
        this.handleDeviceMessage(device.id, data);
      });

      ws.on('close', () => {
        console.log(`Disconnected from device ${device.name}`);
        this.connections.delete(device.id);
        this.devices.set(device.id, { ...device, status: 'offline' });
        this.emit('deviceDisconnected', device);
        
        // Tentative de reconnexion après 30s
        setTimeout(() => this.connectToDevice(device), 30000);
      });

      ws.on('error', (error) => {
        console.error(`WebSocket error for device ${device.name}:`, error);
        this.devices.set(device.id, { ...device, status: 'error' });
        this.emit('deviceError', device, error);
      });

    } catch (error) {
      console.error(`Failed to connect to device ${device.name}:`, error);
      this.devices.set(device.id, { ...device, status: 'error' });
    }
  }

  private async handleDeviceMessage(deviceId: string, data: Buffer): Promise<void> {
    try {
      const message = JSON.parse(data.toString());
      
      switch (message.type) {
        case 'sensor_reading':
          await this.processSensorReading(deviceId, message.data);
          break;
          
        case 'device_status':
          await this.updateDeviceStatus(deviceId, message.data);
          break;
          
        case 'alert':
          await this.handleDeviceAlert(deviceId, message.data);
          break;
          
        default:
          console.warn(`Unknown message type: ${message.type}`);
      }
    } catch (error) {
      console.error(`Failed to process device message:`, error);
    }
  }

  private async processSensorReading(deviceId: string, reading: SensorReading): Promise<void> {
    // Validation de la lecture
    const sensor = this.sensors.get(reading.sensorId);
    if (!sensor) {
      console.warn(`Unknown sensor: ${reading.sensorId}`);
      return;
    }

    const validatedReading = this.validateSensorReading(sensor, reading);
    
    // Stockage en base
    await this.prisma.lectureCapteur.create({
      data: {
        capteurIoTId: reading.sensorId,
        valeur: validatedReading.value,
        qualite: validatedReading.quality,
        timestamp: validatedReading.timestamp,
        niveauBatterie: validatedReading.batteryLevel,
        forceSignal: validatedReading.signalStrength
      }
    });

    // Cache Redis pour accès rapide
    await this.redis.setex(
      `sensor:${reading.sensorId}:latest`,
      300, // 5 minutes TTL
      JSON.stringify(validatedReading)
    );

    // Vérification des seuils d'alerte
    await this.checkAlertThresholds(sensor, validatedReading);

    // Événement pour subscribers
    this.emit('sensorReading', validatedReading);

    // Mise à jour Home Assistant
    await this.homeAssistantService.updateSensorState(reading.sensorId, validatedReading);
  }

  private validateSensorReading(sensor: IoTSensor, reading: SensorReading): SensorReading {
    let quality: DataQuality = 'excellent';
    let value = reading.value;

    // Validation de la plage
    if (value < sensor.range.min || value > sensor.range.max) {
      quality = 'poor';
      console.warn(`Sensor reading out of range: ${value} not in [${sensor.range.min}, ${sensor.range.max}]`);
    }

    // Application de la calibration
    if (sensor.calibration) {
      value = this.applyCalibratedValue(value, sensor.calibration);
    }

    // Vérification de la fraîcheur
    const age = Date.now() - reading.timestamp.getTime();
    if (age > 5 * 60 * 1000) { // 5 minutes
      quality = 'degraded';
    }

    // Vérification niveau batterie
    if (reading.batteryLevel && reading.batteryLevel < 20) {
      quality = 'degraded';
    }

    return {
      ...reading,
      value,
      quality
    };
  }

  private async checkAlertThresholds(sensor: IoTSensor, reading: SensorReading): Promise<void> {
    for (const threshold of sensor.alertThresholds) {
      const isTriggered = this.evaluateThreshold(threshold, reading.value);
      
      if (isTriggered) {
        const alert = {
          id: `iot-${sensor.id}-${threshold.type}-${Date.now()}`,
          type: 'iot_threshold',
          severity: threshold.severity,
          title: `${sensor.name}: ${threshold.message}`,
          message: `Valeur ${reading.value}${sensor.unit} ${threshold.operator} ${threshold.value}${sensor.unit}`,
          source: { type: 'iot', sourceId: sensor.deviceId },
          context: {
            sensorId: sensor.id,
            deviceId: sensor.deviceId,
            reading: reading,
            threshold: threshold
          },
          actions: await this.generateThresholdActions(sensor, threshold, reading),
          createdAt: new Date(),
          status: 'active'
        };

        this.emit('alertTriggered', alert);
      }
    }
  }
}
```

### Intégration Home Assistant

```typescript
// src/services/iot/home-assistant.service.ts
export class HomeAssistantIntegrationService {
  private baseUrl: string;
  private accessToken: string;
  private websocket: WebSocket | null = null;

  constructor(private configService: ConfigService) {
    this.baseUrl = configService.get('HOME_ASSISTANT_URL');
    this.accessToken = configService.get('HOME_ASSISTANT_TOKEN');
    this.initializeWebSocket();
  }

  private async initializeWebSocket(): Promise<void> {
    try {
      const wsUrl = this.baseUrl.replace('http', 'ws') + '/api/websocket';
      this.websocket = new WebSocket(wsUrl);

      this.websocket.on('open', async () => {
        // Authentification
        await this.authenticateWebSocket();
        console.log('Home Assistant WebSocket connected');
      });

      this.websocket.on('message', (data) => {
        this.handleHomeAssistantMessage(JSON.parse(data.toString()));
      });

    } catch (error) {
      console.error('Failed to connect to Home Assistant:', error);
    }
  }

  async addDevice(device: IoTDevice): Promise<void> {
    // Configuration MQTT Discovery pour Home Assistant
    const discoveryConfig = {
      device: {
        identifiers: [device.mac],
        name: device.name,
        model: device.type,
        manufacturer: 'Baš-Malin',
        sw_version: device.version
      },
      availability: {
        topic: `basmalin/device/${device.id}/status`,
        payload_available: 'online',
        payload_not_available: 'offline'
      }
    };

    // Ajout des capteurs
    for (const sensor of device.sensors) {
      const sensorConfig = {
        ...discoveryConfig,
        unique_id: `basmalin_${device.id}_${sensor.type}`,
        name: `${device.name} ${sensor.name}`,
        state_topic: `basmalin/sensor/${sensor.id}/state`,
        unit_of_measurement: sensor.unit,
        device_class: this.mapSensorTypeToDeviceClass(sensor.type),
        value_template: '{{ value_json.value }}',
        json_attributes_topic: `basmalin/sensor/${sensor.id}/attributes`
      };

      await this.publishMQTTDiscovery(`sensor/basmalin_${sensor.id}/config`, sensorConfig);
    }
  }

  async updateSensorState(sensorId: string, reading: SensorReading): Promise<void> {
    // Publication de l'état du capteur
    await this.publishMQTT(`basmalin/sensor/${sensorId}/state`, {
      value: reading.value,
      timestamp: reading.timestamp.toISOString(),
      quality: reading.quality
    });

    // Publication des attributs
    await this.publishMQTT(`basmalin/sensor/${sensorId}/attributes`, {
      battery_level: reading.batteryLevel,
      signal_strength: reading.signalStrength,
      device_id: reading.deviceId,
      last_updated: reading.timestamp.toISOString()
    });
  }

  async createAutomation(config: AutomationConfig): Promise<void> {
    const automation = {
      alias: config.name,
      description: config.description,
      trigger: config.triggers.map(trigger => ({
        platform: 'mqtt',
        topic: `basmalin/sensor/${trigger.sensorId}/state`,
        value_template: '{{ value_json.value | float }}',
        ...(trigger.condition === 'above' && { above: trigger.value }),
        ...(trigger.condition === 'below' && { below: trigger.value })
      })),
      condition: config.conditions || [],
      action: config.actions.map(action => this.mapActionToHomeAssistant(action)),
      mode: 'restart'
    };

    await this.callService('automation.reload', {});
    await this.setConfig(`automation.${config.id}`, automation);
  }

  private mapSensorTypeToDeviceClass(sensorType: SensorType): string {
    const mapping: Record<SensorType, string> = {
      temperature: 'temperature',
      humidity: 'humidity',
      soil_moisture: 'moisture',
      light_intensity: 'illuminance',
      ph_level: '',
      conductivity: '',
      water_level: '',
      air_pressure: 'pressure',
      wind_speed: 'wind_speed',
      rain_gauge: 'precipitation'
    };

    return mapping[sensorType] || '';
  }

  private async publishMQTT(topic: string, payload: any): Promise<void> {
    await this.callService('mqtt.publish', {
      topic,
      payload: JSON.stringify(payload),
      retain: true
    });
  }

  private async callService(service: string, data: any): Promise<any> {
    const response = await fetch(`${this.baseUrl}/api/services/${service.replace('.', '/')}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`Home Assistant API error: ${response.statusText}`);
    }

    return response.json();
  }
}
```

### Interface de Configuration ESP32

```typescript
// src/app/iot/setup/page.tsx
export default function IoTSetupPage() {
  const [discoveredDevices, setDiscoveredDevices] = useState<DiscoveredDevice[]>([]);
  const [setupStep, setSetupStep] = useState<'discover' | 'configure' | 'test'>('discover');
  const [selectedDevice, setSelectedDevice] = useState<DiscoveredDevice | null>(null);

  return (
    <div className="container mx-auto py-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-8">Configuration IoT & Capteurs</h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Étapes de configuration */}
          <div className="lg:col-span-1">
            <SetupSteps currentStep={setupStep} />
          </div>
          
          {/* Contenu principal */}
          <div className="lg:col-span-2">
            {setupStep === 'discover' && (
              <DeviceDiscoveryPanel 
                devices={discoveredDevices}
                onDeviceSelect={setSelectedDevice}
                onNext={() => setSetupStep('configure')}
              />
            )}
            
            {setupStep === 'configure' && selectedDevice && (
              <DeviceConfigurationPanel 
                device={selectedDevice}
                onConfigured={() => setSetupStep('test')}
                onBack={() => setSetupStep('discover')}
              />
            )}
            
            {setupStep === 'test' && selectedDevice && (
              <DeviceTestingPanel 
                device={selectedDevice}
                onComplete={() => router.push('/iot/dashboard')}
              />
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

const DeviceDiscoveryPanel = ({ devices, onDeviceSelect, onNext }: {
  devices: DiscoveredDevice[];
  onDeviceSelect: (device: DiscoveredDevice) => void;
  onNext: () => void;
}) => {
  const [scanning, setScanning] = useState(false);

  const startScan = async () => {
    setScanning(true);
    try {
      await iotService.startDiscovery();
      // Scan pendant 30 secondes
      setTimeout(() => setScanning(false), 30000);
    } catch (error) {
      console.error('Discovery failed:', error);
      setScanning(false);
    }
  };

  return (
    <Card className="p-6">
      <CardHeader>
        <CardTitle className="flex items-center">
          <WifiIcon className="w-6 h-6 mr-2" />
          Découverte des Appareils
        </CardTitle>
        <CardDescription>
          Recherche automatique des capteurs ESP32 sur votre réseau
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-4">
        <div className="flex justify-between items-center">
          <span className="text-sm text-gray-600">
            {devices.length} appareil(s) découvert(s)
          </span>
          <Button 
            onClick={startScan} 
            disabled={scanning}
            leftIcon={scanning ? <Loader2Icon className="animate-spin" /> : <SearchIcon />}
          >
            {scanning ? 'Scan en cours...' : 'Démarrer le scan'}
          </Button>
        </div>
        
        <div className="space-y-2">
          {devices.map(device => (
            <DeviceCard
              key={device.mac}
              device={device}
              onSelect={() => onDeviceSelect(device)}
            />
          ))}
        </div>
        
        {devices.length > 0 && (
          <Button onClick={onNext} className="w-full mt-4">
            Continuer avec l'appareil sélectionné
          </Button>
        )}
      </CardContent>
    </Card>
  );
};

const DeviceConfigurationPanel = ({ device, onConfigured }: {
  device: DiscoveredDevice;
  onConfigured: () => void;
}) => {
  const [config, setConfig] = useState<DeviceSetupConfig>({
    name: device.name,
    gardenId: '',
    zoneId: '',
    network: {
      ssid: '',
      password: ''
    },
    sensors: []
  });

  return (
    <Card className="p-6">
      <CardHeader>
        <CardTitle>Configuration de {device.name}</CardTitle>
        <CardDescription>
          Paramétrage des capteurs et connexion réseau
        </CardDescription>
      </CardHeader>
      
      <CardContent>
        <DeviceConfigForm 
          device={device}
          config={config}
          onChange={setConfig}
          onSubmit={onConfigured}
        />
      </CardContent>
    </Card>
  );
};
```

## Dashboard IoT Temps Réel

```typescript
// src/app/iot/dashboard/page.tsx
export default function IoTDashboardPage() {
  const { devices, sensors, readings } = useIoTData();
  const { deviceType } = useResponsive();

  if (deviceType === 'tv') {
    return <IoTDashboardTV devices={devices} sensors={sensors} readings={readings} />;
  }

  return (
    <div className="container mx-auto py-6">
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Sidebar devices */}
        <div className="lg:col-span-1">
          <DevicesList devices={devices} />
        </div>
        
        {/* Main dashboard */}
        <div className="lg:col-span-3 space-y-6">
          <SensorsOverview sensors={sensors} readings={readings} />
          <RealtimeCharts readings={readings} />
          <AlertsPanel />
        </div>
      </div>
    </div>
  );
}

const SensorsOverview = ({ sensors, readings }: {
  sensors: IoTSensor[];
  readings: Map<string, SensorReading>;
}) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {sensors.map(sensor => {
        const latestReading = readings.get(sensor.id);
        return (
          <SensorCard
            key={sensor.id}
            sensor={sensor}
            reading={latestReading}
          />
        );
      })}
    </div>
  );
};

const SensorCard = ({ sensor, reading }: {
  sensor: IoTSensor;
  reading?: SensorReading;
}) => {
  const getStatusColor = (quality?: DataQuality) => {
    switch (quality) {
      case 'excellent': return 'text-green-600';
      case 'good': return 'text-blue-600';
      case 'degraded': return 'text-yellow-600';
      case 'poor': return 'text-red-600';
      default: return 'text-gray-400';
    }
  };

  return (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-3">
        <div>
          <h3 className="font-semibold">{sensor.name}</h3>
          <p className="text-sm text-gray-600">{sensor.type}</p>
        </div>
        {reading && (
          <Badge 
            variant="outline" 
            className={getStatusColor(reading.quality)}
          >
            {reading.quality}
          </Badge>
        )}
      </div>
      
      {reading ? (
        <div>
          <div className="text-2xl font-bold">
            {reading.value.toFixed(sensor.precision)}{sensor.unit}
          </div>
          <p className="text-xs text-gray-500">
            <TimeAgo date={reading.timestamp} />
          </p>
          
          {reading.batteryLevel && (
            <div className="flex items-center mt-2 text-xs">
              <BatteryIcon className="w-3 h-3 mr-1" />
              {reading.batteryLevel}%
            </div>
          )}
        </div>
      ) : (
        <div className="text-gray-400">
          <div className="text-lg">--</div>
          <p className="text-xs">Pas de données</p>
        </div>
      )}
    </Card>
  );
};
```

## API Routes

```typescript
// src/app/api/iot/devices/route.ts
export async function GET() {
  const devices = await prisma.appareilIoT.findMany({
    include: {
      capteurs: {
        include: {
          dernieresLectures: {
            orderBy: { timestamp: 'desc' },
            take: 1
          }
        }
      },
      zone: true
    }
  });

  return NextResponse.json({
    devices: devices.map(device => ({
      id: device.id,
      name: device.nom,
      type: device.type,
      ip: device.adresseIP,
      status: device.statut,
      lastSeen: device.derniereSynchr,
      sensors: device.capteurs.map(sensor => ({
        id: sensor.id,
        type: sensor.type,
        name: sensor.nom,
        unit: sensor.unite,
        latestReading: sensor.dernieresLectures[0]
      }))
    }))
  });
}

// src/app/api/iot/sensors/[sensorId]/readings/route.ts
export async function GET(
  request: Request,
  { params }: { params: { sensorId: string } }
) {
  const { searchParams } = new URL(request.url);
  const period = searchParams.get('period') || '24h';
  const aggregation = searchParams.get('aggregation') || 'raw';

  const readings = await prisma.lectureCapteur.findMany({
    where: {
      capteurIoTId: params.sensorId,
      timestamp: {
        gte: new Date(Date.now() - parsePeriod(period))
      }
    },
    orderBy: { timestamp: 'desc' }
  });

  let processedReadings = readings;
  
  if (aggregation !== 'raw') {
    processedReadings = aggregateReadings(readings, aggregation);
  }

  return NextResponse.json({ readings: processedReadings });
}
```

## Critères d'Acceptation Techniques

### Connectivité
- [ ] Auto-découverte ESP32 < 30s
- [ ] Reconnexion automatique après perte réseau
- [ ] Support multi-protocoles (Wi-Fi, LoRa, Zigbee)
- [ ] Latence lecture capteur < 5s

### Fiabilité
- [ ] Uptime connexions IoT > 95%
- [ ] Buffer local en cas de perte connexion
- [ ] Détection anomalies automatique
- [ ] Calibrage auto des dérives capteurs

### Intégration
- [ ] Home Assistant HACS compliant
- [ ] MQTT Discovery automatique
- [ ] API REST complète pour intégrations tierces
- [ ] Webhooks pour événements temps réel

## Couverture Exigences Architecture

- **EXG-006.1** : Intégration Home Assistant native
- **EXG-006.2** : Support ESP32 avec auto-découverte
- **EXG-002.1** : Stockage optimisé données temporelles
- **EXG-007.1** : Synchronisation temps réel
- **EXG-009.1** : Monitoring complet des devices IoT

## Tests d'Acceptation

```typescript
// tests/integration/iot.test.ts
describe('IoT Integration', () => {
  test('découverte automatique ESP32 fonctionne', async () => {
    const mockDevice = createMockESP32Device();
    
    iotService.startDiscovery();
    
    await waitFor(() => {
      expect(iotService.getDiscoveredDevices()).toContain(
        expect.objectContaining({ mac: mockDevice.mac })
      );
    });
  });

  test('configuration device persiste correctement', async () => {
    const deviceConfig = createMockDeviceConfig();
    
    const device = await iotService.configureNewDevice(mockDevice, deviceConfig);
    
    expect(device.id).toBeDefined();
    expect(device.status).toBe('online');
  });

  test('lecture capteur déclenche alertes', async () => {
    const sensor = await createTestSensor();
    const alertTriggeredSpy = jest.fn();
    
    iotService.on('alertTriggered', alertTriggeredSpy);
    
    await iotService.processSensorReading(sensor.deviceId, {
      sensorId: sensor.id,
      value: 45, // Au-dessus du seuil d'alerte
      timestamp: new Date()
    });
    
    expect(alertTriggeredSpy).toHaveBeenCalled();
  });
});
```

Cette spécification couvre l'intégration complète des capteurs IoT avec Home Assistant, permettant un monitoring automatique et intelligent du jardin avec déclenchement d'actions automatisées.