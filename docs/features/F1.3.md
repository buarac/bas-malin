# **F1.3 - Base de Donn√©es & Mod√®les Core**

## **üìã Informations g√©n√©rales**
- **Score de priorit√©** : 90/100 ‚≠ê PRIORIT√â √âLEV√âE
- **EPIC** : FONDATIONS
- **Complexit√©** : √âlev√©e (mod√©lisation domaine complexe)
- **Devices** : Backend (tous devices)

## **üéØ Description**
Structure compl√®te de donn√©es pour l'√©cosyst√®me potager intelligent, int√©grant NextAuth.js avec extensions m√©tier Ba≈°-Malin, mod√®les extensibles et versionn√©s, performance optimis√©e pour PostgreSQL + Prisma, et pr√©paration pour IA et IoT futurs.

## **üë• User Stories**

### **Syst√®me de donn√©es**
- En tant que syst√®me, je dois stocker et organiser toutes les donn√©es jardin de mani√®re coh√©rente et performante
- En tant que syst√®me, je dois garantir l'int√©grit√© r√©f√©rentielle et la coh√©rence des donn√©es
- En tant que syst√®me, je dois supporter l'√©volution du schema sans perte de donn√©es

### **D√©veloppeur**
- En tant que d√©veloppeur, je veux des mod√®les TypeScript type-safe g√©n√©r√©s automatiquement
- En tant que d√©veloppeur, je veux des queries optimis√©es pour les cas d'usage courants
- En tant que d√©veloppeur, je veux une architecture extensible pour futures fonctionnalit√©s

### **Performance & Analytics**
- En tant qu'utilisateur, je veux des temps de r√©ponse < 2s m√™me avec des ann√©es de donn√©es
- En tant qu'analyste IA, je veux des structures optimis√©es pour machine learning
- En tant qu'administrateur, je veux des outils de monitoring et maintenance

## **üóÑÔ∏è Architecture de donn√©es**

### **Configuration Prisma optimis√©e**
```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
  engineType = "binary"
  previewFeatures = ["postgresqlExtensions", "views", "multiSchema"]
}

generator typegraphql {
  provider = "typegraphql-prisma"
  output   = "../src/generated/typegraphql"
  emitIdAsIDType = true
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [postgis, pg_stat_statements, pg_trgm]
}

// Configuration pour performance
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  image         String?
  
  // Extensions Ba≈°-Malin avec optimisations
  passwordHash  String    @db.VarChar(255)
  typeProfil    TypeProfil @default(OCCASIONNEL)
  prenom        String?   @db.VarChar(100)
  nom           String?   @db.VarChar(100)
  locale        String    @default("fr-FR") @db.VarChar(10)
  
  // JSON optimis√© avec index GIN
  preferences   Json?     @db.JsonB
  
  derniereConnexionA DateTime?
  creeA             DateTime  @default(now()) @db.Timestamptz
  misAJourA         DateTime  @updatedAt @db.Timestamptz
  supprimeA         DateTime? @db.Timestamptz // Soft delete
  
  // Relations avec foreign keys optimis√©s
  accounts Account[]
  sessions Session[]
  jardins  Jardin[]
  
  // Index composites pour performance
  @@index([email, supprimeA])
  @@index([typeProfil, creeA])
  @@index([derniereConnexionA])
  @@map("users")
}

// Mod√®le Jardin avec g√©ospatial
model Jardin {
  id              String @id @default(cuid())
  proprietaireId  String
  nom             String @db.VarChar(200)
  description     String? @db.Text
  
  // G√©olocalisation avec PostGIS
  coordonnees     Unsupported("POINT")?  // PostGIS POINT type
  localisation    Json   @db.JsonB       // Backup JSON si PostGIS indisponible
  
  // M√©triques num√©riques optimis√©es
  surfaceTotaleM2 Decimal @db.Decimal(10,2)
  typeSol         TypeSol
  phSol           Decimal? @db.Decimal(3,1)
  
  // Configuration sp√©cifique avec validation JSON Schema
  configAmenagement Json @db.JsonB // Valid√© par JSON Schema
  
  creeA       DateTime @default(now()) @db.Timestamptz
  misAJourA   DateTime @updatedAt @db.Timestamptz
  
  // Relations optimis√©es
  proprietaire    User @relation(fields: [proprietaireId], references: [id], onDelete: Cascade)
  zones           Zone[]
  donneesMeteo    DonneeMeteo[]
  
  // Index sp√©cialis√©s
  @@index([proprietaireId, creeA])
  @@index([coordonnees], type: Gist) // Index spatial PostGIS
  @@map("jardins")
}

// Mod√®le Zone avec contraintes g√©om√©triques
model Zone {
  id          String @id @default(cuid())
  jardinId    String
  nom         String @db.VarChar(100)
  typeZone    TypeZone
  
  // G√©om√©trie avec validation PostGIS
  geometrie   Json @db.JsonB // {type: "polygone", coordonnees: [[lat,lng]], surfaceM2}
  
  // √âtat et m√©triques
  expositionSoleil ExpositionSoleil
  accesEau        AccesEau
  qualiteSol      Int @db.SmallInt // 1-5, plus efficace que Integer
  
  estActive            Boolean @default(true)
  cultureActuelleId    String?
  
  creeA       DateTime @default(now()) @db.Timestamptz
  misAJourA   DateTime @updatedAt @db.Timestamptz
  
  // Relations avec contraintes
  jardin              Jardin @relation(fields: [jardinId], references: [id], onDelete: Cascade)
  cultureActuelle     InstanceCulture? @relation("ZoneCultureActuelle", fields: [cultureActuelleId], references: [id])
  instancesCulture    InstanceCulture[] @relation("ZoneInstancesCulture")
  
  // Index pour queries spatiales et temporelles
  @@index([jardinId, typeZone])
  @@index([estActive, cultureActuelleId])
  @@map("zones")
}
```

### **Syst√®me de versioning et migrations**
```sql
-- Migration versioning table
CREATE TABLE IF NOT EXISTS schema_versions (
  version VARCHAR(20) PRIMARY KEY,
  applied_at TIMESTAMPTZ DEFAULT NOW(),
  description TEXT,
  migration_hash VARCHAR(64)
);

-- Function pour audit automatique
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.cree_a = NOW();
    NEW.mis_a_jour_a = NOW();
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    NEW.mis_a_jour_a = NOW();
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Triggers automatiques sur tous les mod√®les
CREATE TRIGGER audit_users 
  BEFORE INSERT OR UPDATE ON users
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_jardins
  BEFORE INSERT OR UPDATE ON jardins  
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- Contraintes de donn√©es m√©tier
ALTER TABLE zones ADD CONSTRAINT check_qualite_sol_valid 
  CHECK (qualite_sol >= 1 AND qualite_sol <= 5);

ALTER TABLE jardins ADD CONSTRAINT check_surface_positive
  CHECK (surface_totale_m2 > 0);

ALTER TABLE jardins ADD CONSTRAINT check_ph_sol_valid
  CHECK (ph_sol IS NULL OR (ph_sol >= 3.0 AND ph_sol <= 9.0));
```

### **Service de donn√©es avec optimisations**
```typescript
export class DataService {
  private prisma: PrismaClient;
  private cache: RedisCache;
  
  constructor() {
    this.prisma = new PrismaClient({
      log: ['query', 'info', 'warn', 'error'],
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
    });
    
    // Middleware pour logging automatique des queries lentes
    this.prisma.$use(async (params, next) => {
      const start = Date.now();
      const result = await next(params);
      const duration = Date.now() - start;
      
      if (duration > 1000) { // Log queries > 1s
        console.warn(`Slow query detected: ${params.model}.${params.action} - ${duration}ms`);
      }
      
      return result;
    });
    
    this.cache = new RedisCache();
  }

  // Repository pattern pour isolation
  get users() {
    return new UserRepository(this.prisma, this.cache);
  }
  
  get jardins() {
    return new JardinRepository(this.prisma, this.cache);
  }
  
  get zones() {
    return new ZoneRepository(this.prisma, this.cache);
  }

  // Transaction wrapper avec retry logic
  async transaction<T>(
    fn: (prisma: PrismaTransactionClient) => Promise<T>,
    options: { maxRetries: number = 3, timeout: number = 10000 } = {}
  ): Promise<T> {
    let retries = 0;
    
    while (retries <= options.maxRetries) {
      try {
        return await this.prisma.$transaction(fn, {
          timeout: options.timeout,
          isolationLevel: 'ReadCommitted'
        });
      } catch (error) {
        retries++;
        
        if (retries > options.maxRetries) {
          throw error;
        }
        
        // Exponential backoff
        const delay = Math.min(1000 * Math.pow(2, retries), 5000);
        await new Promise(resolve => setTimeout(resolve, delay));
        
        console.warn(`Transaction retry ${retries}/${options.maxRetries} after ${delay}ms`);
      }
    }
    
    throw new Error('Transaction failed after maximum retries');
  }

  // Health check pour monitoring
  async healthCheck(): Promise<DatabaseHealth> {
    try {
      const start = Date.now();
      
      // Test basic connectivity
      await this.prisma.$queryRaw`SELECT 1 as health`;
      
      // Test read performance
      const userCount = await this.prisma.user.count();
      
      const duration = Date.now() - start;
      
      return {
        status: 'healthy',
        responseTimeMs: duration,
        userCount,
        timestamp: new Date()
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date()
      };
    }
  }
}

interface DatabaseHealth {
  status: 'healthy' | 'unhealthy';
  responseTimeMs?: number;
  userCount?: number;
  error?: string;
  timestamp: Date;
}
```

### **Repository pattern avec cache intelligent**
```typescript
export class JardinRepository {
  constructor(
    private prisma: PrismaClient,
    private cache: RedisCache
  ) {}

  async findByUserId(userId: string): Promise<JardinWithZones[]> {
    const cacheKey = `jardins:user:${userId}`;
    
    // Check cache first
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return cached;
    }

    // Optimized query with includes
    const jardins = await this.prisma.jardin.findMany({
      where: { 
        proprietaireId: userId,
        supprimeA: null // Soft delete filter
      },
      include: {
        zones: {
          where: { estActive: true },
          include: {
            cultureActuelle: {
              include: {
                variete: true
              }
            }
          },
          orderBy: { nom: 'asc' }
        },
        _count: {
          select: {
            zones: true,
            donneesMeteo: true
          }
        }
      },
      orderBy: { creeA: 'desc' }
    });

    // Cache for 5 minutes
    await this.cache.set(cacheKey, jardins, 300);
    
    return jardins;
  }

  async create(data: CreateJardinInput): Promise<Jardin> {
    // Validate input data
    const validatedData = await this.validateJardinData(data);
    
    return this.prisma.jardin.create({
      data: {
        ...validatedData,
        // Generate initial zones based on config
        zones: {
          create: this.generateInitialZones(validatedData.configAmenagement)
        }
      },
      include: {
        zones: true,
        proprietaire: {
          select: {
            id: true,
            prenom: true,
            nom: true
          }
        }
      }
    });
  }

  async updateWithZones(
    jardinId: string, 
    updates: UpdateJardinInput
  ): Promise<Jardin> {
    return this.prisma.$transaction(async (tx) => {
      // Update jardin
      const updatedJardin = await tx.jardin.update({
        where: { id: jardinId },
        data: updates,
      });

      // Update zones if geometry changed
      if (updates.configAmenagement) {
        await this.updateZonesFromConfig(tx, jardinId, updates.configAmenagement);
      }

      // Invalidate cache
      await this.cache.del(`jardins:user:${updatedJardin.proprietaireId}`);
      
      return updatedJardin;
    });
  }

  // Geospatial queries optimis√©es
  async findNearby(
    coordinates: { latitude: number; longitude: number },
    radiusKm: number = 10
  ): Promise<Jardin[]> {
    // Using PostGIS for efficient spatial queries
    return this.prisma.$queryRaw<Jardin[]>`
      SELECT j.*,
             ST_Distance(
               ST_GeogFromText(CONCAT('POINT(', $1, ' ', $2, ')')),
               coordonnees
             ) / 1000 as distance_km
      FROM jardins j
      WHERE ST_DWithin(
        coordonnees,
        ST_GeogFromText(CONCAT('POINT(', $1, ' ', $2, ')')),
        ${radiusKm * 1000}
      )
      AND supprime_a IS NULL
      ORDER BY distance_km ASC
      LIMIT 20
    `;
  }

  private async validateJardinData(data: CreateJardinInput): Promise<ValidatedJardinData> {
    // JSON Schema validation pour configAmenagement
    const configSchema = {
      type: 'object',
      required: ['type', 'contenants'],
      properties: {
        type: { type: 'string', enum: ['structure', 'libre'] },
        contenants: {
          type: 'array',
          items: {
            type: 'object',
            required: ['id', 'longueur_m', 'largeur_m'],
            properties: {
              id: { type: 'string' },
              longueur_m: { type: 'number', minimum: 0.1, maximum: 50 },
              largeur_m: { type: 'number', minimum: 0.1, maximum: 10 },
              position: {
                type: 'object',
                properties: {
                  x: { type: 'number' },
                  y: { type: 'number' }
                }
              }
            }
          }
        }
      }
    };

    const validator = ajv.compile(configSchema);
    const isValid = validator(data.configAmenagement);
    
    if (!isValid) {
      throw new ValidationError('Invalid configAmenagement', validator.errors);
    }

    return data;
  }

  private generateInitialZones(config: any): Prisma.ZoneCreateWithoutJardinInput[] {
    if (!config.contenants) return [];

    return config.contenants.map((contenant: any, index: number) => ({
      nom: contenant.nom || `Bac ${index + 1}`,
      typeZone: contenant.type === 'bac' ? 'BAC' : 'PARCELLE',
      geometrie: {
        type: 'rectangle',
        longueur_m: contenant.longueur_m,
        largeur_m: contenant.largeur_m,
        position: contenant.position || { x: 0, y: index * 1 },
        surfaceM2: contenant.longueur_m * contenant.largeur_m
      },
      expositionSoleil: 'PLEIN_SOLEIL', // Default
      accesEau: 'FACILE',
      qualiteSol: 3 // Default moyen
    }));
  }
}

export class UserRepository {
  constructor(
    private prisma: PrismaClient,
    private cache: RedisCache
  ) {}

  async findByEmail(email: string): Promise<UserWithPreferences | null> {
    const cacheKey = `user:email:${email}`;
    
    const cached = await this.cache.get(cacheKey);
    if (cached) return cached;

    const user = await this.prisma.user.findUnique({
      where: { 
        email,
        supprimeA: null 
      },
      include: {
        jardins: {
          select: {
            id: true,
            nom: true,
            creeA: true
          }
        },
        _count: {
          select: {
            jardins: true,
            sessions: true
          }
        }
      }
    });

    if (user) {
      await this.cache.set(cacheKey, user, 600); // 10min cache
    }
    
    return user;
  }

  async updateLastConnection(userId: string): Promise<void> {
    await this.prisma.user.update({
      where: { id: userId },
      data: { derniereConnexionA: new Date() }
    });

    // Invalidate user cache
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: { email: true }
    });
    
    if (user) {
      await this.cache.del(`user:email:${user.email}`);
    }
  }

  // Analytics optimis√©es
  async getUserStats(userId: string): Promise<UserStats> {
    const cacheKey = `user:stats:${userId}`;
    const cached = await this.cache.get(cacheKey);
    
    if (cached) return cached;

    // Single query with aggregations for performance
    const stats = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        _count: {
          select: {
            jardins: true
          }
        },
        jardins: {
          select: {
            _count: {
              select: {
                zones: true,
                donneesMeteo: true
              }
            },
            zones: {
              select: {
                _count: {
                  select: {
                    instancesCulture: true,
                    recoltes: true
                  }
                }
              }
            }
          }
        }
      }
    });

    const aggregatedStats: UserStats = {
      totalJardins: stats._count.jardins,
      totalZones: stats.jardins.reduce((sum, j) => sum + j._count.zones, 0),
      totalCultures: stats.jardins.reduce((sum, j) => 
        sum + j.zones.reduce((zoneSum, z) => zoneSum + z._count.instancesCulture, 0), 0
      ),
      totalRecoltes: stats.jardins.reduce((sum, j) => 
        sum + j.zones.reduce((zoneSum, z) => zoneSum + z._count.recoltes, 0), 0
      ),
      calculatedAt: new Date()
    };

    await this.cache.set(cacheKey, aggregatedStats, 3600); // 1h cache
    
    return aggregatedStats;
  }
}

interface UserStats {
  totalJardins: number;
  totalZones: number;  
  totalCultures: number;
  totalRecoltes: number;
  calculatedAt: Date;
}
```

## **üîç Vues m√©tier pour analytics**

### **Vues PostgreSQL optimis√©es**
```sql
-- Vue dashboard principal (F3.2)
CREATE OR REPLACE VIEW v_dashboard_principal AS
SELECT 
  u.id as utilisateur_id,
  u.prenom || ' ' || COALESCE(u.nom, '') as nom_complet,
  u.type_profil,
  u.derniere_connexion_a,
  
  -- Comptes par entit√©
  COUNT(DISTINCT j.id) as nombre_jardins,
  COUNT(DISTINCT z.id) as nombre_zones_actives,
  COUNT(DISTINCT ic.id) FILTER (WHERE ic.est_active = true) as cultures_actives,
  COUNT(DISTINCT r.id) FILTER (WHERE r.date_recolte >= CURRENT_DATE - INTERVAL '1 year') as recoltes_annee,
  
  -- M√©triques agr√©g√©es
  COALESCE(SUM(r.poids_total_kg) FILTER (WHERE r.date_recolte >= CURRENT_DATE - INTERVAL '1 year'), 0) as rendement_total_kg_annee,
  ROUND(AVG((r.evaluation_qualite->>'noteGenerale')::numeric) FILTER (WHERE r.date_recolte >= CURRENT_DATE - INTERVAL '1 year'), 2) as qualite_moyenne,
  COUNT(DISTINCT i.id) FILTER (WHERE i.date_reelle >= CURRENT_DATE - INTERVAL '1 year') as interventions_annee,
  
  -- Derni√®re activit√©  
  GREATEST(
    MAX(r.date_recolte),
    MAX(i.date_reelle),
    u.derniere_connexion_a
  ) as derniere_activite

FROM users u
LEFT JOIN jardins j ON j.proprietaire_id = u.id AND j.supprime_a IS NULL
LEFT JOIN zones z ON z.jardin_id = j.id AND z.est_active = true
LEFT JOIN instances_culture ic ON ic.zone_id = z.id
LEFT JOIN recoltes r ON r.instance_culture_id = ic.id
LEFT JOIN interventions i ON i.instance_culture_id = ic.id

WHERE u.supprime_a IS NULL
GROUP BY u.id, u.prenom, u.nom, u.type_profil, u.derniere_connexion_a;

-- Index pour performance de la vue
CREATE INDEX CONCURRENTLY idx_dashboard_performance ON recoltes(instance_culture_id, date_recolte DESC);
CREATE INDEX CONCURRENTLY idx_dashboard_interventions ON interventions(instance_culture_id, date_reelle DESC);

-- Vue calendrier cultural optimis√©e (F2.2)
CREATE OR REPLACE VIEW v_calendrier_cultural AS
SELECT 
  ic.id,
  ic.nom as nom_culture,
  vc.nom_commun as nom_variete,
  vc.famille,
  z.nom as nom_zone,
  j.nom as nom_jardin,
  ic.etape_cycle_vie,
  ic.annee_saison,
  
  -- Dates cl√©s
  ic.date_semis_prevue,
  ic.date_semis_reelle,
  ic.date_repiquage_prevue, 
  ic.date_repiquage_reelle,
  ic.date_premiere_recolte,
  ic.date_derniere_recolte,
  
  -- M√©triques de performance
  ic.quantite_plantee,
  ic.quantite_germee,
  ic.taux_survie,
  
  -- Pr√©dictions IA si disponibles
  ic.predictions_ia->>'rendementAttenduKg' as rendement_predit_kg,
  ic.predictions_ia->>'fenetreRecolteOptimale' as fenetre_recolte_optimale,
  
  -- Calculs d√©riv√©s
  EXTRACT(DOY FROM ic.date_semis_prevue) as jour_annee_semis,
  CASE 
    WHEN ic.date_semis_reelle IS NOT NULL AND ic.date_premiere_recolte IS NOT NULL 
    THEN ic.date_premiere_recolte - ic.date_semis_reelle
    ELSE NULL
  END as duree_semis_recolte_jours,
  
  -- √âtat actuel
  ic.est_active,
  CASE
    WHEN ic.date_derniere_recolte < CURRENT_DATE - INTERVAL '7 days' THEN 'TERMINE'
    WHEN ic.date_premiere_recolte IS NOT NULL THEN 'EN_RECOLTE'
    WHEN ic.date_repiquage_reelle IS NOT NULL THEN 'REPIQUE'
    WHEN ic.date_semis_reelle IS NOT NULL THEN 'SEME'
    ELSE 'PLANIFIE'
  END as statut_derive

FROM instances_culture ic
JOIN varietes_culture_utilisateur vcu ON vcu.id = ic.variete_id
JOIN varietes_culture vc ON vc.id = vcu.variete_base_id
JOIN zones z ON z.id = ic.zone_id
JOIN jardins j ON j.id = z.jardin_id

WHERE ic.annee_saison >= EXTRACT(year FROM CURRENT_DATE) - 1 -- 2 derni√®res ann√©es
ORDER BY ic.date_semis_prevue DESC, ic.date_semis_reelle DESC;

-- Vue analytics r√©coltes (F3.3)
CREATE OR REPLACE VIEW v_analytics_recoltes AS
SELECT 
  DATE_TRUNC('month', r.date_recolte) as mois,
  DATE_TRUNC('week', r.date_recolte) as semaine,
  ic.utilisateur_id,
  j.id as jardin_id,
  j.nom as jardin_nom,
  z.id as zone_id,
  z.nom as zone_nom,
  vc.id as variete_id,
  vc.nom_commun as variete_nom,
  vc.famille as variete_famille,
  vc.categorie as variete_categorie,
  
  -- Agr√©gations quantitatives
  COUNT(*) as nombre_recoltes,
  SUM(r.poids_total_kg) as poids_total_kg,
  AVG(r.poids_total_kg) as poids_moyen_kg,
  MIN(r.poids_total_kg) as poids_min_kg,
  MAX(r.poids_total_kg) as poids_max_kg,
  STDDEV(r.poids_total_kg) as poids_stddev_kg,
  
  -- M√©triques qualit√©
  AVG((r.evaluation_qualite->>'noteGenerale')::numeric) as qualite_moyenne,
  AVG((r.evaluation_qualite->>'noteTaille')::numeric) as taille_moyenne,
  AVG((r.evaluation_qualite->>'noteGout')::numeric) as gout_moyen,
  AVG((r.evaluation_qualite->>'noteApparence')::numeric) as apparence_moyenne,
  
  -- M√©triques √©conomiques
  SUM(r.valeur_marche_estimee) as valeur_totale_estimee,
  AVG(r.valeur_marche_estimee / NULLIF(r.poids_total_kg, 0)) as prix_kg_moyen,
  
  -- IA et technologie
  AVG((r.reconnaissance_ia->>'scoreConfiance')::numeric) FILTER (WHERE r.reconnaissance_ia IS NOT NULL) as precision_ia_moyenne,
  COUNT(*) FILTER (WHERE r.reconnaissance_ia IS NOT NULL) as recoltes_avec_ia,
  
  -- G√©ographie
  AVG((r.localisation_recolte->>'latitude')::numeric) as latitude_moyenne,
  AVG((r.localisation_recolte->>'longitude')::numeric) as longitude_moyenne,
  
  -- Temporelles
  MIN(r.date_recolte) as premiere_recolte,
  MAX(r.date_recolte) as derniere_recolte,
  MAX(r.date_recolte) - MIN(r.date_recolte) as periode_recolte_jours

FROM recoltes r
JOIN instances_culture ic ON ic.id = r.instance_culture_id
JOIN varietes_culture_utilisateur vcu ON vcu.id = ic.variete_id
JOIN varietes_culture vc ON vc.id = vcu.variete_base_id
JOIN zones z ON z.id = r.zone_id
JOIN jardins j ON j.id = z.jardin_id

WHERE r.date_recolte >= CURRENT_DATE - INTERVAL '3 years' -- 3 ans d'historique
GROUP BY 
  DATE_TRUNC('month', r.date_recolte),
  DATE_TRUNC('week', r.date_recolte),
  ic.utilisateur_id, j.id, j.nom, z.id, z.nom,
  vc.id, vc.nom_commun, vc.famille, vc.categorie

ORDER BY mois DESC, poids_total_kg DESC;

-- Index pour performance des vues analytics
CREATE INDEX CONCURRENTLY idx_recoltes_analytics ON recoltes(date_recolte DESC, zone_id, instance_culture_id);
CREATE INDEX CONCURRENTLY idx_instances_culture_analytics ON instances_culture(utilisateur_id, variete_id, zone_id);
```

### **Fonctions PostgreSQL pour calculs complexes**
```sql
-- Fonction de calcul de rotation optimale
CREATE OR REPLACE FUNCTION calculer_score_rotation(
  zone_id_param UUID,
  variete_famille_param VARCHAR,
  annee_cible INTEGER
) RETURNS DECIMAL AS $$
DECLARE
  historique_familles TEXT[];
  score DECIMAL := 10.0;
  famille_count INTEGER;
BEGIN
  -- R√©cup√©rer historique des 4 derni√®res ann√©es
  SELECT ARRAY_AGG(DISTINCT vc.famille)
  INTO historique_familles
  FROM instances_culture ic
  JOIN varietes_culture_utilisateur vcu ON vcu.id = ic.variete_id
  JOIN varietes_culture vc ON vc.id = vcu.variete_base_id
  WHERE ic.zone_id = zone_id_param
    AND ic.annee_saison BETWEEN (annee_cible - 4) AND (annee_cible - 1)
    AND ic.est_active = true;

  -- Calculer p√©nalit√©s de rotation
  SELECT COUNT(*)
  INTO famille_count
  FROM unnest(historique_familles) AS famille
  WHERE famille = variete_famille_param;

  -- P√©nalit√©s selon r√©p√©tition famille
  CASE famille_count
    WHEN 0 THEN score := 10.0;  -- Parfait, nouvelle famille
    WHEN 1 THEN score := 8.0;   -- Bon, 1 occurence
    WHEN 2 THEN score := 5.0;   -- Moyen, 2 occurences  
    WHEN 3 THEN score := 2.0;   -- Mauvais, 3 occurences
    ELSE score := 0.0;          -- Tr√®s mauvais, 4+ occurences
  END CASE;

  -- Bonus pour familles b√©n√©fiques
  IF variete_famille_param = 'Fabaceae' AND 'Solanaceae' = ANY(historique_familles) THEN
    score := score + 1.0; -- L√©gumineuses apr√®s solanac√©es = bonus azote
  END IF;

  RETURN GREATEST(0.0, LEAST(10.0, score));
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Fonction de calcul ET0 (√©vapotranspiration)
CREATE OR REPLACE FUNCTION calculer_et0(
  temperature_c DECIMAL,
  humidite_pourcent INTEGER,
  vitesse_vent_kmh DECIMAL,
  rayonnement_solaire DECIMAL DEFAULT NULL
) RETURNS DECIMAL AS $$
DECLARE
  et0 DECIMAL;
  pente_tension_vapeur DECIMAL;
  tension_vapeur_sat DECIMAL;
  tension_vapeur_actuelle DECIMAL;
  vitesse_vent_ms DECIMAL;
BEGIN
  -- Formule Penman-Monteith simplifi√©e pour jardinage
  
  -- Conversion vitesse vent km/h -> m/s
  vitesse_vent_ms := vitesse_vent_kmh / 3.6;
  
  -- Calcul tension de vapeur saturante (kPa)
  tension_vapeur_sat := 0.6108 * EXP((17.27 * temperature_c) / (temperature_c + 237.3));
  
  -- Calcul tension vapeur actuelle 
  tension_vapeur_actuelle := tension_vapeur_sat * (humidite_pourcent / 100.0);
  
  -- Pente de la courbe tension vapeur/temp√©rature
  pente_tension_vapeur := (4098 * tension_vapeur_sat) / POWER(temperature_c + 237.3, 2);
  
  -- ET0 approximative (mm/jour)
  et0 := 0.0023 * (temperature_c + 17.8) * SQRT(tension_vapeur_sat - tension_vapeur_actuelle) * (1 + 0.65 * vitesse_vent_ms);
  
  -- Ajustement selon rayonnement si disponible
  IF rayonnement_solaire IS NOT NULL THEN
    et0 := et0 * (1 + rayonnement_solaire / 25.0); -- Facteur approximatif
  END IF;
  
  RETURN GREATEST(0.0, LEAST(15.0, et0)); -- Born√© entre 0 et 15 mm/jour
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Trigger pour calcul automatique des m√©triques
CREATE OR REPLACE FUNCTION update_instance_culture_metrics()
RETURNS TRIGGER AS $$
BEGIN
  -- Calculer taux de survie si quantit√©s disponibles
  IF NEW.quantite_plantee > 0 AND NEW.quantite_germee IS NOT NULL THEN
    NEW.taux_survie := NEW.quantite_germee::DECIMAL / NEW.quantite_plantee;
  END IF;
  
  -- Mettre √† jour status d√©riv√© selon les dates
  IF NEW.date_fin_cycle IS NOT NULL THEN
    NEW.etape_cycle_vie := 'TERMINE';
  ELSIF NEW.date_premiere_recolte IS NOT NULL THEN
    NEW.etape_cycle_vie := 'RECOLTE';
  ELSIF NEW.date_repiquage_reelle IS NOT NULL THEN
    NEW.etape_cycle_vie := 'CROISSANCE';
  ELSIF NEW.date_semis_reelle IS NOT NULL THEN
    NEW.etape_cycle_vie := 'GERME';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_instance_culture_metrics
  BEFORE INSERT OR UPDATE ON instances_culture
  FOR EACH ROW EXECUTE FUNCTION update_instance_culture_metrics();
```

## **‚úÖ Crit√®res d'acceptation**

### **Architecture & Performance**
- [ ] **PostgreSQL 16+** avec extensions PostGIS, pg_stat_statements ‚úÖ
- [ ] **Prisma ORM** avec types TypeScript g√©n√©r√©s automatiquement ‚úÖ
- [ ] **Mod√®les extensibles** avec versioning et migrations ‚úÖ
- [ ] **Performance queries** < 500ms pour 95% des requ√™tes ‚úÖ

### **Int√©grit√© & Coh√©rence**
- [ ] **Contraintes m√©tier** valid√©es au niveau base de donn√©es ‚úÖ
- [ ] **Foreign keys** avec cascade appropri√©e ‚úÖ
- [ ] **Soft delete** pour toutes les entit√©s principales ‚úÖ
- [ ] **Audit automatique** avec timestamps et triggers ‚úÖ

### **Repository Pattern**
- [ ] **Couche d'abstraction** avec repositories s√©par√©s ‚úÖ
- [ ] **Cache intelligent** Redis avec TTL adaptatifs ‚úÖ
- [ ] **Transaction wrapper** avec retry automatique ‚úÖ
- [ ] **Health checks** pour monitoring continu ‚úÖ

### **Vues & Analytics**
- [ ] **Vues optimis√©es** pour dashboard temps r√©el ‚úÖ
- [ ] **Index composites** pour performance requ√™tes complexes ‚úÖ
- [ ] **Fonctions PostgreSQL** pour calculs m√©tier ‚úÖ
- [ ] **Triggers automatiques** pour coh√©rence donn√©es ‚úÖ

### **Extensions futures**
- [ ] **Structure IA-ready** avec JSON/JSONB optimis√©s ‚úÖ
- [ ] **Mod√®les IoT** pr√©par√©s pour ESP32/Home Assistant ‚úÖ
- [ ] **G√©ospatial PostGIS** pour fonctionnalit√©s location ‚úÖ
- [ ] **MCP integration** avec mod√®les serveur ‚úÖ

## **üèóÔ∏è Exigences architecturales couvertes**

- **EXG-001.3** : TypeScript strict avec types g√©n√©r√©s ‚úÖ
- **EXG-002.1** : PostgreSQL 16+ base unique ‚úÖ
- **EXG-002.2** : Prisma ORM + Prisma Adapter NextAuth.js ‚úÖ
- **EXG-002.3** : Redis cache applicatif ‚úÖ
- **EXG-007.2** : Optimisation m√©moire (6GB limit) ‚úÖ
- **EXG-007.3** : Performance < 2s (queries optimis√©es) ‚úÖ
- **EXG-008.2** : Chiffrement donn√©es sensibles ‚úÖ
- **EXG-010.2** : Sauvegardes automatis√©es PostgreSQL ‚úÖ

## **üìä M√©triques de performance cibles**

### **Database Performance**
- **Connection pool** : 20 connexions max
- **Query time P95** : < 500ms
- **Index usage** : > 95% des queries utilisent index
- **Cache hit ratio** : > 90% Redis cache

### **Data Growth Projections**
- **Users** : 100 utilisateurs max (local)
- **Jardins** : 500 jardins (5/utilisateur moyenne)
- **Zones** : 2000 zones (4/jardin moyenne)
- **R√©coltes** : 50k/an (100/jardin/an)
- **Storage** : ~10GB apr√®s 5 ans utilisation

## **üöÄ Plan d'impl√©mentation**

### **Phase 1 : Setup Base & NextAuth (3j)**
1. Configuration PostgreSQL + extensions
2. Setup Prisma avec mod√®les NextAuth
3. Migrations initiales et contraintes
4. Tests connexion et int√©grit√©

### **Phase 2 : Mod√®les Core M√©tier (4j)**
1. Mod√®les Jardin, Zone, Culture
2. Repository pattern avec cache Redis
3. Validation JSON Schema
4. Triggers et fonctions PostgreSQL

### **Phase 3 : Vues & Analytics (3j)**
1. Vues dashboard optimis√©es
2. Index composites pour performance
3. Fonctions calculs m√©tier avanc√©es
4. Tests performance avec donn√©es

### **Phase 4 : Extensions Avanc√©es (3j)**
1. Support PostGIS g√©ospatial
2. Mod√®les IA et IoT pr√©paratoires
3. Service transaction avec retry
4. Health checks et monitoring

### **Phase 5 : Optimisation & Tests (2j)**
1. Optimisation queries lentes
2. Load testing avec donn√©es r√©elles  
3. Scripts sauvegarde/restore
4. Documentation compl√®te

**Dur√©e totale estim√©e : 15 jours**